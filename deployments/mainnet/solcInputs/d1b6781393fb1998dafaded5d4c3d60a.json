{
  "language": "Solidity",
  "sources": {
    "contracts/DInterest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"./libs/SafeERC20.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {BoringOwnable} from \"./libs/BoringOwnable.sol\";\nimport {MulticallUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\";\nimport {MoneyMarket} from \"./moneymarkets/MoneyMarket.sol\";\nimport {IFeeModel} from \"./models/fee/IFeeModel.sol\";\nimport {IInterestModel} from \"./models/interest/IInterestModel.sol\";\nimport {NFT} from \"./tokens/NFT.sol\";\nimport {FundingMultitoken} from \"./tokens/FundingMultitoken.sol\";\nimport {MPHMinter} from \"./rewards/MPHMinter.sol\";\nimport {IInterestOracle} from \"./models/interest-oracle/IInterestOracle.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {Rescuable} from \"./libs/Rescuable.sol\";\nimport {console} from \"hardhat/console.sol\";\n\n/**\n    @title DeLorean Interest -- It's coming back from the future!\n    @author Zefram Lou\n    @notice The main pool contract for fixed-rate deposits\n    @dev The contract to interact with for most actions\n */\ncontract DInterest is\n    ReentrancyGuardUpgradeable,\n    BoringOwnable,\n    Rescuable,\n    MulticallUpgradeable\n{\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n    using PRBMathUD60x18 for uint256;\n\n    // Constants\n    uint256 internal constant PRECISION = 10**18;\n    /**\n        @dev used for sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex\n     */\n    uint256 internal constant EXTRA_PRECISION = 10**27;\n    /**\n        @dev used for funding.principalPerToken\n     */\n    uint256 internal constant ULTRA_PRECISION = 2**128;\n    /**\n        @dev Specifies the threshold for paying out funder interests\n     */\n    uint256 internal constant FUNDER_PAYOUT_THRESHOLD_DIVISOR = 10**10;\n\n    // User deposit data\n    // Each deposit has an ID used in the depositNFT, which is equal to its index in `deposits` plus 1\n    struct Deposit {\n        uint256 virtualTokenTotalSupply; // depositAmount + interestAmount, behaves like a zero coupon bond\n        uint256 interestRate; // interestAmount = interestRate * depositAmount\n        uint256 feeRate; // feeAmount = feeRate * depositAmount\n        uint256 averageRecordedIncomeIndex; // Average income index at time of deposit, used for computing deposit surplus\n        uint64 maturationTimestamp; // Unix timestamp after which the deposit may be withdrawn, in seconds\n        uint64 fundingID; // The ID of the associated Funding struct. 0 if not funded.\n    }\n    Deposit[] internal deposits;\n\n    // Funding data\n    // Each funding has an ID used in the fundingMultitoken, which is equal to its index in `fundingList` plus 1\n    struct Funding {\n        uint64 depositID; // The ID of the associated Deposit struct.\n        uint64 lastInterestPayoutTimestamp; // Unix timestamp of the most recent interest payout, in seconds\n        uint256 recordedMoneyMarketIncomeIndex; // the income index at the last update (creation or withdrawal)\n        uint256 principalPerToken; // The amount of stablecoins that's earning interest for you per funding token you own. Scaled to 18 decimals regardless of stablecoin decimals.\n    }\n    Funding[] internal fundingList;\n    // the sum of (recordedFundedPrincipalAmount / recordedMoneyMarketIncomeIndex) of all fundings\n    uint256 public sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex;\n\n    // Params\n    /**\n        @dev Maximum deposit period, in seconds\n     */\n    uint64 public MaxDepositPeriod;\n    /**\n        @dev Minimum deposit amount, in stablecoins\n     */\n    uint256 public MinDepositAmount;\n\n    // Global variables\n    uint256 public totalDeposit;\n    uint256 public totalInterestOwed;\n    uint256 public totalFeeOwed;\n    uint256 public totalFundedPrincipalAmount;\n\n    // External smart contracts\n    IFeeModel public feeModel;\n    IInterestModel public interestModel;\n    IInterestOracle public interestOracle;\n    NFT public depositNFT;\n    FundingMultitoken public fundingMultitoken;\n    MPHMinter public mphMinter;\n\n    // Extra params\n    /**\n        @dev The maximum amount of deposit in the pool. Set to 0 to disable the cap.\n     */\n    uint256 public GlobalDepositCap;\n\n    // Events\n    event EDeposit(\n        address indexed sender,\n        uint256 indexed depositID,\n        uint256 depositAmount,\n        uint256 interestAmount,\n        uint256 feeAmount,\n        uint64 maturationTimestamp\n    );\n    event ETopupDeposit(\n        address indexed sender,\n        uint64 indexed depositID,\n        uint256 depositAmount,\n        uint256 interestAmount,\n        uint256 feeAmount\n    );\n    event ERolloverDeposit(\n        address indexed sender,\n        uint64 indexed depositID,\n        uint64 indexed newDepositID\n    );\n    event EWithdraw(\n        address indexed sender,\n        uint256 indexed depositID,\n        bool indexed early,\n        uint256 virtualTokenAmount,\n        uint256 feeAmount\n    );\n    event EFund(\n        address indexed sender,\n        uint64 indexed fundingID,\n        uint256 fundAmount,\n        uint256 tokenAmount\n    );\n    event EPayFundingInterest(\n        uint256 indexed fundingID,\n        uint256 interestAmount,\n        uint256 refundAmount\n    );\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n    event ESetParamUint(\n        address indexed sender,\n        string indexed paramName,\n        uint256 newValue\n    );\n\n    function __DInterest_init(\n        uint64 _MaxDepositPeriod,\n        uint256 _MinDepositAmount,\n        address _feeModel,\n        address _interestModel,\n        address _interestOracle,\n        address _depositNFT,\n        address _fundingMultitoken,\n        address _mphMinter\n    ) internal initializer {\n        __ReentrancyGuard_init();\n        __Ownable_init();\n\n        feeModel = IFeeModel(_feeModel);\n        interestModel = IInterestModel(_interestModel);\n        interestOracle = IInterestOracle(_interestOracle);\n        depositNFT = NFT(_depositNFT);\n        fundingMultitoken = FundingMultitoken(_fundingMultitoken);\n        mphMinter = MPHMinter(_mphMinter);\n        MaxDepositPeriod = _MaxDepositPeriod;\n        MinDepositAmount = _MinDepositAmount;\n    }\n\n    /**\n        @param _MaxDepositPeriod The maximum deposit period, in seconds\n        @param _MinDepositAmount The minimum deposit amount, in stablecoins\n        @param _feeModel Address of the FeeModel contract that determines how fees are charged\n        @param _interestModel Address of the InterestModel contract that determines how much interest to offer\n        @param _interestOracle Address of the InterestOracle contract that provides the average interest rate\n        @param _depositNFT Address of the NFT representing ownership of deposits (owner must be set to this DInterest contract)\n        @param _fundingMultitoken Address of the ERC1155 multitoken representing ownership of fundings (this DInterest contract must have the minter-burner role)\n        @param _mphMinter Address of the contract for handling minting MPH to users\n     */\n    function initialize(\n        uint64 _MaxDepositPeriod,\n        uint256 _MinDepositAmount,\n        address _feeModel,\n        address _interestModel,\n        address _interestOracle,\n        address _depositNFT,\n        address _fundingMultitoken,\n        address _mphMinter\n    ) external virtual initializer {\n        __DInterest_init(\n            _MaxDepositPeriod,\n            _MinDepositAmount,\n            _feeModel,\n            _interestModel,\n            _interestOracle,\n            _depositNFT,\n            _fundingMultitoken,\n            _mphMinter\n        );\n    }\n\n    /**\n        Public action functions\n     */\n\n    /**\n        @notice Create a deposit using `depositAmount` stablecoin that matures at timestamp `maturationTimestamp`.\n        @dev The ERC-721 NFT representing deposit ownership is given to msg.sender\n        @param depositAmount The amount of deposit, in stablecoin\n        @param maturationTimestamp The Unix timestamp of maturation, in seconds\n        @return depositID The ID of the created deposit\n        @return interestAmount The amount of fixed-rate interest\n     */\n    function deposit(uint256 depositAmount, uint64 maturationTimestamp)\n        external\n        nonReentrant\n        returns (uint64 depositID, uint256 interestAmount)\n    {\n        return\n            _deposit(\n                msg.sender,\n                depositAmount,\n                maturationTimestamp,\n                false,\n                0,\n                \"\"\n            );\n    }\n\n    /**\n        @notice Create a deposit using `depositAmount` stablecoin that matures at timestamp `maturationTimestamp`.\n        @dev The ERC-721 NFT representing deposit ownership is given to msg.sender\n        @param depositAmount The amount of deposit, in stablecoin\n        @param maturationTimestamp The Unix timestamp of maturation, in seconds\n        @param minimumInterestAmount If the interest amount is less than this, revert\n        @param uri The metadata URI for the minted NFT\n        @return depositID The ID of the created deposit\n        @return interestAmount The amount of fixed-rate interest\n     */\n    function deposit(\n        uint256 depositAmount,\n        uint64 maturationTimestamp,\n        uint256 minimumInterestAmount,\n        string calldata uri\n    ) external nonReentrant returns (uint64 depositID, uint256 interestAmount) {\n        return\n            _deposit(\n                msg.sender,\n                depositAmount,\n                maturationTimestamp,\n                false,\n                minimumInterestAmount,\n                uri\n            );\n    }\n\n    /**\n        @notice Add `depositAmount` stablecoin to the existing deposit with ID `depositID`.\n        @dev The interest rate for the topped up funds will be the current oracle rate.\n        @param depositID The deposit to top up\n        @param depositAmount The amount to top up, in stablecoin\n        @return interestAmount The amount of interest that will be earned by the topped up funds at maturation\n     */\n    function topupDeposit(uint64 depositID, uint256 depositAmount)\n        external\n        nonReentrant\n        returns (uint256 interestAmount)\n    {\n        return _topupDeposit(msg.sender, depositID, depositAmount, 0);\n    }\n\n    /**\n        @notice Add `depositAmount` stablecoin to the existing deposit with ID `depositID`.\n        @dev The interest rate for the topped up funds will be the current oracle rate.\n        @param depositID The deposit to top up\n        @param depositAmount The amount to top up, in stablecoin\n        @param minimumInterestAmount If the interest amount is less than this, revert\n        @return interestAmount The amount of interest that will be earned by the topped up funds at maturation\n     */\n    function topupDeposit(\n        uint64 depositID,\n        uint256 depositAmount,\n        uint256 minimumInterestAmount\n    ) external nonReentrant returns (uint256 interestAmount) {\n        return\n            _topupDeposit(\n                msg.sender,\n                depositID,\n                depositAmount,\n                minimumInterestAmount\n            );\n    }\n\n    /**\n        @notice Withdraw all funds from deposit with ID `depositID` and use them\n                to create a new deposit that matures at time `maturationTimestamp`\n        @param depositID The deposit to roll over\n        @param maturationTimestamp The Unix timestamp of the new deposit, in seconds\n        @return newDepositID The ID of the new deposit\n     */\n    function rolloverDeposit(uint64 depositID, uint64 maturationTimestamp)\n        external\n        nonReentrant\n        returns (uint256 newDepositID, uint256 interestAmount)\n    {\n        return\n            _rolloverDeposit(msg.sender, depositID, maturationTimestamp, 0, \"\");\n    }\n\n    /**\n        @notice Withdraw all funds from deposit with ID `depositID` and use them\n                to create a new deposit that matures at time `maturationTimestamp`\n        @param depositID The deposit to roll over\n        @param maturationTimestamp The Unix timestamp of the new deposit, in seconds\n        @param minimumInterestAmount If the interest amount is less than this, revert\n        @param uri The metadata URI of the NFT\n        @return newDepositID The ID of the new deposit\n     */\n    function rolloverDeposit(\n        uint64 depositID,\n        uint64 maturationTimestamp,\n        uint256 minimumInterestAmount,\n        string calldata uri\n    )\n        external\n        nonReentrant\n        returns (uint256 newDepositID, uint256 interestAmount)\n    {\n        return\n            _rolloverDeposit(\n                msg.sender,\n                depositID,\n                maturationTimestamp,\n                minimumInterestAmount,\n                uri\n            );\n    }\n\n    /**\n        @notice Withdraws funds from the deposit with ID `depositID`.\n        @dev Virtual tokens behave like zero coupon bonds, after maturation withdrawing 1 virtual token\n             yields 1 stablecoin. The total supply is given by deposit.virtualTokenTotalSupply\n        @param depositID the deposit to withdraw from\n        @param virtualTokenAmount the amount of virtual tokens to withdraw\n        @param early True if intend to withdraw before maturation, false otherwise\n        @return withdrawnStablecoinAmount the amount of stablecoins withdrawn\n     */\n    function withdraw(\n        uint64 depositID,\n        uint256 virtualTokenAmount,\n        bool early\n    ) external nonReentrant returns (uint256 withdrawnStablecoinAmount) {\n        return\n            _withdraw(msg.sender, depositID, virtualTokenAmount, early, false);\n    }\n\n    /**\n        @notice Funds the fixed-rate interest of the deposit with ID `depositID`.\n                In exchange, the funder receives the future floating-rate interest\n                generated by the portion of the deposit whose interest was funded.\n        @dev The sender receives ERC-1155 multitokens (fundingMultitoken) representing\n             their funding position.\n        @param depositID The deposit whose fixed-rate interest will be funded\n        @param fundAmount The amount of stablecoins to pay for the fundingMultitokens.\n                          If it exceeds the upper bound, it will be set to\n                          the bound value instead. (See {_fund} implementation)\n        @return fundingID The ID of the fundingMultitoken the sender received\n        @return fundingMultitokensMinted The amount of fundingMultitokens minted to the sender\n        @return actualFundAmount The amount of stablecoins paid by the sender\n        @return principalFunded The amount of principal the minted fundingMultitokens is earning yield on\n     */\n    function fund(uint64 depositID, uint256 fundAmount)\n        external\n        nonReentrant\n        returns (\n            uint64 fundingID,\n            uint256 fundingMultitokensMinted,\n            uint256 actualFundAmount,\n            uint256 principalFunded\n        )\n    {\n        return _fund(msg.sender, depositID, fundAmount, 0);\n    }\n\n    /**\n        @notice Funds the fixed-rate interest of the deposit with ID `depositID`.\n                In exchange, the funder receives the future floating-rate interest\n                generated by the portion of the deposit whose interest was funded.\n        @dev The sender receives ERC-1155 multitokens (fundingMultitoken) representing\n             their funding position.\n        @param depositID The deposit whose fixed-rate interest will be funded\n        @param fundAmount The amount of stablecoins to pay for the fundingMultitokens.\n                          If it exceeds the upper bound, it will be set to\n                          the bound value instead. (See {_fund} implementation)\n        @param minPrincipalFunded The minimum amount of principalFunded, below which the tx will revert\n        @return fundingID The ID of the fundingMultitoken the sender received\n        @return fundingMultitokensMinted The amount of fundingMultitokens minted to the sender\n        @return actualFundAmount The amount of stablecoins paid by the sender\n        @return principalFunded The amount of principal the minted fundingMultitokens is earning yield on\n     */\n    function fund(\n        uint64 depositID,\n        uint256 fundAmount,\n        uint256 minPrincipalFunded\n    )\n        external\n        nonReentrant\n        returns (\n            uint64 fundingID,\n            uint256 fundingMultitokensMinted,\n            uint256 actualFundAmount,\n            uint256 principalFunded\n        )\n    {\n        return _fund(msg.sender, depositID, fundAmount, minPrincipalFunded);\n    }\n\n    /**\n        @notice Distributes the floating-rate interest accrued by a deposit to the\n                floating-rate bond holders.\n        @param fundingID The ID of the floating-rate bond\n        @return interestAmount The amount of interest distributed, in stablecoins\n     */\n    function payInterestToFunders(uint64 fundingID)\n        external\n        nonReentrant\n        returns (uint256 interestAmount)\n    {\n        return _payInterestToFunders(fundingID, moneyMarket().incomeIndex());\n    }\n\n    /**\n        Public getter functions\n     */\n\n    /**\n        @notice Computes the amount of fixed-rate interest (before fees) that\n                will be given to a deposit of `depositAmount` stablecoins that\n                matures in `depositPeriodInSeconds` seconds.\n        @param depositAmount The deposit amount, in stablecoins\n        @param depositPeriodInSeconds The deposit period, in seconds\n        @return interestAmount The amount of fixed-rate interest (before fees)\n     */\n    function calculateInterestAmount(\n        uint256 depositAmount,\n        uint256 depositPeriodInSeconds\n    ) public virtual returns (uint256 interestAmount) {\n        (, uint256 moneyMarketInterestRatePerSecond) = interestOracle\n            .updateAndQuery();\n        (bool surplusIsNegative, uint256 surplusAmount) = surplus();\n\n        return\n            interestModel.calculateInterestAmount(\n                depositAmount,\n                depositPeriodInSeconds,\n                moneyMarketInterestRatePerSecond,\n                surplusIsNegative,\n                surplusAmount\n            );\n    }\n\n    /**\n        @notice Computes the pool's overall surplus, which is the value of its holdings\n                in the `moneyMarket` minus the amount owed to depositors, funders, and\n                the fee beneficiary.\n        @return isNegative True if the surplus is negative, false otherwise\n        @return surplusAmount The absolute value of the surplus, in stablecoins\n     */\n    function surplus()\n        public\n        virtual\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        return _surplus(moneyMarket().incomeIndex());\n    }\n\n    /**\n        @notice Returns the total number of deposits.\n        @return deposits.length\n     */\n    function depositsLength() external view returns (uint256) {\n        return deposits.length;\n    }\n\n    /**\n        @notice Returns the total number of floating-rate bonds.\n        @return fundingList.length\n     */\n    function fundingListLength() external view returns (uint256) {\n        return fundingList.length;\n    }\n\n    /**\n        @notice Returns the Deposit struct associated with the deposit with ID\n                `depositID`.\n        @param depositID The ID of the deposit\n        @return The deposit struct\n     */\n    function getDeposit(uint64 depositID)\n        external\n        view\n        returns (Deposit memory)\n    {\n        return deposits[depositID - 1];\n    }\n\n    /**\n        @notice Returns the Funding struct associated with the floating-rate bond with ID\n                `fundingID`.\n        @param fundingID The ID of the floating-rate bond\n        @return The Funding struct\n     */\n    function getFunding(uint64 fundingID)\n        external\n        view\n        returns (Funding memory)\n    {\n        return fundingList[fundingID - 1];\n    }\n\n    /**\n        @notice Returns the moneyMarket contract\n        @return The moneyMarket\n     */\n    function moneyMarket() public view returns (MoneyMarket) {\n        return interestOracle.moneyMarket();\n    }\n\n    /**\n        @notice Returns the stablecoin ERC20 token contract\n        @return The stablecoin\n     */\n    function stablecoin() public view returns (ERC20) {\n        return moneyMarket().stablecoin();\n    }\n\n    /**\n        Internal action functions\n     */\n\n    /**\n        @dev See {deposit}\n     */\n    function _deposit(\n        address sender,\n        uint256 depositAmount,\n        uint64 maturationTimestamp,\n        bool rollover,\n        uint256 minimumInterestAmount,\n        string memory uri\n    ) internal virtual returns (uint64 depositID, uint256 interestAmount) {\n        (depositID, interestAmount) = _depositRecordData(\n            sender,\n            depositAmount,\n            maturationTimestamp,\n            minimumInterestAmount,\n            uri\n        );\n        _depositTransferFunds(sender, depositAmount, rollover);\n    }\n\n    function _depositRecordData(\n        address sender,\n        uint256 depositAmount,\n        uint64 maturationTimestamp,\n        uint256 minimumInterestAmount,\n        string memory uri\n    ) internal virtual returns (uint64 depositID, uint256 interestAmount) {\n        // Ensure input is valid\n        require(depositAmount >= MinDepositAmount, \"BAD_AMOUNT\");\n        uint256 depositPeriod = maturationTimestamp - block.timestamp;\n        require(depositPeriod <= MaxDepositPeriod, \"BAD_TIME\");\n\n        // Calculate interest\n        interestAmount = calculateInterestAmount(depositAmount, depositPeriod);\n        require(\n            interestAmount > 0 && interestAmount >= minimumInterestAmount,\n            \"BAD_INTEREST\"\n        );\n\n        // Calculate fee\n        uint256 feeAmount = feeModel.getInterestFeeAmount(\n            address(this),\n            interestAmount\n        );\n        interestAmount -= feeAmount;\n\n        // Record deposit data\n        deposits.push(\n            Deposit({\n                virtualTokenTotalSupply: depositAmount + interestAmount,\n                interestRate: interestAmount.div(depositAmount),\n                feeRate: feeAmount.div(depositAmount),\n                maturationTimestamp: maturationTimestamp,\n                fundingID: 0,\n                averageRecordedIncomeIndex: interestOracle\n                    .moneyMarket()\n                    .incomeIndex()\n            })\n        );\n        require(deposits.length <= type(uint64).max, \"OVERFLOW\");\n        depositID = uint64(deposits.length);\n\n        // Update global values\n        totalDeposit += depositAmount;\n        {\n            uint256 depositCap = GlobalDepositCap;\n            require(depositCap == 0 || totalDeposit <= depositCap, \"CAP\");\n        }\n        totalInterestOwed += interestAmount;\n        totalFeeOwed += feeAmount;\n\n        // Mint depositNFT\n        if (bytes(uri).length == 0) {\n            depositNFT.mint(sender, depositID);\n        } else {\n            depositNFT.mint(sender, depositID, uri);\n        }\n\n        // Emit event\n        emit EDeposit(\n            sender,\n            depositID,\n            depositAmount,\n            interestAmount,\n            feeAmount,\n            maturationTimestamp\n        );\n\n        // Vest MPH to sender\n        mphMinter.createVestForDeposit(sender, depositID);\n    }\n\n    function _depositTransferFunds(\n        address sender,\n        uint256 depositAmount,\n        bool rollover\n    ) internal virtual {\n        // Only transfer funds from sender if it's not a rollover\n        // because if it is the funds are already in the contract\n        if (!rollover) {\n            ERC20 _stablecoin = stablecoin();\n\n            // Transfer `depositAmount` stablecoin to DInterest\n            _stablecoin.safeTransferFrom(sender, address(this), depositAmount);\n\n            // Lend `depositAmount` stablecoin to money market\n            MoneyMarket _moneyMarket = moneyMarket();\n            _stablecoin.safeIncreaseAllowance(\n                address(_moneyMarket),\n                depositAmount\n            );\n            _moneyMarket.deposit(depositAmount);\n        }\n    }\n\n    /**\n        @dev See {topupDeposit}\n     */\n    function _topupDeposit(\n        address sender,\n        uint64 depositID,\n        uint256 depositAmount,\n        uint256 minimumInterestAmount\n    ) internal virtual returns (uint256 interestAmount) {\n        interestAmount = _topupDepositRecordData(\n            sender,\n            depositID,\n            depositAmount,\n            minimumInterestAmount\n        );\n        _topupDepositTransferFunds(sender, depositAmount);\n    }\n\n    function _topupDepositRecordData(\n        address sender,\n        uint64 depositID,\n        uint256 depositAmount,\n        uint256 minimumInterestAmount\n    ) internal virtual returns (uint256 interestAmount) {\n        Deposit storage depositEntry = _getDeposit(depositID);\n        require(depositNFT.ownerOf(depositID) == sender, \"NOT_OWNER\");\n\n        // underflow check prevents topups after maturation\n        uint256 depositPeriod = depositEntry.maturationTimestamp -\n            block.timestamp;\n\n        // Calculate interest\n        interestAmount = calculateInterestAmount(depositAmount, depositPeriod);\n        require(\n            interestAmount > 0 && interestAmount >= minimumInterestAmount,\n            \"BAD_INTEREST\"\n        );\n\n        // Calculate fee\n        uint256 feeAmount = feeModel.getInterestFeeAmount(\n            address(this),\n            interestAmount\n        );\n        interestAmount -= feeAmount;\n\n        // Update deposit struct\n        uint256 interestRate = depositEntry.interestRate;\n        uint256 currentDepositAmount = depositEntry.virtualTokenTotalSupply.div(\n            interestRate + PRECISION\n        );\n        depositEntry.virtualTokenTotalSupply += depositAmount + interestAmount;\n        depositEntry.interestRate =\n            (PRECISION * interestAmount + currentDepositAmount * interestRate) /\n            (depositAmount + currentDepositAmount);\n        depositEntry.feeRate =\n            (PRECISION *\n                feeAmount +\n                currentDepositAmount *\n                depositEntry.feeRate) /\n            (depositAmount + currentDepositAmount);\n        uint256 sumOfRecordedDepositAmountDivRecordedIncomeIndex = (currentDepositAmount *\n                EXTRA_PRECISION) /\n                depositEntry.averageRecordedIncomeIndex +\n                (depositAmount * EXTRA_PRECISION) /\n                moneyMarket().incomeIndex();\n        depositEntry.averageRecordedIncomeIndex =\n            ((depositAmount + currentDepositAmount) * EXTRA_PRECISION) /\n            sumOfRecordedDepositAmountDivRecordedIncomeIndex;\n\n        // Update global values\n        totalDeposit += depositAmount;\n        {\n            uint256 depositCap = GlobalDepositCap;\n            require(depositCap == 0 || totalDeposit <= depositCap, \"CAP\");\n        }\n        totalInterestOwed += interestAmount;\n        totalFeeOwed += feeAmount;\n\n        // Emit event\n        emit ETopupDeposit(\n            sender,\n            depositID,\n            depositAmount,\n            interestAmount,\n            feeAmount\n        );\n\n        // Update vest\n        mphMinter.updateVestForDeposit(\n            depositID,\n            currentDepositAmount,\n            depositAmount\n        );\n    }\n\n    function _topupDepositTransferFunds(address sender, uint256 depositAmount)\n        internal\n        virtual\n    {\n        ERC20 _stablecoin = stablecoin();\n\n        // Transfer `depositAmount` stablecoin to DInterest\n        _stablecoin.safeTransferFrom(sender, address(this), depositAmount);\n\n        // Lend `depositAmount` stablecoin to money market\n        MoneyMarket _moneyMarket = moneyMarket();\n        _stablecoin.safeIncreaseAllowance(address(_moneyMarket), depositAmount);\n        _moneyMarket.deposit(depositAmount);\n    }\n\n    /**\n        @dev See {rolloverDeposit}\n     */\n    function _rolloverDeposit(\n        address sender,\n        uint64 depositID,\n        uint64 maturationTimestamp,\n        uint256 minimumInterestAmount,\n        string memory uri\n    ) internal virtual returns (uint64 newDepositID, uint256 interestAmount) {\n        // withdraw from existing deposit\n        uint256 withdrawnStablecoinAmount = _withdraw(\n            sender,\n            depositID,\n            type(uint256).max,\n            false,\n            true\n        );\n\n        // deposit funds into a new deposit\n        (newDepositID, interestAmount) = _deposit(\n            sender,\n            withdrawnStablecoinAmount,\n            maturationTimestamp,\n            true,\n            minimumInterestAmount,\n            uri\n        );\n\n        emit ERolloverDeposit(sender, depositID, newDepositID);\n    }\n\n    /**\n        @dev See {withdraw}\n        @param rollover True if being called from {_rolloverDeposit}, false otherwise\n     */\n    function _withdraw(\n        address sender,\n        uint64 depositID,\n        uint256 virtualTokenAmount,\n        bool early,\n        bool rollover\n    ) internal virtual returns (uint256 withdrawnStablecoinAmount) {\n        (\n            uint256 withdrawAmount,\n            uint256 feeAmount,\n            uint256 fundingInterestAmount,\n            uint256 refundAmount\n        ) = _withdrawRecordData(sender, depositID, virtualTokenAmount, early);\n        return\n            _withdrawTransferFunds(\n                sender,\n                _getDeposit(depositID).fundingID,\n                withdrawAmount,\n                feeAmount,\n                fundingInterestAmount,\n                refundAmount,\n                rollover\n            );\n    }\n\n    function _withdrawRecordData(\n        address sender,\n        uint64 depositID,\n        uint256 virtualTokenAmount,\n        bool early\n    )\n        internal\n        virtual\n        returns (\n            uint256 withdrawAmount,\n            uint256 feeAmount,\n            uint256 fundingInterestAmount,\n            uint256 refundAmount\n        )\n    {\n        // Verify input\n        require(virtualTokenAmount > 0, \"BAD_AMOUNT\");\n        Deposit storage depositEntry = _getDeposit(depositID);\n        if (early) {\n            require(\n                block.timestamp < depositEntry.maturationTimestamp,\n                \"MATURE\"\n            );\n        } else {\n            require(\n                block.timestamp >= depositEntry.maturationTimestamp,\n                \"IMMATURE\"\n            );\n        }\n        require(depositNFT.ownerOf(depositID) == sender, \"NOT_OWNER\");\n\n        // Check if withdrawing all funds\n        {\n            uint256 virtualTokenTotalSupply = depositEntry\n                .virtualTokenTotalSupply;\n            if (virtualTokenAmount > virtualTokenTotalSupply) {\n                virtualTokenAmount = virtualTokenTotalSupply;\n            }\n        }\n\n        // Compute token amounts\n        uint256 interestRate = depositEntry.interestRate;\n        uint256 feeRate = depositEntry.feeRate;\n        uint256 depositAmount = virtualTokenAmount.div(\n            interestRate + PRECISION\n        );\n        {\n            uint256 interestAmount = early\n                ? 0\n                : virtualTokenAmount - depositAmount;\n            withdrawAmount = depositAmount + interestAmount;\n        }\n        if (early) {\n            // apply fee to withdrawAmount\n            uint256 earlyWithdrawFee = feeModel.getEarlyWithdrawFeeAmount(\n                address(this),\n                depositID,\n                withdrawAmount\n            );\n            feeAmount = earlyWithdrawFee;\n            withdrawAmount -= earlyWithdrawFee;\n        } else {\n            feeAmount = depositAmount.mul(feeRate);\n        }\n\n        // Update global values\n        totalDeposit -= depositAmount;\n        totalInterestOwed -= virtualTokenAmount - depositAmount;\n        totalFeeOwed -= depositAmount.mul(feeRate);\n\n        // If deposit was funded, compute funding interest payout\n        uint64 fundingID = depositEntry.fundingID;\n        if (fundingID > 0) {\n            Funding storage funding = _getFunding(fundingID);\n\n            // Compute funded deposit amount before withdrawal\n            uint256 recordedFundedPrincipalAmount = (fundingMultitoken\n                .totalSupply(fundingID) * funding.principalPerToken) /\n                ULTRA_PRECISION;\n\n            // Shrink funding principal per token value\n            {\n                uint256 totalPrincipal = _depositVirtualTokenToPrincipal(\n                    depositID,\n                    depositEntry.virtualTokenTotalSupply\n                );\n                uint256 totalPrincipalDecrease = virtualTokenAmount +\n                    depositAmount.mul(feeRate);\n                if (\n                    totalPrincipal <=\n                    totalPrincipalDecrease + recordedFundedPrincipalAmount\n                ) {\n                    // Not enough unfunded principal, need to decrease funding principal per token value\n                    funding.principalPerToken = (totalPrincipal >=\n                        totalPrincipalDecrease)\n                        ? (funding.principalPerToken *\n                            (totalPrincipal - totalPrincipalDecrease)) /\n                            recordedFundedPrincipalAmount\n                        : 0;\n                }\n            }\n\n            // Compute interest payout + refund\n            // and update relevant state\n            (\n                fundingInterestAmount,\n                refundAmount\n            ) = _computeAndUpdateFundingInterestAfterWithdraw(\n                fundingID,\n                recordedFundedPrincipalAmount,\n                early\n            );\n        }\n\n        // Update vest\n        {\n            uint256 depositAmountBeforeWithdrawal = _getDeposit(depositID)\n                .virtualTokenTotalSupply\n                .div(interestRate + PRECISION);\n            mphMinter.updateVestForDeposit(\n                depositID,\n                depositAmountBeforeWithdrawal,\n                0\n            );\n        }\n\n        // Burn `virtualTokenAmount` deposit virtual tokens\n        _getDeposit(depositID).virtualTokenTotalSupply -= virtualTokenAmount;\n\n        // Emit event\n        emit EWithdraw(sender, depositID, early, virtualTokenAmount, feeAmount);\n    }\n\n    function _withdrawTransferFunds(\n        address sender,\n        uint64 fundingID,\n        uint256 withdrawAmount,\n        uint256 feeAmount,\n        uint256 fundingInterestAmount,\n        uint256 refundAmount,\n        bool rollover\n    ) internal virtual returns (uint256 withdrawnStablecoinAmount) {\n        ERC20 _stablecoin = stablecoin();\n\n        // Withdraw funds from money market\n        // Withdraws principal together with funding interest to save gas\n        if (rollover) {\n            // Rollover mode, don't withdraw `withdrawAmount` from moneyMarket\n\n            // We do this because feePlusFundingInterest might\n            // be slightly less due to rounding\n            uint256 feePlusFundingInterest = moneyMarket().withdraw(\n                feeAmount + fundingInterestAmount\n            );\n            if (feePlusFundingInterest >= feeAmount + fundingInterestAmount) {\n                // enough to pay everything, if there's extra give to feeAmount\n                feeAmount = feePlusFundingInterest - fundingInterestAmount;\n            } else if (feePlusFundingInterest >= feeAmount) {\n                // enough to pay fee, give remainder to fundingInterestAmount\n                fundingInterestAmount = feePlusFundingInterest - feeAmount;\n            } else {\n                // not enough to pay fee, give everything to fee\n                feeAmount = feePlusFundingInterest;\n                fundingInterestAmount = 0;\n            }\n\n            // we're keeping the withdrawal amount in the money market\n            withdrawnStablecoinAmount = withdrawAmount;\n        } else {\n            uint256 actualWithdrawnAmount = moneyMarket().withdraw(\n                withdrawAmount + feeAmount + fundingInterestAmount\n            );\n\n            // We do this because `actualWithdrawnAmount` might\n            // be slightly less due to rounding\n            withdrawnStablecoinAmount = withdrawAmount;\n            if (\n                actualWithdrawnAmount >=\n                withdrawAmount + feeAmount + fundingInterestAmount\n            ) {\n                // enough to pay everything, if there's extra give to feeAmount\n                feeAmount =\n                    actualWithdrawnAmount -\n                    withdrawAmount -\n                    fundingInterestAmount;\n            } else if (actualWithdrawnAmount >= withdrawAmount + feeAmount) {\n                // enough to pay withdrawal + fee + remainder\n                // give remainder to funding interest\n                fundingInterestAmount =\n                    actualWithdrawnAmount -\n                    withdrawAmount -\n                    feeAmount;\n            } else if (actualWithdrawnAmount >= withdrawAmount) {\n                // enough to pay withdrawal + remainder\n                // give remainder to fee\n                feeAmount = actualWithdrawnAmount - withdrawAmount;\n                fundingInterestAmount = 0;\n            } else {\n                // not enough to pay withdrawal\n                // give everything to withdrawal\n                withdrawnStablecoinAmount = actualWithdrawnAmount;\n                feeAmount = 0;\n                fundingInterestAmount = 0;\n            }\n\n            if (withdrawnStablecoinAmount > 0) {\n                _stablecoin.safeTransfer(sender, withdrawnStablecoinAmount);\n            }\n        }\n\n        // Send `feeAmount` stablecoin to feeModel beneficiary\n        if (feeAmount > 0) {\n            _stablecoin.safeTransfer(feeModel.beneficiary(), feeAmount);\n        }\n\n        // Distribute `fundingInterestAmount` stablecoins to funders\n        if (fundingInterestAmount > 0) {\n            _stablecoin.safeIncreaseAllowance(\n                address(fundingMultitoken),\n                fundingInterestAmount\n            );\n            fundingMultitoken.distributeDividends(\n                fundingID,\n                address(_stablecoin),\n                fundingInterestAmount\n            );\n            // Mint funder rewards\n            if (fundingInterestAmount > refundAmount) {\n                _distributeFundingRewards(\n                    fundingID,\n                    fundingInterestAmount - refundAmount\n                );\n            }\n        }\n    }\n\n    /**\n        @dev See {fund}\n     */\n    function _fund(\n        address sender,\n        uint64 depositID,\n        uint256 fundAmount,\n        uint256 minPrincipalFunded\n    )\n        internal\n        virtual\n        returns (\n            uint64 fundingID,\n            uint256 fundingMultitokensMinted,\n            uint256 actualFundAmount,\n            uint256 principalFunded\n        )\n    {\n        (\n            fundingID,\n            fundingMultitokensMinted,\n            actualFundAmount,\n            principalFunded\n        ) = _fundRecordData(sender, depositID, fundAmount, minPrincipalFunded);\n        _fundTransferFunds(sender, actualFundAmount);\n    }\n\n    function _fundRecordData(\n        address sender,\n        uint64 depositID,\n        uint256 fundAmount,\n        uint256 minPrincipalFunded\n    )\n        internal\n        virtual\n        returns (\n            uint64 fundingID,\n            uint256 fundingMultitokensMinted,\n            uint256 actualFundAmount,\n            uint256 principalFunded\n        )\n    {\n        Deposit storage depositEntry = _getDeposit(depositID);\n        fundingID = depositEntry.fundingID;\n        uint256 incomeIndex = moneyMarket().incomeIndex();\n\n        // Create funding struct if one doesn't exist\n        {\n            uint256 virtualTokenTotalSupply = depositEntry\n                .virtualTokenTotalSupply;\n            uint256 totalPrincipal = _depositVirtualTokenToPrincipal(\n                depositID,\n                virtualTokenTotalSupply\n            );\n            uint256 depositAmount = virtualTokenTotalSupply.div(\n                depositEntry.interestRate + PRECISION\n            );\n            if (\n                fundingID == 0 || _getFunding(fundingID).principalPerToken == 0\n            ) {\n                // The first funder, create struct\n                require(block.timestamp <= type(uint64).max, \"OVERFLOW\");\n                fundingList.push(\n                    Funding({\n                        depositID: depositID,\n                        lastInterestPayoutTimestamp: uint64(block.timestamp),\n                        recordedMoneyMarketIncomeIndex: incomeIndex,\n                        principalPerToken: ULTRA_PRECISION\n                    })\n                );\n                require(fundingList.length <= type(uint64).max, \"OVERFLOW\");\n                fundingID = uint64(fundingList.length);\n                depositEntry.fundingID = fundingID;\n\n                // Bound fundAmount upwards by the fixed rate yield amount\n                uint256 bound = calculateInterestAmount(\n                    depositAmount,\n                    depositEntry.maturationTimestamp - block.timestamp\n                );\n                if (fundAmount > bound) {\n                    fundAmount = bound;\n                }\n\n                principalFunded = (totalPrincipal * fundAmount) / bound;\n                fundingMultitokensMinted = principalFunded;\n            } else {\n                // Not the first funder\n                // Trigger interest payment for existing funders\n                _payInterestToFunders(fundingID, incomeIndex);\n\n                // Compute amount of principal to fund\n                uint256 principalPerToken = _getFunding(fundingID)\n                    .principalPerToken;\n                uint256 unfundedPrincipalAmount = totalPrincipal -\n                    (fundingMultitoken.totalSupply(fundingID) *\n                        principalPerToken) /\n                    ULTRA_PRECISION;\n\n                // Bound fundAmount upwards by the fixed rate yield amount\n                uint256 bound = calculateInterestAmount(\n                    (depositAmount * unfundedPrincipalAmount) / totalPrincipal,\n                    depositEntry.maturationTimestamp - block.timestamp\n                );\n                if (fundAmount > bound) {\n                    fundAmount = bound;\n                }\n                principalFunded =\n                    (unfundedPrincipalAmount * fundAmount) /\n                    bound;\n                fundingMultitokensMinted =\n                    (principalFunded * ULTRA_PRECISION) /\n                    principalPerToken;\n            }\n        }\n\n        // Check principalFunded is at least minPrincipalFunded\n        require(principalFunded >= minPrincipalFunded, \"MIN\");\n\n        // Mint funding multitoken\n        fundingMultitoken.mint(sender, fundingID, fundingMultitokensMinted);\n\n        // Update relevant values\n        sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +=\n            (principalFunded * EXTRA_PRECISION) /\n            incomeIndex;\n        totalFundedPrincipalAmount += principalFunded;\n\n        // Emit event\n        emit EFund(sender, fundingID, fundAmount, fundingMultitokensMinted);\n\n        actualFundAmount = fundAmount;\n    }\n\n    function _fundTransferFunds(address sender, uint256 fundAmount)\n        internal\n        virtual\n    {\n        ERC20 _stablecoin = stablecoin();\n\n        // Transfer `fundAmount` stablecoins from sender\n        _stablecoin.safeTransferFrom(sender, address(this), fundAmount);\n\n        // Deposit `fundAmount` stablecoins into moneyMarket\n        MoneyMarket _moneyMarket = moneyMarket();\n        _stablecoin.safeIncreaseAllowance(address(_moneyMarket), fundAmount);\n        _moneyMarket.deposit(fundAmount);\n    }\n\n    /**\n        @dev See {payInterestToFunders}\n        @param currentMoneyMarketIncomeIndex The moneyMarket's current incomeIndex\n     */\n    function _payInterestToFunders(\n        uint64 fundingID,\n        uint256 currentMoneyMarketIncomeIndex\n    ) internal virtual returns (uint256 interestAmount) {\n        Funding storage f = _getFunding(fundingID);\n        {\n            uint256 recordedMoneyMarketIncomeIndex = f\n                .recordedMoneyMarketIncomeIndex;\n            uint256 fundingTokenTotalSupply = fundingMultitoken.totalSupply(\n                fundingID\n            );\n            uint256 recordedFundedPrincipalAmount = (fundingTokenTotalSupply *\n                f.principalPerToken) / ULTRA_PRECISION;\n\n            // Update funding values\n            sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex =\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\n                (recordedFundedPrincipalAmount * EXTRA_PRECISION) /\n                currentMoneyMarketIncomeIndex -\n                (recordedFundedPrincipalAmount * EXTRA_PRECISION) /\n                recordedMoneyMarketIncomeIndex;\n            f.recordedMoneyMarketIncomeIndex = currentMoneyMarketIncomeIndex;\n\n            // Compute interest to funders\n            interestAmount =\n                (recordedFundedPrincipalAmount *\n                    currentMoneyMarketIncomeIndex) /\n                recordedMoneyMarketIncomeIndex -\n                recordedFundedPrincipalAmount;\n        }\n\n        // Distribute interest to funders\n        if (interestAmount > 0) {\n            ERC20 _stablecoin = stablecoin();\n            uint256 stablecoinPrecision = 10**uint256(_stablecoin.decimals());\n            if (\n                interestAmount >\n                stablecoinPrecision / FUNDER_PAYOUT_THRESHOLD_DIVISOR\n            ) {\n                interestAmount = moneyMarket().withdraw(interestAmount);\n                if (interestAmount > 0) {\n                    _stablecoin.safeIncreaseAllowance(\n                        address(fundingMultitoken),\n                        interestAmount\n                    );\n                    fundingMultitoken.distributeDividends(\n                        fundingID,\n                        address(_stablecoin),\n                        interestAmount\n                    );\n\n                    _distributeFundingRewards(fundingID, interestAmount);\n                }\n            } else {\n                // interestAmount below minimum payout threshold, pay nothing\n                emit EPayFundingInterest(fundingID, 0, 0);\n                return 0;\n            }\n        }\n\n        emit EPayFundingInterest(fundingID, interestAmount, 0);\n    }\n\n    /**\n        @dev Mints MPH rewards to the holders of an FRB. If past the deposit maturation,\n             only mint proportional to the time from the last distribution to the maturation.\n        @param fundingID The ID of the funding\n        @param rawInterestAmount The interest being distributed\n     */\n    function _distributeFundingRewards(\n        uint64 fundingID,\n        uint256 rawInterestAmount\n    ) internal {\n        Funding storage f = _getFunding(fundingID);\n\n        // Mint funder rewards\n        uint256 maturationTimestamp = _getDeposit(f.depositID)\n            .maturationTimestamp;\n        if (block.timestamp > maturationTimestamp) {\n            // past maturation, only mint proportionally to maturation - last payout\n            uint256 lastInterestPayoutTimestamp = f.lastInterestPayoutTimestamp;\n            if (lastInterestPayoutTimestamp < maturationTimestamp) {\n                uint256 effectiveInterestAmount = (rawInterestAmount *\n                    (maturationTimestamp - lastInterestPayoutTimestamp)) /\n                    (block.timestamp - lastInterestPayoutTimestamp);\n                mphMinter.distributeFundingRewards(\n                    fundingID,\n                    effectiveInterestAmount\n                );\n            }\n        } else {\n            // before maturation, mint full amount\n            mphMinter.distributeFundingRewards(fundingID, rawInterestAmount);\n        }\n        // update last payout timestamp\n        require(block.timestamp <= type(uint64).max, \"OVERFLOW\");\n        f.lastInterestPayoutTimestamp = uint64(block.timestamp);\n    }\n\n    /**\n        @dev Used in {_withdraw}. Computes the amount of interest to distribute\n             to the deposit's floating-rate bond holders. Also updates the Funding\n             struct associated with the floating-rate bond.\n        @param fundingID The ID of the floating-rate bond\n        @param recordedFundedPrincipalAmount The amount of principal funded before the withdrawal\n        @param early True if withdrawing before maturation, false otherwise\n        @return fundingInterestAmount The amount of interest to distribute to the floating-rate bond holders, plus the refund amount\n        @return refundAmount The amount of refund caused by an early withdraw\n     */\n    function _computeAndUpdateFundingInterestAfterWithdraw(\n        uint64 fundingID,\n        uint256 recordedFundedPrincipalAmount,\n        bool early\n    )\n        internal\n        virtual\n        returns (uint256 fundingInterestAmount, uint256 refundAmount)\n    {\n        Funding storage f = _getFunding(fundingID);\n        uint256 currentFundedPrincipalAmount = (fundingMultitoken.totalSupply(\n            fundingID\n        ) * f.principalPerToken) / ULTRA_PRECISION;\n\n        // Update funding values\n        {\n            uint256 recordedMoneyMarketIncomeIndex = f\n                .recordedMoneyMarketIncomeIndex;\n            uint256 currentMoneyMarketIncomeIndex = moneyMarket().incomeIndex();\n            uint256 currentFundedPrincipalAmountDivRecordedIncomeIndex = (currentFundedPrincipalAmount *\n                    EXTRA_PRECISION) / currentMoneyMarketIncomeIndex;\n            uint256 recordedFundedPrincipalAmountDivRecordedIncomeIndex = (recordedFundedPrincipalAmount *\n                    EXTRA_PRECISION) / recordedMoneyMarketIncomeIndex;\n            if (\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\n                    currentFundedPrincipalAmountDivRecordedIncomeIndex >=\n                recordedFundedPrincipalAmountDivRecordedIncomeIndex\n            ) {\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex =\n                    sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\n                    currentFundedPrincipalAmountDivRecordedIncomeIndex -\n                    recordedFundedPrincipalAmountDivRecordedIncomeIndex;\n            } else {\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex = 0;\n            }\n\n            f.recordedMoneyMarketIncomeIndex = currentMoneyMarketIncomeIndex;\n            totalFundedPrincipalAmount -=\n                recordedFundedPrincipalAmount -\n                currentFundedPrincipalAmount;\n\n            // Compute interest to funders\n            fundingInterestAmount =\n                (recordedFundedPrincipalAmount *\n                    currentMoneyMarketIncomeIndex) /\n                recordedMoneyMarketIncomeIndex -\n                recordedFundedPrincipalAmount;\n        }\n\n        // Add refund to interestAmount\n        if (early) {\n            Deposit storage depositEntry = _getDeposit(f.depositID);\n            uint256 interestRate = depositEntry.interestRate;\n            uint256 feeRate = depositEntry.feeRate;\n            (, uint256 moneyMarketInterestRatePerSecond) = interestOracle\n                .updateAndQuery();\n            refundAmount = (recordedFundedPrincipalAmount -\n                currentFundedPrincipalAmount).mul(\n                    (moneyMarketInterestRatePerSecond *\n                        (depositEntry.maturationTimestamp - block.timestamp))\n                        .exp2() - PRECISION\n                );\n            uint256 maxRefundAmount = (recordedFundedPrincipalAmount -\n                currentFundedPrincipalAmount)\n                .div(PRECISION + interestRate + feeRate)\n                .mul(interestRate + feeRate);\n            refundAmount = refundAmount <= maxRefundAmount\n                ? refundAmount\n                : maxRefundAmount;\n            fundingInterestAmount += refundAmount;\n        }\n\n        emit EPayFundingInterest(\n            fundingID,\n            fundingInterestAmount,\n            refundAmount\n        );\n    }\n\n    /**\n        Internal getter functions\n     */\n\n    /**\n        @dev See {getDeposit}\n     */\n    function _getDeposit(uint64 depositID)\n        internal\n        view\n        returns (Deposit storage)\n    {\n        return deposits[depositID - 1];\n    }\n\n    /**\n        @dev See {getFunding}\n     */\n    function _getFunding(uint64 fundingID)\n        internal\n        view\n        returns (Funding storage)\n    {\n        return fundingList[fundingID - 1];\n    }\n\n    /**\n        @dev Converts a virtual token value into the corresponding principal value.\n             Principal refers to deposit + full interest + fee.\n        @param depositID The ID of the deposit of the virtual tokens\n        @param virtualTokenAmount The virtual token value\n        @return The corresponding principal value\n     */\n    function _depositVirtualTokenToPrincipal(\n        uint64 depositID,\n        uint256 virtualTokenAmount\n    ) internal view virtual returns (uint256) {\n        Deposit storage depositEntry = _getDeposit(depositID);\n        uint256 depositInterestRate = depositEntry.interestRate;\n        return\n            virtualTokenAmount.div(depositInterestRate + PRECISION).mul(\n                depositInterestRate + depositEntry.feeRate + PRECISION\n            );\n    }\n\n    /**\n        @dev See {Rescuable._authorizeRescue}\n     */\n    function _authorizeRescue(\n        address, /*token*/\n        address /*target*/\n    ) internal view override onlyOwner {}\n\n    /**\n        @dev See {surplus}\n        @param incomeIndex The moneyMarket's current incomeIndex\n     */\n    function _surplus(uint256 incomeIndex)\n        internal\n        virtual\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        // compute totalInterestOwedToFunders\n        uint256 currentValue = (incomeIndex *\n            sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex) /\n            EXTRA_PRECISION;\n        uint256 initialValue = totalFundedPrincipalAmount;\n        uint256 totalInterestOwedToFunders;\n        if (currentValue > initialValue) {\n            totalInterestOwedToFunders = currentValue - initialValue;\n        }\n\n        // compute surplus\n        uint256 totalValue = moneyMarket().totalValue(incomeIndex);\n        uint256 totalOwed = totalDeposit +\n            totalInterestOwed +\n            totalFeeOwed +\n            totalInterestOwedToFunders;\n        if (totalValue >= totalOwed) {\n            // Locked value more than owed deposits, positive surplus\n            isNegative = false;\n            surplusAmount = totalValue - totalOwed;\n        } else {\n            // Locked value less than owed deposits, negative surplus\n            isNegative = true;\n            surplusAmount = totalOwed - totalValue;\n        }\n    }\n\n    /**\n        Param setters (only callable by the owner)\n     */\n    function setFeeModel(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"NOT_CONTRACT\");\n        feeModel = IFeeModel(newValue);\n        emit ESetParamAddress(msg.sender, \"feeModel\", newValue);\n    }\n\n    function setInterestModel(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"NOT_CONTRACT\");\n        interestModel = IInterestModel(newValue);\n        emit ESetParamAddress(msg.sender, \"interestModel\", newValue);\n    }\n\n    function setInterestOracle(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"NOT_CONTRACT\");\n        interestOracle = IInterestOracle(newValue);\n        emit ESetParamAddress(msg.sender, \"interestOracle\", newValue);\n    }\n\n    function setRewards(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"NOT_CONTRACT\");\n        moneyMarket().setRewards(newValue);\n        emit ESetParamAddress(msg.sender, \"moneyMarket.rewards\", newValue);\n    }\n\n    function setMPHMinter(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"NOT_CONTRACT\");\n        mphMinter = MPHMinter(newValue);\n        emit ESetParamAddress(msg.sender, \"mphMinter\", newValue);\n    }\n\n    function setMaxDepositPeriod(uint64 newValue) external onlyOwner {\n        require(newValue > 0, \"BAD_VAL\");\n        MaxDepositPeriod = newValue;\n        emit ESetParamUint(msg.sender, \"MaxDepositPeriod\", uint256(newValue));\n    }\n\n    function setMinDepositAmount(uint256 newValue) external onlyOwner {\n        require(newValue > 0, \"BAD_VAL\");\n        MinDepositAmount = newValue;\n        emit ESetParamUint(msg.sender, \"MinDepositAmount\", newValue);\n    }\n\n    function setGlobalDepositCap(uint256 newValue) external onlyOwner {\n        GlobalDepositCap = newValue;\n        emit ESetParamUint(msg.sender, \"GlobalDepositCap\", newValue);\n    }\n\n    function setDepositNFTBaseURI(string calldata newURI) external onlyOwner {\n        depositNFT.setBaseURI(newURI);\n    }\n\n    function setDepositNFTContractURI(string calldata newURI)\n        external\n        onlyOwner\n    {\n        depositNFT.setContractURI(newURI);\n    }\n\n    function skimSurplus(address recipient) external onlyOwner {\n        (bool isNegative, uint256 surplusMagnitude) = surplus();\n        if (!isNegative) {\n            surplusMagnitude = moneyMarket().withdraw(surplusMagnitude);\n            stablecoin().safeTransfer(recipient, surplusMagnitude);\n        }\n    }\n\n    function decreaseFeeForDeposit(uint64 depositID, uint256 newFeeRate)\n        external\n        onlyOwner\n    {\n        Deposit storage depositStorage = _getDeposit(depositID);\n        uint256 feeRate = depositStorage.feeRate;\n        uint256 interestRate = depositStorage.interestRate;\n        uint256 virtualTokenTotalSupply = depositStorage\n            .virtualTokenTotalSupply;\n        require(newFeeRate < feeRate, \"BAD_VAL\");\n        uint256 depositAmount = virtualTokenTotalSupply.div(\n            interestRate + PRECISION\n        );\n\n        // update fee rate\n        depositStorage.feeRate = newFeeRate;\n\n        // update interest rate\n        // fee reduction is allocated to interest\n        uint256 reducedFeeAmount = depositAmount.mul(feeRate - newFeeRate);\n        depositStorage.interestRate =\n            interestRate +\n            reducedFeeAmount.div(depositAmount);\n\n        // update global amounts\n        totalInterestOwed += reducedFeeAmount;\n        totalFeeOwed -= reducedFeeAmount;\n    }\n\n    uint256[32] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/libs/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n        @dev Modified from openzeppelin. Instead of reverting when the allowance is non-zero,\n        we first set the allowance to 0 and then call approve(spender, currentAllowance + value).\n        This provides support for non-standard tokens such as USDT that revert in this scenario. \n     */\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 currentAllowance = token.allowance(address(this), spender);\n        if (currentAllowance > 0) {\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(token.approve.selector, spender, 0)\n            );\n        }\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                currentAllowance + value\n            )\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libs/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Edited by BoringCrypto\n\ncontract BoringOwnable {\n    address private _owner;\n    address private _pendingOwner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    function __Ownable_init() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    function owner() external view returns (address) {\n        return _owner;\n    }\n\n    function pendingOwner() external view returns (address) {\n        return _pendingOwner;\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(\n                newOwner != address(0) || renounce,\n                \"Ownable: zero address\"\n            );\n\n            // Effects\n            emit OwnershipTransferred(_owner, newOwner);\n            _owner = newOwner;\n            _pendingOwner = address(0);\n        } else {\n            // Effects\n            _pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address __pendingOwner = _pendingOwner;\n\n        // Checks\n        require(\n            msg.sender == __pendingOwner,\n            \"Ownable: caller != pending owner\"\n        );\n\n        // Effects\n        emit OwnershipTransferred(_owner, __pendingOwner);\n        _owner = __pendingOwner;\n        _pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./AddressUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract MulticallUpgradeable is Initializable {\n    function __Multicall_init() internal initializer {\n        __Multicall_init_unchained();\n    }\n\n    function __Multicall_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = _functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/moneymarkets/MoneyMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {Rescuable} from \"../libs/Rescuable.sol\";\n\n// Interface for money market protocols (Compound, Aave, etc.)\nabstract contract MoneyMarket is\n    Rescuable,\n    OwnableUpgradeable,\n    AccessControlUpgradeable\n{\n    bytes32 internal constant RESCUER_ROLE = keccak256(\"RESCUER_ROLE\");\n\n    function __MoneyMarket_init(address rescuer) internal initializer {\n        __Ownable_init();\n        __AccessControl_init();\n\n        // RESCUER_ROLE is managed by itself\n        _setupRole(RESCUER_ROLE, rescuer);\n        _setRoleAdmin(RESCUER_ROLE, RESCUER_ROLE);\n    }\n\n    function deposit(uint256 amount) external virtual;\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        virtual\n        returns (uint256 actualAmountWithdrawn);\n\n    /**\n        @notice The total value locked in the money market, in terms of the underlying stablecoin\n     */\n    function totalValue() external returns (uint256) {\n        return _totalValue(_incomeIndex());\n    }\n\n    /**\n        @notice The total value locked in the money market, in terms of the underlying stablecoin\n     */\n    function totalValue(uint256 currentIncomeIndex)\n        external\n        view\n        returns (uint256)\n    {\n        return _totalValue(currentIncomeIndex);\n    }\n\n    /**\n        @notice Used for calculating the interest generated (e.g. cDai's price for the Compound market)\n     */\n    function incomeIndex() external returns (uint256 index) {\n        return _incomeIndex();\n    }\n\n    function stablecoin() external view virtual returns (ERC20);\n\n    function claimRewards() external virtual; // Claims farmed tokens (e.g. COMP, CRV) and sends it to the rewards pool\n\n    function setRewards(address newValue) external virtual;\n\n    /**\n        @dev IMPORTANT MUST READ\n        This function is for restricting unauthorized accounts from taking funds\n        and ensuring only tokens not used by the MoneyMarket can be rescued.\n        IF YOU DON'T GET IT RIGHT YOU WILL LOSE PEOPLE'S MONEY\n        MAKE SURE YOU DO ALL OF THE FOLLOWING\n        1) You MUST override it in a MoneyMarket implementation.\n        2) You MUST make `super._authorizeRescue(token, target);` the first line of your overriding function.\n        3) You MUST revert during a call to this function if a token used by the MoneyMarket is being rescued.\n        4) You SHOULD look at how existing MoneyMarkets do it as an example.\n     */\n    function _authorizeRescue(\n        address, /*token*/\n        address /*target*/\n    ) internal view virtual override {\n        require(hasRole(RESCUER_ROLE, msg.sender), \"MoneyMarket: not rescuer\");\n    }\n\n    function _totalValue(uint256 currentIncomeIndex)\n        internal\n        view\n        virtual\n        returns (uint256);\n\n    function _incomeIndex() internal virtual returns (uint256 index);\n\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n}\n"
    },
    "contracts/models/fee/IFeeModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\ninterface IFeeModel {\n    function beneficiary() external view returns (address payable);\n\n    function getInterestFeeAmount(address pool, uint256 interestAmount)\n        external\n        view\n        returns (uint256 feeAmount);\n\n    function getEarlyWithdrawFeeAmount(\n        address pool,\n        uint64 depositID,\n        uint256 withdrawnDepositAmount\n    ) external view returns (uint256 feeAmount);\n}\n"
    },
    "contracts/models/interest/IInterestModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\ninterface IInterestModel {\n    function calculateInterestAmount(\n        uint256 depositAmount,\n        uint256 depositPeriodInSeconds,\n        uint256 moneyMarketInterestRatePerSecond,\n        bool surplusIsNegative,\n        uint256 surplusAmount\n    ) external view returns (uint256 interestAmount);\n}\n"
    },
    "contracts/tokens/NFT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC721URIStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract NFT is ERC721URIStorageUpgradeable, OwnableUpgradeable {\n    string internal _contractURI;\n    string internal __baseURI;\n\n    function initialize(string calldata tokenName, string calldata tokenSymbol)\n        external\n        initializer\n    {\n        __Ownable_init();\n        __ERC721_init(tokenName, tokenSymbol);\n    }\n\n    function contractURI() external view returns (string memory) {\n        return _contractURI;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return __baseURI;\n    }\n\n    function mint(address to, uint256 tokenId) external onlyOwner {\n        _safeMint(to, tokenId);\n    }\n\n    function mint(\n        address to,\n        uint256 tokenId,\n        string calldata uri\n    ) external onlyOwner {\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n    }\n\n    function burn(uint256 tokenId) external onlyOwner {\n        _burn(tokenId);\n    }\n\n    function setContractURI(string calldata newURI) external onlyOwner {\n        _contractURI = newURI;\n    }\n\n    function setTokenURI(uint256 tokenId, string calldata newURI) external {\n        require(ownerOf(tokenId) == msg.sender, \"NFT: not token owner\");\n        _setTokenURI(tokenId, newURI);\n    }\n\n    function setBaseURI(string calldata newURI) external onlyOwner {\n        __baseURI = newURI;\n    }\n\n    uint256[48] private __gap;\n}\n"
    },
    "contracts/tokens/FundingMultitoken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC1155Upgradeable} from \"../libs/ERC1155Upgradeable.sol\";\nimport {ERC1155DividendToken} from \"../libs/ERC1155DividendToken.sol\";\nimport {WrappedERC1155Token} from \"../libs/WrappedERC1155Token.sol\";\n\ncontract FundingMultitoken is ERC1155DividendToken, WrappedERC1155Token {\n    bytes32 public constant DIVIDEND_ROLE = keccak256(\"DIVIDEND_ROLE\");\n\n    function __FundingMultitoken_init(\n        address admin,\n        string calldata uri,\n        address[] memory dividendTokens,\n        address _wrapperTemplate,\n        bool _deployWrapperOnMint,\n        string memory _baseName,\n        string memory _baseSymbol,\n        uint8 _decimals\n    ) internal initializer {\n        __ERC1155Base_init(admin, uri);\n        __ERC1155DividendToken_init_unchained(dividendTokens);\n        __WrappedERC1155Token_init_unchained(\n            _wrapperTemplate,\n            _deployWrapperOnMint,\n            _baseName,\n            _baseSymbol,\n            _decimals\n        );\n        __FundingMultitoken_init_unchained(admin);\n    }\n\n    function __FundingMultitoken_init_unchained(address admin)\n        internal\n        initializer\n    {\n        // DIVIDEND_ROLE is managed by itself\n        _setupRole(DIVIDEND_ROLE, admin);\n        _setRoleAdmin(DIVIDEND_ROLE, DIVIDEND_ROLE);\n    }\n\n    function initialize(\n        address admin,\n        string calldata uri,\n        address[] calldata dividendTokens,\n        address _wrapperTemplate,\n        bool _deployWrapperOnMint,\n        string memory _baseName,\n        string memory _baseSymbol,\n        uint8 _decimals\n    ) external virtual initializer {\n        __FundingMultitoken_init(\n            admin,\n            uri,\n            dividendTokens,\n            _wrapperTemplate,\n            _deployWrapperOnMint,\n            _baseName,\n            _baseSymbol,\n            _decimals\n        );\n    }\n\n    function distributeDividends(\n        uint256 tokenID,\n        address dividendToken,\n        uint256 amount\n    ) external {\n        require(\n            hasRole(DIVIDEND_ROLE, _msgSender()),\n            \"FundingMultitoken: must have dividend role\"\n        );\n        _distributeDividends(tokenID, dividendToken, amount);\n    }\n\n    function withdrawDividend(uint256 tokenID, address dividendToken) external {\n        _withdrawDividend(tokenID, dividendToken, msg.sender);\n    }\n\n    function withdrawDividendFor(\n        uint256 tokenID,\n        address dividendToken,\n        address user\n    ) external {\n        require(\n            hasRole(DIVIDEND_ROLE, _msgSender()),\n            \"FundingMultitoken: must have dividend role\"\n        );\n        _withdrawDividend(tokenID, dividendToken, user);\n    }\n\n    function registerDividendToken(address dividendToken) external {\n        require(\n            hasRole(DIVIDEND_ROLE, _msgSender()),\n            \"FundingMultitoken: must have dividend role\"\n        );\n        _registerDividendToken(dividendToken);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155DividendToken, WrappedERC1155Token) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n        @dev See {ERC1155Upgradeable._shouldSkipSafeTransferAcceptanceCheck}\n     */\n    function _shouldSkipSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        internal\n        override(ERC1155Upgradeable, WrappedERC1155Token)\n        returns (bool)\n    {\n        return\n            WrappedERC1155Token._shouldSkipSafeTransferAcceptanceCheck(\n                operator,\n                from,\n                to,\n                id,\n                amount,\n                data\n            );\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/rewards/MPHMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {Vesting02} from \"./Vesting02.sol\";\nimport {FundingMultitoken} from \"../tokens/FundingMultitoken.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {MPHToken} from \"./MPHToken.sol\";\n\ncontract MPHMinter is AccessControlUpgradeable {\n    using AddressUpgradeable for address;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n    bytes32 public constant WHITELISTER_ROLE = keccak256(\"WHITELISTER_ROLE\");\n    bytes32 public constant WHITELISTED_POOL_ROLE =\n        keccak256(\"WHITELISTED_POOL_ROLE\");\n    bytes32 public constant LEGACY_MINTER_ROLE =\n        keccak256(\"LEGACY_MINTER_ROLE\");\n    bytes32 public constant CONVERTER_ROLE = keccak256(\"CONVERTER_ROLE\");\n\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n    event ESetParamUint(\n        address indexed sender,\n        string indexed paramName,\n        address pool,\n        uint256 newValue\n    );\n    event MintDepositorReward(\n        address indexed sender,\n        address indexed to,\n        uint256 depositorReward\n    );\n    event MintFunderReward(\n        address indexed sender,\n        address indexed to,\n        uint256 funderReward\n    );\n\n    /**\n        @notice The multiplier applied when minting MPH for a pool's depositor reward.\n                Unit is MPH-wei per depositToken-wei per second. (wei here is the smallest decimal place)\n                Scaled by 10^18.\n                NOTE: The depositToken's decimals matter!\n     */\n    mapping(address => uint256) public poolDepositorRewardMintMultiplier;\n    /**\n        @notice The multiplier applied when minting MPH for a pool's funder reward.\n                Unit is MPH-wei per depositToken-wei. (wei here is the smallest decimal place)\n                Scaled by 10^18.\n                NOTE: The depositToken's decimals matter!\n     */\n    mapping(address => uint256) public poolFunderRewardMultiplier;\n    /**\n        @notice Multiplier used for calculating dev reward\n     */\n    uint256 public devRewardMultiplier;\n    /**\n        @notice Multiplier used for calculating gov reward\n     */\n    uint256 public govRewardMultiplier;\n\n    /**\n        External contracts\n     */\n    MPHToken public mph;\n    address public govTreasury;\n    address public devWallet;\n    Vesting02 public vesting02;\n\n    function __MPHMinter_init(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) internal initializer {\n        __AccessControl_init();\n        __MPHMinter_init_unchained(\n            _mph,\n            _govTreasury,\n            _devWallet,\n            _vesting02,\n            _devRewardMultiplier,\n            _govRewardMultiplier\n        );\n    }\n\n    function __MPHMinter_init_unchained(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) internal initializer {\n        // setup initial roles\n        _setupRole(DEFAULT_ADMIN_ROLE, _govTreasury);\n        _setupRole(WHITELISTER_ROLE, _govTreasury);\n\n        // only accounts with the whitelister role can whitelist pools\n        _setRoleAdmin(WHITELISTED_POOL_ROLE, WHITELISTER_ROLE);\n\n        mph = MPHToken(_mph);\n        govTreasury = _govTreasury;\n        devWallet = _devWallet;\n        vesting02 = Vesting02(_vesting02);\n        devRewardMultiplier = _devRewardMultiplier;\n        govRewardMultiplier = _govRewardMultiplier;\n    }\n\n    function initialize(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) external initializer {\n        __MPHMinter_init(\n            _mph,\n            _govTreasury,\n            _devWallet,\n            _vesting02,\n            _devRewardMultiplier,\n            _govRewardMultiplier\n        );\n    }\n\n    function createVestForDeposit(address account, uint64 depositID)\n        external\n        onlyRole(WHITELISTED_POOL_ROLE)\n    {\n        vesting02.createVestForDeposit(\n            account,\n            msg.sender,\n            depositID,\n            poolDepositorRewardMintMultiplier[msg.sender]\n        );\n    }\n\n    function updateVestForDeposit(\n        uint64 depositID,\n        uint256 currentDepositAmount,\n        uint256 depositAmount\n    ) external onlyRole(WHITELISTED_POOL_ROLE) {\n        vesting02.updateVestForDeposit(\n            msg.sender,\n            depositID,\n            currentDepositAmount,\n            depositAmount,\n            poolDepositorRewardMintMultiplier[msg.sender]\n        );\n    }\n\n    function mintVested(address account, uint256 amount)\n        external\n        returns (uint256 mintedAmount)\n    {\n        require(msg.sender == address(vesting02), \"MPHMinter: not vesting02\");\n        if (mph.owner() != address(this)) {\n            // not the owner of the MPH token, cannot mint\n            return 0;\n        }\n        if (amount > 0) {\n            mph.ownerMint(account, amount);\n        }\n        uint256 devReward = amount.mul(devRewardMultiplier);\n        if (devReward > 0) {\n            mph.ownerMint(devWallet, devReward);\n        }\n        uint256 govReward = amount.mul(govRewardMultiplier);\n        if (govReward > 0) {\n            mph.ownerMint(govTreasury, govReward);\n        }\n        return amount;\n    }\n\n    function distributeFundingRewards(uint64 fundingID, uint256 interestAmount)\n        external\n        onlyRole(WHITELISTED_POOL_ROLE)\n    {\n        if (interestAmount == 0 || mph.owner() != address(this)) {\n            return;\n        }\n        uint256 mintMPHAmount = interestAmount.mul(\n            poolFunderRewardMultiplier[msg.sender]\n        );\n        if (mintMPHAmount == 0) {\n            return;\n        }\n        FundingMultitoken fundingMultitoken = DInterest(msg.sender)\n            .fundingMultitoken();\n        mph.ownerMint(address(this), mintMPHAmount);\n        mph.increaseAllowance(address(fundingMultitoken), mintMPHAmount);\n        fundingMultitoken.distributeDividends(\n            fundingID,\n            address(mph),\n            mintMPHAmount\n        );\n\n        uint256 devReward = mintMPHAmount.mul(devRewardMultiplier);\n        if (devReward > 0) {\n            mph.ownerMint(devWallet, devReward);\n        }\n        uint256 govReward = mintMPHAmount.mul(govRewardMultiplier);\n        if (govReward > 0) {\n            mph.ownerMint(govTreasury, govReward);\n        }\n    }\n\n    /**\n        @dev Used for supporting the v2 MPHMinterLegacy\n     */\n    function legacyMintFunderReward(\n        address pool,\n        address to,\n        uint256 depositAmount,\n        uint256 fundingCreationTimestamp,\n        uint256 maturationTimestamp,\n        uint256, /*interestPayoutAmount*/\n        bool early\n    ) external onlyRole(LEGACY_MINTER_ROLE) returns (uint256) {\n        require(hasRole(WHITELISTED_POOL_ROLE, pool), \"MPHMinter: not pool\");\n\n        if (mph.owner() != address(this)) {\n            // not the owner of the MPH token, cannot mint\n            return 0;\n        }\n\n        uint256 funderReward;\n        uint256 devReward;\n        uint256 govReward;\n        if (!early) {\n            funderReward = maturationTimestamp > fundingCreationTimestamp\n                ? depositAmount *\n                    (maturationTimestamp - fundingCreationTimestamp).mul(\n                        poolFunderRewardMultiplier[pool]\n                    )\n                : 0;\n            devReward = funderReward.mul(devRewardMultiplier);\n            govReward = funderReward.mul(govRewardMultiplier);\n        } else {\n            return 0;\n        }\n\n        // mint and vest funder reward\n        if (funderReward > 0) {\n            mph.ownerMint(to, funderReward);\n        }\n        if (devReward > 0) {\n            mph.ownerMint(devWallet, devReward);\n        }\n        if (govReward > 0) {\n            mph.ownerMint(govTreasury, govReward);\n        }\n\n        return funderReward;\n    }\n\n    function converterMint(address to, uint256 amount)\n        external\n        onlyRole(CONVERTER_ROLE)\n    {\n        mph.ownerMint(to, amount);\n    }\n\n    /**\n        Param setters\n     */\n    function setPoolDepositorRewardMintMultiplier(\n        address pool,\n        uint256 newMultiplier\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(pool.isContract(), \"MPHMinter: pool not contract\");\n        poolDepositorRewardMintMultiplier[pool] = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"poolDepositorRewardMintMultiplier\",\n            pool,\n            newMultiplier\n        );\n    }\n\n    function setPoolFunderRewardMultiplier(address pool, uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(pool.isContract(), \"MPHMinter: pool not contract\");\n        poolFunderRewardMultiplier[pool] = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"poolFunderRewardMultiplier\",\n            pool,\n            newMultiplier\n        );\n    }\n\n    function setDevRewardMultiplier(uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newMultiplier <= PRECISION, \"MPHMinter: invalid multiplier\");\n        devRewardMultiplier = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"devRewardMultiplier\",\n            address(0),\n            newMultiplier\n        );\n    }\n\n    function setGovRewardMultiplier(uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newMultiplier <= PRECISION, \"MPHMinter: invalid multiplier\");\n        govRewardMultiplier = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"govRewardMultiplier\",\n            address(0),\n            newMultiplier\n        );\n    }\n\n    function setGovTreasury(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        govTreasury = newValue;\n        emit ESetParamAddress(msg.sender, \"govTreasury\", newValue);\n    }\n\n    function setDevWallet(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        devWallet = newValue;\n        emit ESetParamAddress(msg.sender, \"devWallet\", newValue);\n    }\n\n    function setMPHTokenOwner(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        mph.transferOwnership(newValue);\n        emit ESetParamAddress(msg.sender, \"mphTokenOwner\", newValue);\n    }\n\n    function setMPHTokenOwnerToZero() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        mph.renounceOwnership();\n        emit ESetParamAddress(msg.sender, \"mphTokenOwner\", address(0));\n    }\n\n    function setVesting02(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue.isContract(), \"MPHMinter: not contract\");\n        vesting02 = Vesting02(newValue);\n        emit ESetParamAddress(msg.sender, \"vesting02\", newValue);\n    }\n\n    uint256[42] private __gap;\n}\n"
    },
    "contracts/models/interest-oracle/IInterestOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {MoneyMarket} from \"../../moneymarkets/MoneyMarket.sol\";\n\ninterface IInterestOracle {\n    function updateAndQuery() external returns (bool updated, uint256 value);\n\n    function query() external view returns (uint256 value);\n\n    function moneyMarket() external view returns (MoneyMarket);\n}\n"
    },
    "prb-math/contracts/PRBMathUD60x18.sol": {
      "content": "// SPDX-License-Identifier: WTFPL\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary PRBMathUD60x18 {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 = 115792089237316195423570985008687907853269984665640564039457000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimised for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimised for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding towards zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    },
    "contracts/libs/Rescuable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {SafeERC20} from \"./SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n    @notice Inherit this to allow for rescuing ERC20 tokens sent to the contract in error.\n */\nabstract contract Rescuable {\n    using SafeERC20 for IERC20;\n\n    /**\n        @notice Rescues ERC20 tokens sent to the contract in error.\n        @dev Need to implement {_authorizeRescue} to do access-control for this function.\n        @param token The ERC20 token to rescue\n        @param target The address to send the tokens to\n     */\n    function rescue(address token, address target) external virtual {\n        // make sure we're not stealing funds or something\n        _authorizeRescue(token, target);\n\n        // transfer token to target\n        IERC20 tokenContract = IERC20(token);\n        tokenContract.safeTransfer(\n            target,\n            tokenContract.balanceOf(address(this))\n        );\n    }\n\n    /**\n        @dev IMPORTANT MUST READ\n        IF YOU DON'T GET IT RIGHT YOU WILL LOSE PEOPLE'S MONEY\n        MAKE SURE YOU DO ALL OF THE FOLLOWING\n        1) You MUST revert during a call to this function if the token rescue should be stopped.\n        2) You MUST implement proper access control to prevent stealing funds.\n        3) You MUST revert if `token` is a token your contract holds as user funds.\n        @param token The ERC20 token to rescue\n        @param target The address to send the tokens to\n     */\n    function _authorizeRescue(address token, address target) internal virtual;\n\n    uint256[50] private __gap;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorageUpgradeable is Initializable, ERC721Upgradeable {\n    function __ERC721URIStorage_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721URIStorage_init_unchained();\n    }\n\n    function __ERC721URIStorage_init_unchained() internal initializer {\n    }\n    using StringsUpgradeable for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/libs/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport {IERC1155ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport {IERC1155MetadataURIUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport {ERC165Upgradeable, IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is\n    Initializable,\n    ContextUpgradeable,\n    ERC165Upgradeable,\n    IERC1155Upgradeable,\n    IERC1155MetadataURIUpgradeable\n{\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal initializer {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            account != address(0),\n            \"ERC1155: balance query for the zero address\"\n        );\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(\n            accounts.length == ids.length,\n            \"ERC1155: accounts and ids length mismatch\"\n        );\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        require(\n            _msgSender() != operator,\n            \"ERC1155: setting approval status for self\"\n        );\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            from,\n            to,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        uint256 fromBalance = _balances[id][from];\n        require(\n            fromBalance >= amount,\n            \"ERC1155: insufficient balance for transfer\"\n        );\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(\n                fromBalance >= amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            address(0),\n            account,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(\n            operator,\n            address(0),\n            account,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            address(0),\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            account,\n            address(0),\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            \"\"\n        );\n\n        uint256 accountBalance = _balances[id][account];\n        require(\n            accountBalance >= amount,\n            \"ERC1155: burn amount exceeds balance\"\n        );\n        _balances[id][account] = accountBalance - amount;\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(\n                accountBalance >= amount,\n                \"ERC1155: burn amount exceeds balance\"\n            );\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n        @dev Override this to return true to skip checking to.onERC1155Received during\n             single transfers.\n     */\n    function _shouldSkipSafeTransferAcceptanceCheck(\n        address, /*operator*/\n        address, /*from*/\n        address, /*to*/\n        uint256, /*id*/\n        uint256, /*amount*/\n        bytes memory /*data*/\n    ) internal virtual returns (bool) {\n        return false;\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (\n            to.isContract() &&\n            !_shouldSkipSafeTransferAcceptanceCheck(\n                operator,\n                from,\n                to,\n                id,\n                amount,\n                data\n            )\n        ) {\n            try\n                IERC1155ReceiverUpgradeable(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response !=\n                    IERC1155ReceiverUpgradeable(to).onERC1155Received.selector\n                ) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response !=\n                    IERC1155ReceiverUpgradeable(to)\n                        .onERC1155BatchReceived\n                        .selector\n                ) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element)\n        private\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n\n    uint256[47] private __gap;\n}\n"
    },
    "contracts/libs/ERC1155DividendToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"./SafeERC20.sol\";\nimport {ERC1155Base} from \"./ERC1155Base.sol\";\n\n/**\n    @notice An extension of ERC1155Base that allows distributing dividends to all holders\n            of an token ID. Also supports multiple dividend tokens.\n */\nabstract contract ERC1155DividendToken is ERC1155Base {\n    using SafeERC20 for IERC20;\n    using SafeCastUpgradeable for uint256;\n    using SafeCastUpgradeable for int256;\n\n    struct DividendTokenData {\n        address dividendToken;\n        mapping(uint256 => uint256) magnifiedDividendPerShare;\n        // About dividendCorrection:\n        // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\n        //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\n        // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\n        //   `dividendOf(_user)` should not be changed,\n        //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\n        // To keep the `dividendOf(_user)` unchanged, we add a correction term:\n        //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\n        //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\n        //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\n        // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\n        mapping(uint256 => mapping(address => int256)) magnifiedDividendCorrections;\n        mapping(uint256 => mapping(address => uint256)) withdrawnDividends;\n    }\n\n    // With `magnitude`, we can properly distribute dividends even if the amount of received target is small.\n    // For more discussion about choosing the value of `magnitude`,\n    //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n    uint256 internal constant magnitude = 2**128;\n\n    /**\n        @notice The list of tokens that can be distributed to token holders as dividend. 1-indexed.\n     */\n    mapping(uint256 => DividendTokenData) public dividendTokenDataList;\n    uint256 public dividendTokenDataListLength;\n    /**\n        @notice The dividend token address to its key in {dividendTokenDataList}\n     */\n    mapping(address => uint256) public dividendTokenToDataID;\n\n    /// @dev This event MUST emit when target is distributed to token holders.\n    /// @param from The address which sends target to this contract.\n    /// @param weiAmount The amount of distributed target in wei.\n    event DividendsDistributed(\n        uint256 indexed tokenID,\n        address indexed from,\n        address indexed dividendToken,\n        uint256 weiAmount\n    );\n\n    /// @dev This event MUST emit when an address withdraws their dividend.\n    /// @param to The address which withdraws target from this contract.\n    /// @param weiAmount The amount of withdrawn target in wei.\n    event DividendWithdrawn(\n        uint256 indexed tokenID,\n        address indexed to,\n        address indexed dividendToken,\n        uint256 weiAmount\n    );\n\n    function __ERC1155DividendToken_init(\n        address[] memory dividendTokens,\n        address admin,\n        string memory uri\n    ) internal initializer {\n        __ERC1155Base_init(admin, uri);\n        __ERC1155DividendToken_init_unchained(dividendTokens);\n    }\n\n    function __ERC1155DividendToken_init_unchained(\n        address[] memory dividendTokens\n    ) internal initializer {\n        dividendTokenDataListLength = dividendTokens.length;\n        for (uint256 i = 0; i < dividendTokens.length; i++) {\n            dividendTokenDataList[i + 1].dividendToken = dividendTokens[i];\n            dividendTokenToDataID[dividendTokens[i]] = i + 1;\n        }\n    }\n\n    /**\n        Public getters\n     */\n\n    /// @notice View the amount of dividend in wei that an address can withdraw.\n    /// @param tokenID The token's ID.\n    /// @param dividendToken The token the dividend is in\n    /// @param _owner The address of a token holder.\n    /// @return The amount of dividend in wei that `_owner` can withdraw.\n    function dividendOf(\n        uint256 tokenID,\n        address dividendToken,\n        address _owner\n    ) public view returns (uint256) {\n        return _withdrawableDividendOf(tokenID, dividendToken, _owner);\n    }\n\n    /// @notice View the amount of dividend in wei that an address has withdrawn.\n    /// @param tokenID The token's ID.\n    /// @param dividendToken The token the dividend is in\n    /// @param _owner The address of a token holder.\n    /// @return The amount of dividend in wei that `_owner` has withdrawn.\n    function withdrawnDividendOf(\n        uint256 tokenID,\n        address dividendToken,\n        address _owner\n    ) public view returns (uint256) {\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\n        if (dividendTokenDataID == 0) {\n            return 0;\n        }\n        DividendTokenData storage data = dividendTokenDataList[\n            dividendTokenDataID\n        ];\n        return data.withdrawnDividends[tokenID][_owner];\n    }\n\n    /// @notice View the amount of dividend in wei that an address has earned in total.\n    /// @dev accumulativeDividendOf(_owner) = _withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\n    /// = (magnifiedDividendPerShare * balanceOf(_owner) + magnifiedDividendCorrections[_owner]) / magnitude\n    /// @param tokenID The token's ID.\n    /// @param dividendToken The token the dividend is in\n    /// @param _owner The address of a token holder.\n    /// @return The amount of dividend in wei that `_owner` has earned in total.\n    function accumulativeDividendOf(\n        uint256 tokenID,\n        address dividendToken,\n        address _owner\n    ) public view returns (uint256) {\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\n        if (dividendTokenDataID == 0) {\n            return 0;\n        }\n        DividendTokenData storage data = dividendTokenDataList[\n            dividendTokenDataID\n        ];\n        return\n            ((data.magnifiedDividendPerShare[tokenID] *\n                balanceOf(_owner, tokenID)).toInt256() +\n                data.magnifiedDividendCorrections[tokenID][_owner])\n                .toUint256() / magnitude;\n    }\n\n    /**\n        Internal functions\n     */\n\n    /// @notice View the amount of dividend in wei that an address can withdraw.\n    /// @param tokenID The token's ID.\n    /// @param dividendToken The token the dividend is in\n    /// @param _owner The address of a token holder.\n    /// @return The amount of dividend in wei that `_owner` can withdraw.\n    function _withdrawableDividendOf(\n        uint256 tokenID,\n        address dividendToken,\n        address _owner\n    ) internal view returns (uint256) {\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\n        if (dividendTokenDataID == 0) {\n            return 0;\n        }\n        DividendTokenData storage data = dividendTokenDataList[\n            dividendTokenDataID\n        ];\n        return\n            accumulativeDividendOf(tokenID, dividendToken, _owner) -\n            data.withdrawnDividends[tokenID][_owner];\n    }\n\n    /// @notice Distributes target to token holders as dividends.\n    /// @dev It reverts if the total supply of tokens is 0.\n    /// It emits the `DividendsDistributed` event if the amount of received target is greater than 0.\n    /// About undistributed target tokens:\n    ///   In each distribution, there is a small amount of target not distributed,\n    ///     the magnified amount of which is\n    ///     `(amount * magnitude) % totalSupply()`.\n    ///   With a well-chosen `magnitude`, the amount of undistributed target\n    ///     (de-magnified) in a distribution can be less than 1 wei.\n    ///   We can actually keep track of the undistributed target in a distribution\n    ///     and try to distribute it in the next distribution,\n    ///     but keeping track of such data on-chain costs much more than\n    ///     the saved target, so we don't do that.\n    function _distributeDividends(\n        uint256 tokenID,\n        address dividendToken,\n        uint256 amount\n    ) internal {\n        uint256 tokenTotalSupply = totalSupply(tokenID);\n        require(tokenTotalSupply > 0);\n        require(amount > 0);\n\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\n        require(\n            dividendTokenDataID != 0,\n            \"ERC1155DividendToken: invalid dividendToken\"\n        );\n        DividendTokenData storage data = dividendTokenDataList[\n            dividendTokenDataID\n        ];\n\n        data.magnifiedDividendPerShare[tokenID] +=\n            (amount * magnitude) /\n            tokenTotalSupply;\n\n        IERC20(dividendToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        emit DividendsDistributed(tokenID, msg.sender, dividendToken, amount);\n    }\n\n    /// @notice Withdraws the target distributed to the sender.\n    /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn target is greater than 0.\n    function _withdrawDividend(\n        uint256 tokenID,\n        address dividendToken,\n        address user\n    ) internal {\n        uint256 _withdrawableDividend = _withdrawableDividendOf(\n            tokenID,\n            dividendToken,\n            user\n        );\n        if (_withdrawableDividend > 0) {\n            uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\n            require(\n                dividendTokenDataID != 0,\n                \"ERC1155DividendToken: invalid dividendToken\"\n            );\n            DividendTokenData storage data = dividendTokenDataList[\n                dividendTokenDataID\n            ];\n            data.withdrawnDividends[tokenID][user] += _withdrawableDividend;\n            emit DividendWithdrawn(\n                tokenID,\n                user,\n                dividendToken,\n                _withdrawableDividend\n            );\n            IERC20(dividendToken).safeTransfer(user, _withdrawableDividend);\n        }\n    }\n\n    function _registerDividendToken(address dividendToken)\n        internal\n        returns (uint256 newDividendTokenDataID)\n    {\n        require(\n            dividendTokenToDataID[dividendToken] == 0,\n            \"ERC1155DividendToken: already registered\"\n        );\n        dividendTokenDataListLength++;\n        newDividendTokenDataID = dividendTokenDataListLength;\n        dividendTokenDataList[newDividendTokenDataID]\n            .dividendToken = dividendToken;\n        dividendTokenToDataID[dividendToken] = newDividendTokenDataID;\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155Base) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            // Mint\n            for (uint256 i = 0; i < ids.length; i++) {\n                uint256 tokenID = ids[i];\n                uint256 amount = amounts[i];\n\n                for (uint256 j = 1; j <= dividendTokenDataListLength; j++) {\n                    DividendTokenData\n                        storage dividendTokenData = dividendTokenDataList[j];\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\n                            to\n                        ] -= (dividendTokenData.magnifiedDividendPerShare[\n                        tokenID\n                    ] * amount).toInt256();\n                }\n            }\n        } else if (to == address(0)) {\n            // Burn\n            for (uint256 i = 0; i < ids.length; i++) {\n                uint256 tokenID = ids[i];\n                uint256 amount = amounts[i];\n\n                for (uint256 j = 1; j <= dividendTokenDataListLength; j++) {\n                    DividendTokenData\n                        storage dividendTokenData = dividendTokenDataList[j];\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\n                            from\n                        ] += (dividendTokenData.magnifiedDividendPerShare[\n                        tokenID\n                    ] * amount).toInt256();\n                }\n            }\n        } else {\n            // Transfer\n            for (uint256 i = 0; i < ids.length; i++) {\n                uint256 tokenID = ids[i];\n                uint256 amount = amounts[i];\n\n                for (uint256 j = 1; j <= dividendTokenDataListLength; j++) {\n                    DividendTokenData\n                        storage dividendTokenData = dividendTokenDataList[j];\n                    int256 _magCorrection = (dividendTokenData\n                        .magnifiedDividendPerShare[tokenID] * amount)\n                        .toInt256();\n                    // Retain the rewards\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\n                            from\n                        ] += _magCorrection;\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\n                            to\n                        ] -= _magCorrection;\n                }\n            }\n        }\n    }\n\n    uint256[47] private __gap;\n}\n"
    },
    "contracts/libs/WrappedERC1155Token.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ClonesUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport {StringsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport {ERC1155Upgradeable} from \"./ERC1155Upgradeable.sol\";\nimport {ERC1155Base} from \"./ERC1155Base.sol\";\nimport {ERC20Wrapper} from \"./ERC20Wrapper.sol\";\n\n/**\n    @notice An ERC-1155 multitoken where each ID is wrapped in an ERC-20 interface\n */\nabstract contract WrappedERC1155Token is ERC1155Base {\n    using ClonesUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    mapping(uint256 => address) public tokenIDToWrapper;\n    address public wrapperTemplate;\n    bool public deployWrapperOnMint;\n    string public baseName;\n    string public baseSymbol;\n    uint8 public decimals;\n\n    function __WrappedERC1155Token_init(\n        address admin,\n        string memory uri,\n        address _wrapperTemplate,\n        bool _deployWrapperOnMint,\n        string memory _baseName,\n        string memory _baseSymbol,\n        uint8 _decimals\n    ) internal initializer {\n        __ERC1155Base_init(admin, uri);\n        __WrappedERC1155Token_init_unchained(\n            _wrapperTemplate,\n            _deployWrapperOnMint,\n            _baseName,\n            _baseSymbol,\n            _decimals\n        );\n    }\n\n    function __WrappedERC1155Token_init_unchained(\n        address _wrapperTemplate,\n        bool _deployWrapperOnMint,\n        string memory _baseName,\n        string memory _baseSymbol,\n        uint8 _decimals\n    ) internal initializer {\n        wrapperTemplate = _wrapperTemplate;\n        deployWrapperOnMint = _deployWrapperOnMint;\n        baseName = _baseName;\n        baseSymbol = _baseSymbol;\n        decimals = _decimals;\n    }\n\n    /**\n        @notice Called by an ERC20Wrapper contract to handle a transfer call.\n        @dev Only callable by a wrapper deployed by this contract.\n        @param from Source of transfer\n        @param to Target of transfer\n        @param tokenID The ERC-1155 token ID of the wrapper\n        @param amount The amount to transfer\n     */\n    function wrapperTransfer(\n        address from,\n        address to,\n        uint256 tokenID,\n        uint256 amount\n    ) external {\n        require(\n            msg.sender == tokenIDToWrapper[tokenID],\n            \"WrappedERC1155Token: not wrapper\"\n        );\n        _safeTransferFrom(from, to, tokenID, amount, bytes(\"\"));\n    }\n\n    /**\n        @notice Deploys an ERC20Wrapper contract for the ERC-1155 tokens with ID `tokenID`.\n        @dev If a wrapper already exists for this tokenID, does nothing and returns the address\n             of the existing wrapper.\n        @param tokenID The ID of the token to wrap\n        @return wrapperAddress The address of the wrapper\n     */\n    function deployWrapper(uint256 tokenID)\n        external\n        returns (address wrapperAddress)\n    {\n        return _deployWrapper(tokenID);\n    }\n\n    /**\n        @dev See {deployWrapper}\n     */\n    function _deployWrapper(uint256 tokenID)\n        internal\n        returns (address wrapperAddress)\n    {\n        wrapperAddress = tokenIDToWrapper[tokenID];\n        if (wrapperAddress == address(0)) {\n            // deploy wrapper\n            ERC20Wrapper wrapper = ERC20Wrapper(wrapperTemplate.clone());\n            string memory tokenIDString = tokenID.toString();\n            string memory name = string(\n                abi.encodePacked(baseName, tokenIDString)\n            );\n            string memory symbol = string(\n                abi.encodePacked(baseSymbol, tokenIDString)\n            );\n            wrapper.initialize(address(this), tokenID, name, symbol, decimals);\n            tokenIDToWrapper[tokenID] = address(wrapper);\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            // Mint\n            if (deployWrapperOnMint) {\n                for (uint256 i = 0; i < ids.length; i++) {\n                    _deployWrapper(ids[i]);\n                }\n            }\n        }\n\n        // Emit transfer event in wrapper\n        for (uint256 i = 0; i < ids.length; i++) {\n            address wrapperAddress = tokenIDToWrapper[ids[i]];\n            if (wrapperAddress != address(0)) {\n                ERC20Wrapper wrapper = ERC20Wrapper(wrapperAddress);\n                wrapper.emitTransferEvent(from, to, amounts[i]);\n            }\n        }\n    }\n\n    /**\n        @dev See {ERC1155Upgradeable._shouldSkipSafeTransferAcceptanceCheck}\n     */\n    function _shouldSkipSafeTransferAcceptanceCheck(\n        address operator,\n        address, /*from*/\n        address, /*to*/\n        uint256 id,\n        uint256, /*amount*/\n        bytes memory /*data*/\n    ) internal virtual override(ERC1155Upgradeable) returns (bool) {\n        address wrapperAddress = tokenIDToWrapper[id];\n        if (wrapperAddress != address(0)) {\n            // has wrapper, check if operator is the wrapper\n            return operator == wrapperAddress;\n        } else {\n            // no wrapper, should do safety checks\n            return false;\n        }\n    }\n\n    /**\n        Param setters (need metadata role)\n     */\n    function setDeployWrapperOnMint(bool newValue) external {\n        require(\n            hasRole(METADATA_ROLE, msg.sender),\n            \"WrappedERC1155Token: no metadata role\"\n        );\n        deployWrapperOnMint = newValue;\n    }\n\n    function setBaseName(string calldata newValue) external {\n        require(\n            hasRole(METADATA_ROLE, msg.sender),\n            \"WrappedERC1155Token: no metadata role\"\n        );\n        baseName = newValue;\n    }\n\n    function setBaseSymbol(string calldata newValue) external {\n        require(\n            hasRole(METADATA_ROLE, msg.sender),\n            \"WrappedERC1155Token: no metadata role\"\n        );\n        baseSymbol = newValue;\n    }\n\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/libs/ERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC1155Upgradeable} from \"./ERC1155Upgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\n/**\n    @notice An extension of ERC1155 that provides access-controlled minting and burning,\n            as well as a total supply getter for each token ID.\n */\nabstract contract ERC1155Base is ERC1155Upgradeable, AccessControlUpgradeable {\n    bytes32 public constant MINTER_BURNER_ROLE =\n        keccak256(\"MINTER_BURNER_ROLE\");\n    bytes32 public constant METADATA_ROLE = keccak256(\"METADATA_ROLE\");\n    bytes internal constant NULL_BYTES = bytes(\"\");\n\n    mapping(uint256 => uint256) private _totalSupply;\n\n    function __ERC1155Base_init(address admin, string memory uri)\n        internal\n        initializer\n    {\n        __ERC1155_init(uri);\n        __ERC1155Base_init_unchained(admin);\n    }\n\n    function __ERC1155Base_init_unchained(address admin) internal initializer {\n        // admin is granted metadata role and minter-burner role\n        // metadata role is managed by itself\n        // minter-burner role is managed by itself\n        _setupRole(METADATA_ROLE, admin);\n        _setupRole(MINTER_BURNER_ROLE, admin);\n        _setRoleAdmin(METADATA_ROLE, METADATA_ROLE);\n        _setRoleAdmin(MINTER_BURNER_ROLE, MINTER_BURNER_ROLE);\n    }\n\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) external {\n        require(\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\n            \"ERC1155Base: must have minter-burner role to mint\"\n        );\n\n        _mint(to, id, amount, NULL_BYTES);\n    }\n\n    function mintBatch(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\n            \"ERC1155Base: must have minter-burner role to mint\"\n        );\n\n        _mintBatch(to, ids, amounts, NULL_BYTES);\n    }\n\n    function burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) external {\n        require(\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\n            \"ERC1155Base: must have minter-burner role to burn\"\n        );\n\n        _burn(account, id, amount);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\n            \"ERC1155Base: must have minter-burner role to burn\"\n        );\n\n        _burnBatch(account, ids, amounts);\n    }\n\n    function setURI(string calldata newuri) external {\n        require(\n            hasRole(METADATA_ROLE, _msgSender()),\n            \"ERC1155Base: must have metadata role to set URI\"\n        );\n\n        _setURI(newuri);\n    }\n\n    function totalSupply(uint256 id) public view returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    function totalSupplyBatch(uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory totalSupplies)\n    {\n        totalSupplies = new uint256[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            totalSupplies[i] = _totalSupply[ids[i]];\n        }\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155Upgradeable) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            // Mint\n            for (uint256 i = 0; i < ids.length; i++) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        } else if (to == address(0)) {\n            // Burn\n            for (uint256 i = 0; i < ids.length; i++) {\n                _totalSupply[ids[i]] -= amounts[i];\n            }\n        }\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/libs/ERC20Wrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {WrappedERC1155Token} from \"./WrappedERC1155Token.sol\";\n\n/**\n    @notice An ERC-20 wrapper for a particular tokenID of an ERC-1155 token\n */\ncontract ERC20Wrapper is Initializable, IERC20 {\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    WrappedERC1155Token public parentMultitoken;\n    uint256 public tokenID;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    function initialize(\n        address _parentMultitoken,\n        uint256 _tokenID,\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals\n    ) external virtual initializer {\n        parentMultitoken = WrappedERC1155Token(_parentMultitoken);\n        tokenID = _tokenID;\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view virtual override returns (uint256) {\n        return parentMultitoken.totalSupply(tokenID);\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return parentMultitoken.balanceOf(account, tokenID);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        external\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20Wrapper: transfer amount exceeds allowance\"\n        );\n        _approve(sender, msg.sender, currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        external\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20Wrapper: decreased allowance below zero\"\n        );\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n        @dev Only callable by the parentMultitoken. Emits a transfer event when the parent token\n             is transferred.\n     */\n    function emitTransferEvent(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        require(\n            msg.sender == address(parentMultitoken),\n            \"ERC20Wrapper: not parent\"\n        );\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        parentMultitoken.wrapperTransfer(sender, recipient, tokenID, amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(\n            owner != address(0),\n            \"ERC20Wrapper: approve from the zero address\"\n        );\n        require(\n            spender != address(0),\n            \"ERC20Wrapper: approve to the zero address\"\n        );\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/rewards/Vesting02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"../libs/SafeERC20.sol\";\nimport {ERC721URIStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {BoringOwnable} from \"../libs/BoringOwnable.sol\";\nimport {MathUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {MPHMinter} from \"./MPHMinter.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract Vesting02 is ERC721URIStorageUpgradeable, BoringOwnable {\n    using SafeERC20 for IERC20;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n\n    struct Vest {\n        address pool;\n        uint64 depositID;\n        uint64 lastUpdateTimestamp;\n        uint256 accumulatedAmount;\n        uint256 withdrawnAmount;\n        uint256 vestAmountPerStablecoinPerSecond;\n    }\n    Vest[] public vestList;\n    mapping(address => mapping(uint64 => uint64)) public depositIDToVestID;\n\n    MPHMinter public mphMinter;\n    IERC20 public token;\n    string internal _contractURI;\n    string internal __baseURI;\n\n    event ECreateVest(\n        address indexed to,\n        address indexed pool,\n        uint64 depositID,\n        uint64 vestID,\n        uint256 vestAmountPerStablecoinPerSecond\n    );\n    event EUpdateVest(\n        uint64 indexed vestID,\n        address poolAddress,\n        uint64 depositID,\n        uint256 currentDepositAmount,\n        uint256 depositAmount,\n        uint256 vestAmountPerStablecoinPerSecond\n    );\n    event EWithdraw(\n        address indexed sender,\n        uint64 indexed vestID,\n        uint256 withdrawnAmount\n    );\n    event ESetMPHMinter(address newValue);\n    event EBoost(\n        uint64 indexed vestID,\n        uint256 vestAmountPerStablecoinPerSecond\n    );\n\n    function initialize(\n        address _token,\n        string calldata tokenName,\n        string calldata tokenSymbol\n    ) external initializer {\n        __Ownable_init();\n        __ERC721_init(tokenName, tokenSymbol);\n\n        token = IERC20(_token);\n    }\n\n    function setMPHMinter(address newValue) external onlyOwner {\n        require(newValue != address(0), \"Vesting02: 0 address\");\n        mphMinter = MPHMinter(newValue);\n        emit ESetMPHMinter(newValue);\n    }\n\n    /**\n        MPHMinter only functions\n     */\n\n    function createVestForDeposit(\n        address to,\n        address pool,\n        uint64 depositID,\n        uint256 vestAmountPerStablecoinPerSecond\n    ) external virtual returns (uint64 vestID) {\n        require(\n            address(msg.sender) == address(mphMinter),\n            \"Vesting02: not minter\"\n        );\n\n        // create vest object\n        require(block.timestamp <= type(uint64).max, \"Vesting02: OVERFLOW\");\n        vestList.push(\n            Vest({\n                pool: pool,\n                depositID: depositID,\n                lastUpdateTimestamp: uint64(block.timestamp),\n                accumulatedAmount: 0,\n                withdrawnAmount: 0,\n                vestAmountPerStablecoinPerSecond: vestAmountPerStablecoinPerSecond\n            })\n        );\n        require(vestList.length <= type(uint64).max, \"Vesting02: OVERFLOW\");\n        vestID = uint64(vestList.length); // 1-indexed\n        depositIDToVestID[pool][depositID] = vestID;\n\n        // mint NFT\n        _safeMint(to, vestID);\n\n        emit ECreateVest(\n            to,\n            pool,\n            depositID,\n            vestID,\n            vestAmountPerStablecoinPerSecond\n        );\n    }\n\n    function updateVestForDeposit(\n        address poolAddress,\n        uint64 depositID,\n        uint256 currentDepositAmount,\n        uint256 depositAmount,\n        uint256 vestAmountPerStablecoinPerSecond\n    ) external virtual {\n        require(\n            address(msg.sender) == address(mphMinter),\n            \"Vesting02: not minter\"\n        );\n\n        uint64 vestID = depositIDToVestID[poolAddress][depositID];\n        Vest storage vestEntry = _getVest(vestID);\n        DInterest pool = DInterest(poolAddress);\n        DInterest.Deposit memory depositEntry = pool.getDeposit(\n            vestEntry.depositID\n        );\n        uint256 currentTimestamp = MathUpgradeable.min(\n            block.timestamp,\n            depositEntry.maturationTimestamp\n        );\n        if (currentTimestamp > vestEntry.lastUpdateTimestamp) {\n            vestEntry.accumulatedAmount += (currentDepositAmount *\n                (currentTimestamp - vestEntry.lastUpdateTimestamp)).mul(\n                    vestEntry.vestAmountPerStablecoinPerSecond\n                );\n            require(block.timestamp <= type(uint64).max, \"Vesting02: OVERFLOW\");\n            vestEntry.lastUpdateTimestamp = uint64(block.timestamp);\n        }\n        vestEntry.vestAmountPerStablecoinPerSecond =\n            (vestEntry.vestAmountPerStablecoinPerSecond *\n                currentDepositAmount +\n                vestAmountPerStablecoinPerSecond *\n                depositAmount) /\n            (currentDepositAmount + depositAmount);\n\n        emit EUpdateVest(\n            vestID,\n            poolAddress,\n            depositID,\n            currentDepositAmount,\n            depositAmount,\n            vestAmountPerStablecoinPerSecond\n        );\n    }\n\n    /**\n        Public action functions\n     */\n\n    function withdraw(uint64 vestID)\n        external\n        returns (uint256 withdrawnAmount)\n    {\n        return _withdraw(vestID);\n    }\n\n    function multiWithdraw(uint64[] memory vestIDList) external {\n        for (uint256 i = 0; i < vestIDList.length; i++) {\n            _withdraw(vestIDList[i]);\n        }\n    }\n\n    function _withdraw(uint64 vestID)\n        internal\n        virtual\n        returns (uint256 withdrawnAmount)\n    {\n        require(ownerOf(vestID) == msg.sender, \"Vesting02: not owner\");\n\n        // compute withdrawable amount\n        withdrawnAmount = _getVestWithdrawableAmount(vestID);\n        if (withdrawnAmount == 0) {\n            return 0;\n        }\n\n        // update vest object\n        Vest storage vestEntry = _getVest(vestID);\n        vestEntry.withdrawnAmount += withdrawnAmount;\n\n        // mint tokens to vest recipient\n        mphMinter.mintVested(msg.sender, withdrawnAmount);\n\n        emit EWithdraw(msg.sender, vestID, withdrawnAmount);\n    }\n\n    /**\n        Public getter functions\n     */\n\n    function getVestWithdrawableAmount(uint64 vestID)\n        external\n        view\n        returns (uint256)\n    {\n        return _getVestWithdrawableAmount(vestID);\n    }\n\n    function _getVestWithdrawableAmount(uint64 vestID)\n        internal\n        view\n        virtual\n        returns (uint256 withdrawableAmount)\n    {\n        // read vest data\n        Vest memory vestEntry = _getVest(vestID);\n        DInterest pool = DInterest(vestEntry.pool);\n        DInterest.Deposit memory depositEntry = pool.getDeposit(\n            vestEntry.depositID\n        );\n\n        // compute vested amount\n        uint256 currentTimestamp = MathUpgradeable.min(\n            block.timestamp,\n            depositEntry.maturationTimestamp\n        );\n        if (currentTimestamp < vestEntry.lastUpdateTimestamp) {\n            return vestEntry.accumulatedAmount - vestEntry.withdrawnAmount;\n        }\n        uint256 depositAmount = depositEntry.virtualTokenTotalSupply.div(\n            PRECISION + depositEntry.interestRate\n        );\n        return\n            vestEntry.accumulatedAmount +\n            (depositAmount * (currentTimestamp - vestEntry.lastUpdateTimestamp))\n                .mul(vestEntry.vestAmountPerStablecoinPerSecond) -\n            vestEntry.withdrawnAmount;\n    }\n\n    function getVest(uint64 vestID) external view returns (Vest memory) {\n        return _getVest(vestID);\n    }\n\n    function _getVest(uint64 vestID) internal view returns (Vest storage) {\n        return vestList[vestID - 1];\n    }\n\n    function numVests() external view returns (uint256) {\n        return vestList.length;\n    }\n\n    /**\n        NFT metadata\n     */\n\n    function contractURI() external view returns (string memory) {\n        return _contractURI;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return __baseURI;\n    }\n\n    function setContractURI(string calldata newURI) external onlyOwner {\n        _contractURI = newURI;\n    }\n\n    function setTokenURI(uint256 tokenId, string calldata newURI) external {\n        require(ownerOf(tokenId) == msg.sender, \"Vesting02: not token owner\");\n        _setTokenURI(tokenId, newURI);\n    }\n\n    /**\n        Owner functions\n     */\n\n    function setBaseURI(string calldata newURI) external onlyOwner {\n        __baseURI = newURI;\n    }\n\n    function boost(uint64 vestID, uint256 vestAmountPerStablecoinPerSecond)\n        external\n        onlyOwner\n    {\n        _getVest(vestID)\n            .vestAmountPerStablecoinPerSecond = vestAmountPerStablecoinPerSecond;\n        emit EBoost(vestID, vestAmountPerStablecoinPerSecond);\n    }\n\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/rewards/MPHToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20BurnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract MPHToken is\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    OwnableUpgradeable\n{\n    function initialize() external initializer {\n        __Ownable_init();\n        __ERC20Burnable_init();\n        __ERC20_init(\"88mph.app\", \"MPH\");\n    }\n\n    function ownerMint(address account, uint256 amount)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "prb-math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: WTFPL\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculting the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculting the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explictly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE = 78156646155174841979727994598816262306175212592076161876661508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Now use Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the closest power of two that is higher than x.\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20Burnable_init_unchained();\n    }\n\n    function __ERC20Burnable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/zaps/ZapCurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"../libs/SafeERC20.sol\";\nimport {ERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {CurveZapIn} from \"./imports/CurveZapIn.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {NFT} from \"../tokens/NFT.sol\";\nimport {FundingMultitoken} from \"../tokens/FundingMultitoken.sol\";\nimport {Vesting02} from \"../rewards/Vesting02.sol\";\n\ncontract ZapCurve is ERC1155Receiver, IERC721Receiver {\n    using SafeERC20 for ERC20;\n\n    modifier active() {\n        isActive = true;\n        _;\n        isActive = false;\n    }\n\n    CurveZapIn public constant zapper =\n        CurveZapIn(0xf9A724c2607E5766a7Bbe530D6a7e173532F9f3a);\n    bytes internal constant NULL_BYTES = bytes(\"\");\n    bool public isActive;\n\n    function zapCurveDeposit(\n        address pool,\n        address vesting,\n        address swapAddress,\n        address inputToken,\n        uint256 inputTokenAmount,\n        uint256 minOutputTokenAmount,\n        uint64 maturationTimestamp\n    ) external active {\n        DInterest poolContract = DInterest(pool);\n\n        // zap into curve\n        uint64 depositID;\n        {\n            uint256 outputTokenAmount = _zapTokenInCurve(\n                swapAddress,\n                inputToken,\n                inputTokenAmount,\n                minOutputTokenAmount\n            );\n\n            // create deposit\n            poolContract.stablecoin().safeIncreaseAllowance(\n                pool,\n                outputTokenAmount\n            );\n            (depositID, ) = poolContract.deposit(\n                outputTokenAmount,\n                maturationTimestamp\n            );\n        }\n\n        // transfer deposit multitokens to msg.sender\n        poolContract.depositNFT().safeTransferFrom(\n            address(this),\n            msg.sender,\n            depositID\n        );\n\n        // transfer vest token out\n        {\n            Vesting02 vestingContract = Vesting02(vesting);\n            vestingContract.safeTransferFrom(\n                address(this),\n                msg.sender,\n                vestingContract.depositIDToVestID(pool, depositID)\n            );\n        }\n    }\n\n    function zapCurveFund(\n        address pool,\n        address swapAddress,\n        address inputToken,\n        uint256 inputTokenAmount,\n        uint256 minOutputTokenAmount,\n        uint64 depositID\n    ) external active {\n        DInterest poolContract = DInterest(pool);\n        ERC20 stablecoin = poolContract.stablecoin();\n        FundingMultitoken fundingMultitoken = poolContract.fundingMultitoken();\n\n        // zap into curve\n        uint256 outputTokenAmount = _zapTokenInCurve(\n            swapAddress,\n            inputToken,\n            inputTokenAmount,\n            minOutputTokenAmount\n        );\n\n        // create funding\n        stablecoin.safeIncreaseAllowance(pool, outputTokenAmount);\n        (uint64 fundingID, , , ) = poolContract.fund(\n            depositID,\n            outputTokenAmount\n        );\n\n        // transfer funding multitoken to msg.sender\n        fundingMultitoken.safeTransferFrom(\n            address(this),\n            msg.sender,\n            fundingID,\n            fundingMultitoken.balanceOf(address(this), fundingID),\n            NULL_BYTES\n        );\n        // transfer remaining stablecoins to msg.sender\n        stablecoin.safeTransfer(\n            msg.sender,\n            stablecoin.balanceOf(address(this))\n        );\n    }\n\n    function onERC1155Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        uint256, /*value*/\n        bytes calldata /*data*/\n    ) external view override returns (bytes4) {\n        require(isActive, \"ZapCurve: inactive\");\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address, /*operator*/\n        address, /*from*/\n        uint256[] calldata, /*ids*/\n        uint256[] calldata, /*values*/\n        bytes calldata /*data*/\n    ) external view override returns (bytes4) {\n        require(isActive, \"ZapCurve: inactive\");\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    function onERC721Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*tokenId*/\n        bytes memory /*data*/\n    ) external view override returns (bytes4) {\n        require(isActive, \"ZapCurve: inactive\");\n        return this.onERC721Received.selector;\n    }\n\n    function _zapTokenInCurve(\n        address swapAddress,\n        address inputToken,\n        uint256 inputTokenAmount,\n        uint256 minOutputTokenAmount\n    ) internal returns (uint256 outputTokenAmount) {\n        ERC20 inputTokenContract = ERC20(inputToken);\n\n        // transfer inputToken from msg.sender\n        inputTokenContract.safeTransferFrom(\n            msg.sender,\n            address(this),\n            inputTokenAmount\n        );\n\n        // zap inputToken into curve\n        inputTokenContract.safeIncreaseAllowance(\n            address(zapper),\n            inputTokenAmount\n        );\n        outputTokenAmount = zapper.ZapIn(\n            address(this),\n            inputToken,\n            swapAddress,\n            inputTokenAmount,\n            minOutputTokenAmount\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/zaps/imports/CurveZapIn.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\ninterface CurveZapIn {\n    /**\n        @notice This function adds liquidity to a Curve pool with ETH or ERC20 tokens\n        @param toWhomToIssue The address to return the Curve LP tokens to\n        @param fromToken The ERC20 token used for investment (address(0x00) if ether)\n        @param swapAddress Curve swap address for the pool\n        @param incomingTokenQty The amount of fromToken to invest\n        @param minPoolTokens The minimum acceptable quantity of tokens to receive. Reverts otherwise\n        @return crvTokensBought Amount of Curve LP tokens received\n    */\n    function ZapIn(\n        address toWhomToIssue,\n        address fromToken,\n        address swapAddress,\n        uint256 incomingTokenQty,\n        uint256 minPoolTokens\n    ) external payable returns (uint256 crvTokensBought);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/rewards/Vesting03.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\n\nimport {Bytes32AddressLib} from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\nimport {Forwarder} from \"./Forwarder.sol\";\nimport {Vesting02} from \"./Vesting02.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {FullMath} from \"../libs/FullMath.sol\";\n\n/// @title Vesting03\n/// @author zefram.eth\n/// @notice Distributes MPH rewards to depositors over time based on a staking-pool like logic\ncontract Vesting03 is Vesting02 {\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using Clones for address;\n    using PRBMathUD60x18 for uint256;\n    using Bytes32AddressLib for address;\n    using Bytes32AddressLib for bytes32;\n\n    /// -----------------------------------------------------------------------\n    /// Errors\n    /// -----------------------------------------------------------------------\n\n    error Vesting03__Overflow();\n    error Vesting03__NotMinter();\n    error Vesting03__NotVestOwner();\n    error Vesting03__AmountTooLarge();\n    error Vesting03__ForwarderNotDeployed();\n    error Vesting03__NotRewardDistributor();\n\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    event RewardAdded(address indexed pool, uint256 reward);\n    event Staked(uint64 indexed vestID, uint256 amount);\n    event Withdrawn(uint64 indexed vestID, uint256 amount);\n    event RewardPaid(uint64 indexed vestID, uint256 reward);\n    event UpdateDuration(uint64 newDuration);\n    event SetRewardDistributor(address indexed account, bool isDistributor);\n\n    /// -----------------------------------------------------------------------\n    /// Immutable parameters\n    /// -----------------------------------------------------------------------\n\n    /// @notice The Forwarder template for cloning Forwarders\n    Forwarder public immutable forwarderTemplate;\n\n    /// -----------------------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------------------\n\n    struct PeriodInfo {\n        /// @notice The last Unix timestamp (in seconds) when rewardPerTokenStored was updated\n        uint64 lastUpdateTime;\n        /// @notice The Unix timestamp (in seconds) at which the current reward period ends\n        uint64 periodFinish;\n    }\n    /// @notice Info about the reward period of each pool\n    /// @dev pool => value\n    mapping(address => PeriodInfo) public periodInfo;\n\n    /// @notice The per-second rate at which rewardPerToken increases\n    /// @dev pool => value\n    mapping(address => uint256) public rewardRate;\n\n    /// @notice The last stored rewardPerToken value\n    /// @dev pool => value\n    mapping(address => uint256) public rewardPerTokenStored;\n\n    /// @notice The rewardPerToken value when a vest last staked/withdrew/withdrew rewards\n    /// @dev vestId => value\n    mapping(uint64 => uint256) public vestRewardPerTokenPaid;\n\n    /// @notice The earned() value when a vest last staked/withdrew/withdrew rewards\n    /// @dev vestId => value\n    mapping(uint64 => uint256) public rewards;\n\n    /// @notice The total virtual tokens staked in each pool\n    /// @dev pool => value\n    mapping(address => uint256) public totalSupply;\n\n    /// @notice The total deposit of each pool when a vest related to the pool was last updated\n    /// @dev pool => value\n    mapping(address => uint256) public totalDepositStored;\n\n    /// @notice Tracks if an address can call notifyReward()\n    /// @dev account => value\n    mapping(address => bool) public isRewardDistributor;\n\n    /// @notice The duration of each reward period, in seconds\n    uint64 public DURATION;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(Forwarder forwarderTemplate_) {\n        forwarderTemplate = forwarderTemplate_;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Vesting02 compatibility\n    /// -----------------------------------------------------------------------\n\n    function createVestForDeposit(\n        address to,\n        address pool,\n        uint64 depositID,\n        uint256 /*vestAmountPerStablecoinPerSecond*/\n    ) external virtual override returns (uint64 vestID) {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        if (address(msg.sender) != address(mphMinter)) {\n            revert Vesting03__NotMinter();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// Storage loads\n        /// -----------------------------------------------------------------------\n\n        uint256 totalSupply_ = totalSupply[pool];\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable(pool);\n        uint256 rewardPerToken_ = _rewardPerToken(\n            pool,\n            totalSupply_,\n            lastTimeRewardApplicable_,\n            rewardRate[pool]\n        );\n        DInterest.Deposit memory deposit = DInterest(pool).getDeposit(\n            depositID\n        );\n        uint256 depositAmount = FullMath.mulDiv(\n            deposit.virtualTokenTotalSupply,\n            PRECISION,\n            PRECISION + deposit.interestRate\n        );\n        uint256 totalDeposit = DInterest(pool).totalDeposit();\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // create vest object\n        if (block.timestamp > type(uint64).max) {\n            revert Vesting03__Overflow();\n        }\n        vestList.push(\n            Vest({\n                pool: pool,\n                depositID: depositID,\n                lastUpdateTimestamp: 0,\n                accumulatedAmount: 0,\n                withdrawnAmount: 0,\n                vestAmountPerStablecoinPerSecond: 0\n            })\n        );\n        uint256 vestListLength = vestList.length;\n        if (vestListLength > type(uint64).max) {\n            revert Vesting03__Overflow();\n        }\n        vestID = uint64(vestListLength); // 1-indexed\n        depositIDToVestID[pool][depositID] = vestID;\n\n        // mint NFT\n        _safeMint(to, vestID);\n\n        // accrue rewards\n        rewardPerTokenStored[pool] = rewardPerToken_;\n        periodInfo[pool].lastUpdateTime = lastTimeRewardApplicable_;\n        vestRewardPerTokenPaid[vestID] = rewardPerToken_;\n\n        // update stored totalDeposit\n        totalDepositStored[pool] = totalDeposit;\n\n        // update total supply\n        totalSupply[pool] = totalSupply_ + depositAmount;\n\n        emit Staked(vestID, depositAmount);\n    }\n\n    function updateVestForDeposit(\n        address pool,\n        uint64 depositID,\n        uint256 currentDepositAmount,\n        uint256 depositAmount,\n        uint256 vestAmountPerStablecoinPerSecond\n    ) external virtual override {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        if (address(msg.sender) != address(mphMinter)) {\n            revert Vesting03__NotMinter();\n        }\n\n        uint64 vestID = depositIDToVestID[pool][depositID];\n        if (vestID == 0) {\n            // deposit was created before vesting contract, return\n            return;\n        }\n        Vest storage vestEntry = _getVest(vestID);\n\n        if (vestEntry.lastUpdateTimestamp == 0) {\n            // created by Vesting03\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint256 totalSupply_ = totalSupply[pool];\n            uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable(pool);\n            uint256 rewardPerToken_ = _rewardPerToken(\n                pool,\n                totalSupply_,\n                lastTimeRewardApplicable_,\n                rewardRate[pool]\n            );\n            uint256 totalDeposit = DInterest(pool).totalDeposit();\n            uint256 totalDepositStored_ = totalDepositStored[pool];\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            rewardPerTokenStored[pool] = rewardPerToken_;\n            periodInfo[pool].lastUpdateTime = lastTimeRewardApplicable_;\n            rewards[vestID] = _earned(\n                vestID,\n                currentDepositAmount,\n                rewardPerToken_,\n                rewards[vestID]\n            );\n            vestRewardPerTokenPaid[vestID] = rewardPerToken_;\n\n            // update stored totalDeposit\n            totalDepositStored[pool] = totalDeposit;\n\n            // update total supply\n            if (depositAmount > 0) {\n                // deposit\n                totalSupply[pool] = totalSupply_ + depositAmount;\n\n                emit Staked(vestID, depositAmount);\n            } else {\n                // withdrawal\n                // this is the only way for the vesting contract to learn\n                // of the amount that was withdrawn, since it's not passed in\n                // as an argument\n                uint256 withdrawAmount = totalDepositStored_ - totalDeposit;\n                totalSupply[pool] = totalSupply_ - withdrawAmount;\n\n                emit Withdrawn(vestID, withdrawAmount);\n            }\n        } else {\n            // created by Vesting02\n            // use the same code\n            DInterest poolContract = DInterest(pool);\n            DInterest.Deposit memory depositEntry = poolContract.getDeposit(\n                vestEntry.depositID\n            );\n            uint256 currentTimestamp = block.timestamp <\n                depositEntry.maturationTimestamp\n                ? block.timestamp\n                : depositEntry.maturationTimestamp;\n            if (currentTimestamp > vestEntry.lastUpdateTimestamp) {\n                vestEntry.accumulatedAmount += (currentDepositAmount *\n                    (currentTimestamp - vestEntry.lastUpdateTimestamp)).mul(\n                        vestEntry.vestAmountPerStablecoinPerSecond\n                    );\n                require(\n                    block.timestamp <= type(uint64).max,\n                    \"Vesting02: OVERFLOW\"\n                );\n                vestEntry.lastUpdateTimestamp = uint64(block.timestamp);\n            }\n            vestEntry.vestAmountPerStablecoinPerSecond =\n                (vestEntry.vestAmountPerStablecoinPerSecond *\n                    currentDepositAmount +\n                    vestAmountPerStablecoinPerSecond *\n                    depositAmount) /\n                (currentDepositAmount + depositAmount);\n\n            emit EUpdateVest(\n                vestID,\n                pool,\n                depositID,\n                currentDepositAmount,\n                depositAmount,\n                vestAmountPerStablecoinPerSecond\n            );\n        }\n    }\n\n    function _withdraw(uint64 vestID)\n        internal\n        virtual\n        override\n        returns (uint256 withdrawnAmount)\n    {\n        Vest storage vestEntry = _getVest(vestID);\n\n        if (vestEntry.lastUpdateTimestamp == 0) {\n            // created by Vesting03\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (ownerOf(vestID) != msg.sender) {\n                revert Vesting03__NotVestOwner();\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            address pool = vestEntry.pool;\n            uint64 depositID = vestEntry.depositID;\n            uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable(pool);\n            uint256 rewardPerToken_ = _rewardPerToken(\n                pool,\n                totalSupply[pool],\n                lastTimeRewardApplicable_,\n                rewardRate[pool]\n            );\n            DInterest.Deposit memory deposit = DInterest(pool).getDeposit(\n                depositID\n            );\n            uint256 depositAmount = FullMath.mulDiv(\n                deposit.virtualTokenTotalSupply,\n                PRECISION,\n                PRECISION + deposit.interestRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            withdrawnAmount = _earned(\n                vestID,\n                depositAmount,\n                rewardPerToken_,\n                rewards[vestID]\n            );\n\n            // accrue rewards\n            rewardPerTokenStored[pool] = rewardPerToken_;\n            periodInfo[pool].lastUpdateTime = lastTimeRewardApplicable_;\n            vestRewardPerTokenPaid[vestID] = rewardPerToken_;\n\n            // withdraw rewards\n            if (withdrawnAmount > 0) {\n                rewards[vestID] = 0;\n\n                /// -----------------------------------------------------------------------\n                /// Effects\n                /// -----------------------------------------------------------------------\n\n                mphMinter.mph().transfer(msg.sender, withdrawnAmount);\n                emit RewardPaid(vestID, withdrawnAmount);\n            }\n        } else {\n            // created by Vesting02\n            return super._withdraw(vestID);\n        }\n    }\n\n    function _getVestWithdrawableAmount(uint64 vestID)\n        internal\n        view\n        virtual\n        override\n        returns (uint256 withdrawableAmount)\n    {\n        Vest storage vestEntry = _getVest(vestID);\n        address pool = vestEntry.pool;\n        uint64 depositID = vestEntry.depositID;\n\n        if (vestEntry.lastUpdateTimestamp == 0) {\n            // created by Vesting03\n            uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable(pool);\n            uint256 rewardPerToken_ = _rewardPerToken(\n                pool,\n                totalSupply[pool],\n                lastTimeRewardApplicable_,\n                rewardRate[pool]\n            );\n            DInterest.Deposit memory deposit = DInterest(pool).getDeposit(\n                depositID\n            );\n            uint256 depositAmount = FullMath.mulDiv(\n                deposit.virtualTokenTotalSupply,\n                PRECISION,\n                PRECISION + deposit.interestRate\n            );\n\n            return\n                _earned(\n                    vestID,\n                    depositAmount,\n                    rewardPerToken_,\n                    rewards[vestID]\n                );\n        } else {\n            // created by Vesting02\n            return super._getVestWithdrawableAmount(vestID);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @notice The latest time at which stakers are earning rewards.\n    function lastTimeRewardApplicable(address pool)\n        public\n        view\n        returns (uint64)\n    {\n        uint64 periodFinish = periodInfo[pool].periodFinish;\n        return\n            block.timestamp < periodFinish\n                ? uint64(block.timestamp)\n                : periodFinish;\n    }\n\n    /// @notice The amount of reward tokens each staked token has earned so far\n    function rewardPerToken(address pool) external view returns (uint256) {\n        return\n            _rewardPerToken(\n                pool,\n                DInterest(pool).totalDeposit(),\n                lastTimeRewardApplicable(pool),\n                rewardRate[pool]\n            );\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Forwarder\n    /// -----------------------------------------------------------------------\n\n    function forwarderOfPool(address pool) public view returns (Forwarder) {\n        return\n            Forwarder(\n                Clones.predictDeterministicAddress(\n                    address(forwarderTemplate),\n                    pool.fillLast12Bytes()\n                )\n            );\n    }\n\n    function deployForwarderOfPool(address pool) external {\n        address(forwarderTemplate).cloneDeterministic(pool.fillLast12Bytes());\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staking pool logic\n    /// -----------------------------------------------------------------------\n\n    /// @notice Lets a reward distributor start a new reward period. The reward tokens must have already\n    /// been transferred to this contract before calling this function. If it is called\n    /// when a reward period is still active, a new reward period will begin from the time\n    /// of calling this function, using the leftover rewards from the old reward period plus\n    /// the newly sent rewards as the reward.\n    /// @dev If the reward amount will cause an overflow when computing rewardPerToken, then\n    /// this function will revert.\n    /// @param pool The pool to distribute reward tokens to\n    /// @param reward The amount of reward tokens to use in the new reward period.\n    function notifyRewardAmount(address pool, uint256 reward) external {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        if (reward == 0) {\n            return;\n        }\n        if (!isRewardDistributor[msg.sender]) {\n            revert Vesting03__NotRewardDistributor();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// Storage loads\n        /// -----------------------------------------------------------------------\n\n        uint256 rewardRate_ = rewardRate[pool];\n        uint64 periodFinish_ = periodInfo[pool].periodFinish;\n        uint64 lastTimeRewardApplicable_ = block.timestamp < periodFinish_\n            ? uint64(block.timestamp)\n            : periodFinish_;\n        uint64 duration = DURATION;\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // accrue rewards\n        rewardPerTokenStored[pool] = _rewardPerToken(\n            pool,\n            totalSupply[pool],\n            lastTimeRewardApplicable_,\n            rewardRate_\n        );\n\n        // record new reward\n        uint256 newRewardRate;\n        if (block.timestamp >= periodFinish_) {\n            newRewardRate = reward / duration;\n        } else {\n            uint256 remaining = periodFinish_ - block.timestamp;\n            uint256 leftover = remaining * rewardRate_;\n            newRewardRate = (reward + leftover) / duration;\n        }\n        // prevent overflow when computing rewardPerToken\n        if (newRewardRate >= ((type(uint256).max / PRECISION) / duration)) {\n            revert Vesting03__AmountTooLarge();\n        }\n        rewardRate[pool] = newRewardRate;\n        periodInfo[pool] = PeriodInfo({\n            lastUpdateTime: uint64(block.timestamp),\n            periodFinish: uint64(block.timestamp + duration)\n        });\n\n        /// -----------------------------------------------------------------------\n        /// Effects\n        /// -----------------------------------------------------------------------\n\n        // pull rewards from the forwarder contract\n        Forwarder forwarder = forwarderOfPool(pool);\n        if (address(forwarder).code.length == 0)\n            revert Vesting03__ForwarderNotDeployed();\n        forwarder.pullTokens(address(mphMinter.mph()), reward);\n\n        emit RewardAdded(pool, reward);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Owner functions\n    /// -----------------------------------------------------------------------\n\n    function updateDuration(uint64 duration_) external onlyOwner {\n        DURATION = duration_;\n        emit UpdateDuration(duration_);\n    }\n\n    /// @notice Lets the owner add/remove accounts from the list of reward distributors.\n    /// Reward distributors can call notifyRewardAmount()\n    /// @param rewardDistributor The account to add/remove\n    /// @param isRewardDistributor_ True to add the account, false to remove the account\n    function setRewardDistributor(\n        address rewardDistributor,\n        bool isRewardDistributor_\n    ) external onlyOwner {\n        isRewardDistributor[rewardDistributor] = isRewardDistributor_;\n        emit SetRewardDistributor(rewardDistributor, isRewardDistributor_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal functions\n    /// -----------------------------------------------------------------------\n\n    function _earned(\n        uint64 vestID,\n        uint256 accountBalance,\n        uint256 rewardPerToken_,\n        uint256 accountRewards\n    ) internal view returns (uint256) {\n        uint256 vestRewardPerTokenPaid_ = vestRewardPerTokenPaid[vestID];\n        if (vestRewardPerTokenPaid_ == 0) {\n            return 0;\n        }\n        return\n            FullMath.mulDiv(\n                accountBalance,\n                rewardPerToken_ - vestRewardPerTokenPaid_,\n                PRECISION\n            ) + accountRewards;\n    }\n\n    function _rewardPerToken(\n        address pool,\n        uint256 totalSupply_,\n        uint256 lastTimeRewardApplicable_,\n        uint256 rewardRate_\n    ) internal view returns (uint256) {\n        if (totalSupply_ == 0) {\n            return rewardPerTokenStored[pool];\n        }\n        return\n            rewardPerTokenStored[pool] +\n            FullMath.mulDiv(\n                (lastTimeRewardApplicable_ - periodInfo[pool].lastUpdateTime) *\n                    PRECISION,\n                rewardRate_,\n                totalSupply_\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "contracts/rewards/Forwarder.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {SafeERC20} from \"../libs/SafeERC20.sol\";\n\n/// @title Forwarder\n/// @author zefram.eth\n/// @notice Allows its controller to pull any ERC20 token from it\ncontract Forwarder {\n    using SafeERC20 for IERC20;\n\n    error Forwarder__NotController();\n\n    address public immutable controller;\n\n    constructor(address controller_) {\n        controller = controller_;\n    }\n\n    function pullTokens(address token, uint256 amount) external {\n        if (msg.sender != controller) revert Forwarder__NotController();\n\n        IERC20(token).safeTransfer(controller, amount);\n    }\n}\n"
    },
    "contracts/libs/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (type(uint256).max - denominator + 1) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        unchecked {\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n"
    },
    "contracts/rewards/Vesting02Fantom.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"../libs/SafeERC20.sol\";\nimport {ERC721URIStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {BoringOwnable} from \"../libs/BoringOwnable.sol\";\nimport {MathUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {MPHMinter} from \"./MPHMinter.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract Vesting02Fantom is ERC721URIStorageUpgradeable, BoringOwnable {\n    using SafeERC20 for IERC20;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n\n    struct Vest {\n        address pool;\n        uint64 depositID;\n        uint64 lastUpdateTimestamp;\n        uint256 accumulatedAmount;\n        uint256 withdrawnAmount;\n        uint256 vestAmountPerStablecoinPerSecond;\n    }\n    Vest[] public vestList;\n    mapping(address => mapping(uint64 => uint64)) public depositIDToVestID;\n\n    MPHMinter public mphMinter;\n    IERC20 public token;\n    string internal _contractURI;\n    string internal __baseURI;\n\n    event ECreateVest(\n        address indexed to,\n        address indexed pool,\n        uint64 depositID,\n        uint64 vestID,\n        uint256 vestAmountPerStablecoinPerSecond\n    );\n    event EUpdateVest(\n        uint64 indexed vestID,\n        address poolAddress,\n        uint64 depositID,\n        uint256 currentDepositAmount,\n        uint256 depositAmount,\n        uint256 vestAmountPerStablecoinPerSecond\n    );\n    event EWithdraw(\n        address indexed sender,\n        uint64 indexed vestID,\n        uint256 withdrawnAmount\n    );\n    event ESetMPHMinter(address newValue);\n    event EBoost(\n        uint64 indexed vestID,\n        uint256 vestAmountPerStablecoinPerSecond\n    );\n\n    function initialize(\n        address _token,\n        string calldata tokenName,\n        string calldata tokenSymbol\n    ) external initializer {\n        __Ownable_init();\n        __ERC721_init(tokenName, tokenSymbol);\n\n        token = IERC20(_token);\n    }\n\n    function setMPHMinter(address newValue) external onlyOwner {\n        require(newValue != address(0), \"Vesting02: 0 address\");\n        mphMinter = MPHMinter(newValue);\n        emit ESetMPHMinter(newValue);\n    }\n\n    /**\n        MPHMinter only functions\n     */\n\n    function createVestForDeposit(\n        address to,\n        address pool,\n        uint64 depositID,\n        uint256 vestAmountPerStablecoinPerSecond\n    ) external returns (uint64 vestID) {\n        require(\n            address(msg.sender) == address(mphMinter),\n            \"Vesting02: not minter\"\n        );\n\n        // create vest object\n        require(block.timestamp <= type(uint64).max, \"Vesting02: OVERFLOW\");\n        vestList.push(\n            Vest({\n                pool: pool,\n                depositID: depositID,\n                lastUpdateTimestamp: uint64(block.timestamp),\n                accumulatedAmount: 0,\n                withdrawnAmount: 0,\n                vestAmountPerStablecoinPerSecond: vestAmountPerStablecoinPerSecond\n            })\n        );\n        require(vestList.length <= type(uint64).max, \"Vesting02: OVERFLOW\");\n        vestID = uint64(vestList.length); // 1-indexed\n        depositIDToVestID[pool][depositID] = vestID;\n\n        // mint NFT\n        _safeMint(to, vestID);\n\n        emit ECreateVest(\n            to,\n            pool,\n            depositID,\n            vestID,\n            vestAmountPerStablecoinPerSecond\n        );\n    }\n\n    function updateVestForDeposit(\n        address poolAddress,\n        uint64 depositID,\n        uint256 currentDepositAmount,\n        uint256 depositAmount,\n        uint256 vestAmountPerStablecoinPerSecond\n    ) external {\n        require(\n            address(msg.sender) == address(mphMinter),\n            \"Vesting02: not minter\"\n        );\n\n        uint64 vestID = depositIDToVestID[poolAddress][depositID];\n        if (vestID == 0) {\n            // deposit was created before vesting contract, return\n            return;\n        }\n        Vest storage vestEntry = _getVest(vestID);\n        DInterest pool = DInterest(poolAddress);\n        DInterest.Deposit memory depositEntry = pool.getDeposit(\n            vestEntry.depositID\n        );\n        uint256 currentTimestamp = MathUpgradeable.min(\n            block.timestamp,\n            depositEntry.maturationTimestamp\n        );\n        if (currentTimestamp > vestEntry.lastUpdateTimestamp) {\n            vestEntry.accumulatedAmount += (currentDepositAmount *\n                (currentTimestamp - vestEntry.lastUpdateTimestamp)).mul(\n                    vestEntry.vestAmountPerStablecoinPerSecond\n                );\n            require(block.timestamp <= type(uint64).max, \"Vesting02: OVERFLOW\");\n            vestEntry.lastUpdateTimestamp = uint64(block.timestamp);\n        }\n        vestEntry.vestAmountPerStablecoinPerSecond =\n            (vestEntry.vestAmountPerStablecoinPerSecond *\n                currentDepositAmount +\n                vestAmountPerStablecoinPerSecond *\n                depositAmount) /\n            (currentDepositAmount + depositAmount);\n\n        emit EUpdateVest(\n            vestID,\n            poolAddress,\n            depositID,\n            currentDepositAmount,\n            depositAmount,\n            vestAmountPerStablecoinPerSecond\n        );\n    }\n\n    /**\n        Public action functions\n     */\n\n    function withdraw(uint64 vestID)\n        external\n        returns (uint256 withdrawnAmount)\n    {\n        return _withdraw(vestID);\n    }\n\n    function multiWithdraw(uint64[] memory vestIDList) external {\n        for (uint256 i = 0; i < vestIDList.length; i++) {\n            _withdraw(vestIDList[i]);\n        }\n    }\n\n    function _withdraw(uint64 vestID)\n        internal\n        returns (uint256 withdrawnAmount)\n    {\n        require(ownerOf(vestID) == msg.sender, \"Vesting02: not owner\");\n\n        // compute withdrawable amount\n        withdrawnAmount = _getVestWithdrawableAmount(vestID);\n        if (withdrawnAmount == 0) {\n            return 0;\n        }\n\n        // update vest object\n        Vest storage vestEntry = _getVest(vestID);\n        vestEntry.withdrawnAmount += withdrawnAmount;\n\n        // mint tokens to vest recipient\n        mphMinter.mintVested(msg.sender, withdrawnAmount);\n\n        emit EWithdraw(msg.sender, vestID, withdrawnAmount);\n    }\n\n    /**\n        Public getter functions\n     */\n\n    function getVestWithdrawableAmount(uint64 vestID)\n        external\n        view\n        returns (uint256)\n    {\n        return _getVestWithdrawableAmount(vestID);\n    }\n\n    function _getVestWithdrawableAmount(uint64 vestID)\n        internal\n        view\n        returns (uint256 withdrawableAmount)\n    {\n        // read vest data\n        Vest memory vestEntry = _getVest(vestID);\n        DInterest pool = DInterest(vestEntry.pool);\n        DInterest.Deposit memory depositEntry = pool.getDeposit(\n            vestEntry.depositID\n        );\n\n        // compute vested amount\n        uint256 currentTimestamp = MathUpgradeable.min(\n            block.timestamp,\n            depositEntry.maturationTimestamp\n        );\n        if (currentTimestamp < vestEntry.lastUpdateTimestamp) {\n            return vestEntry.accumulatedAmount - vestEntry.withdrawnAmount;\n        }\n        uint256 depositAmount = depositEntry.virtualTokenTotalSupply.div(\n            PRECISION + depositEntry.interestRate\n        );\n        return\n            vestEntry.accumulatedAmount +\n            (depositAmount * (currentTimestamp - vestEntry.lastUpdateTimestamp))\n                .mul(vestEntry.vestAmountPerStablecoinPerSecond) -\n            vestEntry.withdrawnAmount;\n    }\n\n    function getVest(uint64 vestID) external view returns (Vest memory) {\n        return _getVest(vestID);\n    }\n\n    function _getVest(uint64 vestID) internal view returns (Vest storage) {\n        return vestList[vestID - 1];\n    }\n\n    function numVests() external view returns (uint256) {\n        return vestList.length;\n    }\n\n    /**\n        NFT metadata\n     */\n\n    function contractURI() external view returns (string memory) {\n        return _contractURI;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return __baseURI;\n    }\n\n    function setContractURI(string calldata newURI) external onlyOwner {\n        _contractURI = newURI;\n    }\n\n    function setTokenURI(uint256 tokenId, string calldata newURI) external {\n        require(ownerOf(tokenId) == msg.sender, \"Vesting02: not token owner\");\n        _setTokenURI(tokenId, newURI);\n    }\n\n    /**\n        Owner functions\n     */\n\n    function setBaseURI(string calldata newURI) external onlyOwner {\n        __baseURI = newURI;\n    }\n\n    function boost(uint64 vestID, uint256 vestAmountPerStablecoinPerSecond)\n        external\n        onlyOwner\n    {\n        _getVest(vestID)\n            .vestAmountPerStablecoinPerSecond = vestAmountPerStablecoinPerSecond;\n        emit EBoost(vestID, vestAmountPerStablecoinPerSecond);\n    }\n\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/rewards/MPHMinterMainnet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {Vesting02} from \"./Vesting02.sol\";\nimport {FundingMultitoken} from \"../tokens/FundingMultitoken.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {MPHToken} from \"./MPHToken.sol\";\n\ncontract MPHMinterMainnet is AccessControlUpgradeable {\n    using AddressUpgradeable for address;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n    bytes32 public constant WHITELISTER_ROLE = keccak256(\"WHITELISTER_ROLE\");\n    bytes32 public constant WHITELISTED_POOL_ROLE =\n        keccak256(\"WHITELISTED_POOL_ROLE\");\n    bytes32 public constant LEGACY_MINTER_ROLE =\n        keccak256(\"LEGACY_MINTER_ROLE\");\n    bytes32 public constant CONVERTER_ROLE = keccak256(\"CONVERTER_ROLE\");\n\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n    event ESetParamUint(\n        address indexed sender,\n        string indexed paramName,\n        address pool,\n        uint256 newValue\n    );\n    event MintDepositorReward(\n        address indexed sender,\n        address indexed to,\n        uint256 depositorReward\n    );\n    event MintFunderReward(\n        address indexed sender,\n        address indexed to,\n        uint256 funderReward\n    );\n\n    /**\n        @notice The multiplier applied when minting MPH for a pool's depositor reward.\n                Unit is MPH-wei per depositToken-wei per second. (wei here is the smallest decimal place)\n                Scaled by 10^18.\n                NOTE: The depositToken's decimals matter!\n     */\n    mapping(address => uint256) public poolDepositorRewardMintMultiplier;\n    /**\n        @notice The multiplier applied when minting MPH for a pool's funder reward.\n                Unit is MPH-wei per depositToken-wei. (wei here is the smallest decimal place)\n                Scaled by 10^18.\n                NOTE: The depositToken's decimals matter!\n     */\n    mapping(address => uint256) public poolFunderRewardMultiplier;\n    /**\n        @notice Multiplier used for calculating dev reward\n     */\n    uint256 public devRewardMultiplier;\n    /**\n        @notice Multiplier used for calculating gov reward\n     */\n    uint256 public govRewardMultiplier;\n\n    /**\n        External contracts\n     */\n    MPHToken public mph;\n    address public govTreasury;\n    address public devWallet;\n    Vesting02 public vesting02;\n\n    function __MPHMinter_init(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) internal initializer {\n        __AccessControl_init();\n        __MPHMinter_init_unchained(\n            _mph,\n            _govTreasury,\n            _devWallet,\n            _vesting02,\n            _devRewardMultiplier,\n            _govRewardMultiplier\n        );\n    }\n\n    function __MPHMinter_init_unchained(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) internal initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        // only accounts with the whitelister role can whitelist pools\n        _setRoleAdmin(WHITELISTED_POOL_ROLE, WHITELISTER_ROLE);\n\n        mph = MPHToken(_mph);\n        govTreasury = _govTreasury;\n        devWallet = _devWallet;\n        vesting02 = Vesting02(_vesting02);\n        devRewardMultiplier = _devRewardMultiplier;\n        govRewardMultiplier = _govRewardMultiplier;\n    }\n\n    function initialize(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) external initializer {\n        __MPHMinter_init(\n            _mph,\n            _govTreasury,\n            _devWallet,\n            _vesting02,\n            _devRewardMultiplier,\n            _govRewardMultiplier\n        );\n    }\n\n    function createVestForDeposit(address account, uint64 depositID)\n        external\n        onlyRole(WHITELISTED_POOL_ROLE)\n    {\n        vesting02.createVestForDeposit(\n            account,\n            msg.sender,\n            depositID,\n            poolDepositorRewardMintMultiplier[msg.sender]\n        );\n    }\n\n    function updateVestForDeposit(\n        uint64 depositID,\n        uint256 currentDepositAmount,\n        uint256 depositAmount\n    ) external onlyRole(WHITELISTED_POOL_ROLE) {\n        vesting02.updateVestForDeposit(\n            msg.sender,\n            depositID,\n            currentDepositAmount,\n            depositAmount,\n            poolDepositorRewardMintMultiplier[msg.sender]\n        );\n    }\n\n    function mintVested(address account, uint256 amount)\n        external\n        returns (uint256 mintedAmount)\n    {\n        require(msg.sender == address(vesting02), \"MPHMinter: not vesting02\");\n        if (mph.owner() != address(this)) {\n            // not the owner of the MPH token, cannot mint\n            return 0;\n        }\n        if (amount > 0) {\n            mph.ownerMint(account, amount);\n        }\n        uint256 devReward = amount.mul(devRewardMultiplier);\n        if (devReward > 0) {\n            mph.ownerMint(devWallet, devReward);\n        }\n        uint256 govReward = amount.mul(govRewardMultiplier);\n        if (govReward > 0) {\n            mph.ownerMint(govTreasury, govReward);\n        }\n        return amount;\n    }\n\n    function distributeFundingRewards(uint64 fundingID, uint256 interestAmount)\n        external\n        onlyRole(WHITELISTED_POOL_ROLE)\n    {\n        if (interestAmount == 0 || mph.owner() != address(this)) {\n            return;\n        }\n        uint256 mintMPHAmount = interestAmount.mul(\n            poolFunderRewardMultiplier[msg.sender]\n        );\n        if (mintMPHAmount == 0) {\n            return;\n        }\n        FundingMultitoken fundingMultitoken = DInterest(msg.sender)\n            .fundingMultitoken();\n        mph.ownerMint(address(this), mintMPHAmount);\n        mph.increaseAllowance(address(fundingMultitoken), mintMPHAmount);\n        fundingMultitoken.distributeDividends(\n            fundingID,\n            address(mph),\n            mintMPHAmount\n        );\n\n        uint256 devReward = mintMPHAmount.mul(devRewardMultiplier);\n        if (devReward > 0) {\n            mph.ownerMint(devWallet, devReward);\n        }\n        uint256 govReward = mintMPHAmount.mul(govRewardMultiplier);\n        if (govReward > 0) {\n            mph.ownerMint(govTreasury, govReward);\n        }\n    }\n\n    /**\n        @dev Used for supporting the v2 MPHMinterLegacy\n     */\n    function legacyMintFunderReward(\n        address pool,\n        address to,\n        uint256 depositAmount,\n        uint256 fundingCreationTimestamp,\n        uint256 maturationTimestamp,\n        uint256, /*interestPayoutAmount*/\n        bool early\n    ) external onlyRole(LEGACY_MINTER_ROLE) returns (uint256) {\n        require(hasRole(WHITELISTED_POOL_ROLE, pool), \"MPHMinter: not pool\");\n\n        if (mph.owner() != address(this)) {\n            // not the owner of the MPH token, cannot mint\n            return 0;\n        }\n\n        uint256 funderReward;\n        uint256 devReward;\n        uint256 govReward;\n        if (!early) {\n            funderReward = maturationTimestamp > fundingCreationTimestamp\n                ? depositAmount *\n                    (maturationTimestamp - fundingCreationTimestamp).mul(\n                        poolFunderRewardMultiplier[pool]\n                    )\n                : 0;\n            devReward = funderReward.mul(devRewardMultiplier);\n            govReward = funderReward.mul(govRewardMultiplier);\n        } else {\n            return 0;\n        }\n\n        // mint and vest funder reward\n        if (funderReward > 0) {\n            mph.ownerMint(to, funderReward);\n        }\n        if (devReward > 0) {\n            mph.ownerMint(devWallet, devReward);\n        }\n        if (govReward > 0) {\n            mph.ownerMint(govTreasury, govReward);\n        }\n\n        return funderReward;\n    }\n\n    function converterMint(address to, uint256 amount)\n        external\n        onlyRole(CONVERTER_ROLE)\n    {\n        mph.ownerMint(to, amount);\n    }\n\n    /**\n        Param setters\n     */\n    function setPoolDepositorRewardMintMultiplier(\n        address pool,\n        uint256 newMultiplier\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(pool.isContract(), \"MPHMinter: pool not contract\");\n        poolDepositorRewardMintMultiplier[pool] = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"poolDepositorRewardMintMultiplier\",\n            pool,\n            newMultiplier\n        );\n    }\n\n    function setPoolFunderRewardMultiplier(address pool, uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(pool.isContract(), \"MPHMinter: pool not contract\");\n        poolFunderRewardMultiplier[pool] = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"poolFunderRewardMultiplier\",\n            pool,\n            newMultiplier\n        );\n    }\n\n    function setDevRewardMultiplier(uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newMultiplier <= PRECISION, \"MPHMinter: invalid multiplier\");\n        devRewardMultiplier = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"devRewardMultiplier\",\n            address(0),\n            newMultiplier\n        );\n    }\n\n    function setGovRewardMultiplier(uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newMultiplier <= PRECISION, \"MPHMinter: invalid multiplier\");\n        govRewardMultiplier = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"govRewardMultiplier\",\n            address(0),\n            newMultiplier\n        );\n    }\n\n    function setGovTreasury(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        govTreasury = newValue;\n        emit ESetParamAddress(msg.sender, \"govTreasury\", newValue);\n    }\n\n    function setDevWallet(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        devWallet = newValue;\n        emit ESetParamAddress(msg.sender, \"devWallet\", newValue);\n    }\n\n    function setMPHTokenOwner(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        mph.transferOwnership(newValue);\n        emit ESetParamAddress(msg.sender, \"mphTokenOwner\", newValue);\n    }\n\n    function setMPHTokenOwnerToZero() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        mph.renounceOwnership();\n        emit ESetParamAddress(msg.sender, \"mphTokenOwner\", address(0));\n    }\n\n    function setVesting02(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue.isContract(), \"MPHMinter: not contract\");\n        vesting02 = Vesting02(newValue);\n        emit ESetParamAddress(msg.sender, \"vesting02\", newValue);\n    }\n\n    uint256[42] private __gap;\n}\n"
    },
    "contracts/rewards/MPHMinterLegacy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {MPHToken} from \"./MPHToken.sol\";\nimport {MPHMinter} from \"./MPHMinter.sol\";\n\n/**\n    @title Dummy MPHMinter that doesn't mint anything. For legacy support.\n*/\ncontract MPHMinterLegacy {\n    bytes32 public constant WHITELISTED_POOL_ROLE =\n        keccak256(\"WHITELISTED_POOL_ROLE\");\n\n    MPHMinter public mphMinter;\n\n    constructor(MPHMinter _mphMinter) {\n        mphMinter = _mphMinter;\n    }\n\n    function mintDepositorReward(\n        address, /*to*/\n        uint256, /*depositAmount*/\n        uint256, /*depositPeriodInSeconds*/\n        uint256 /*interestAmount*/\n    ) external pure returns (uint256) {\n        return 0;\n    }\n\n    function takeBackDepositorReward(\n        address from,\n        uint256 mintMPHAmount,\n        bool early\n    ) external returns (uint256) {\n        require(\n            mphMinter.hasRole(WHITELISTED_POOL_ROLE, msg.sender),\n            \"NOT_POOL\"\n        );\n        if (!early) {\n            return 0;\n        }\n        mphMinter.mph().transferFrom(\n            from,\n            mphMinter.govTreasury(),\n            mintMPHAmount\n        );\n        return mintMPHAmount;\n    }\n\n    function mintFunderReward(\n        address to,\n        uint256 depositAmount,\n        uint256 fundingCreationTimestamp,\n        uint256 maturationTimestamp,\n        uint256 interestPayoutAmount,\n        bool early\n    ) external returns (uint256) {\n        return\n            mphMinter.legacyMintFunderReward(\n                msg.sender,\n                to,\n                depositAmount,\n                fundingCreationTimestamp,\n                maturationTimestamp,\n                interestPayoutAmount,\n                early\n            );\n    }\n}\n"
    },
    "contracts/rewards/MPHConverter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {MPHMinter} from \"./MPHMinter.sol\";\nimport {MPHToken} from \"./MPHToken.sol\";\n\n/**\n    @title MPHConverter\n    @notice Converts between the chain's native MPH token and foreign versions bridged from other chains\n    @dev Each foreign token has a daily limit for converting into the native token in order to limit the\n    effect of potential hacks of a deployment on another chain or a bridge. Also pausable.\n */\ncontract MPHConverter is PausableUpgradeable, OwnableUpgradeable {\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    struct DailyConvertLimit {\n        uint96 limitAmount;\n        uint96 convertedAmountToday;\n        uint64 lastResetTimestamp;\n    }\n\n    MPHMinter public mphMinter;\n    mapping(address => bool) public isWhitelistedForeignToken;\n    mapping(address => DailyConvertLimit)\n        public foreignToNativeDailyConvertLimit;\n\n    modifier onlyWhitelistedForeignToken(IERC20 foreignToken) {\n        require(\n            isWhitelistedForeignToken[address(foreignToken)],\n            \"MPHConverter: NOT_WHITELISTED\"\n        );\n        _;\n    }\n\n    modifier updateDailyConvertLimit(IERC20 foreignToken, uint256 amount) {\n        DailyConvertLimit memory limit = foreignToNativeDailyConvertLimit[\n            address(foreignToken)\n        ];\n        if (limit.lastResetTimestamp + 1 days <= block.timestamp) {\n            // more than 1 day after the last reset\n            // clear usage\n            limit.lastResetTimestamp = block.timestamp.toUint64();\n            limit.convertedAmountToday = 0;\n        }\n        limit.convertedAmountToday += amount.toUint96();\n        require(\n            limit.convertedAmountToday <= limit.limitAmount,\n            \"MPHConverter: LIMIT\"\n        );\n        foreignToNativeDailyConvertLimit[address(foreignToken)] = limit;\n        _;\n    }\n\n    function initialize(MPHMinter _mphMinter) external initializer {\n        __Pausable_init();\n        __Ownable_init();\n\n        mphMinter = _mphMinter;\n    }\n\n    /**\n        Owner functions\n     */\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setForeignTokenWhitelist(IERC20 foreignToken, bool isWhitelisted)\n        external\n        onlyOwner\n    {\n        isWhitelistedForeignToken[address(foreignToken)] = isWhitelisted;\n    }\n\n    function setForeignToNativeDailyConvertLimit(\n        IERC20 foreignToken,\n        uint96 newLimitAmount\n    ) external onlyOwner {\n        foreignToNativeDailyConvertLimit[address(foreignToken)]\n            .limitAmount = newLimitAmount;\n    }\n\n    /**\n        Convert functions\n     */\n\n    function convertNativeTokenToForeign(IERC20 foreignToken, uint256 amount)\n        external\n        whenNotPaused\n        onlyWhitelistedForeignToken(foreignToken)\n    {\n        // transfer native tokens from sender\n        IERC20(address(mphMinter.mph())).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // transfer foreign tokens to sender\n        foreignToken.safeTransfer(msg.sender, amount);\n    }\n\n    function convertForeignTokenToNative(IERC20 foreignToken, uint256 amount)\n        external\n        whenNotPaused\n        onlyWhitelistedForeignToken(foreignToken)\n        updateDailyConvertLimit(foreignToken, amount)\n    {\n        // transfer foreign tokens from sender\n        foreignToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        // transfer native tokens to sender\n        IERC20 _nativeToken = IERC20(address(mphMinter.mph()));\n        uint256 nativeTokenBalance = _nativeToken.balanceOf(address(this));\n        if (nativeTokenBalance >= amount) {\n            // contract has enough native tokens, do simple transfer\n            _nativeToken.safeTransfer(msg.sender, amount);\n        } else if (nativeTokenBalance > 0) {\n            // contract doesn't have enough, transfer balance & mint remainder\n            _nativeToken.safeTransfer(msg.sender, nativeTokenBalance);\n            mphMinter.converterMint(msg.sender, amount - nativeTokenBalance);\n        } else {\n            // contract has no native tokens, mint amount\n            mphMinter.converterMint(msg.sender, amount);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/tokens/NFTWithSVG.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC721URIStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {NFT} from \"./NFT.sol\";\nimport {NFTDescriptor} from \"../libs/NFTDescriptor.sol\";\n\ncontract NFTWithSVG is NFT {\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        string memory _tokenURI = ERC721URIStorageUpgradeable.tokenURI(tokenId);\n        return\n            bytes(_tokenURI).length > 0\n                ? _tokenURI\n                : NFTDescriptor.constructTokenURI(\n                    NFTDescriptor.URIParams({\n                        tokenId: tokenId,\n                        owner: ownerOf(tokenId),\n                        name: name(),\n                        symbol: symbol()\n                    })\n                );\n    }\n}\n"
    },
    "contracts/libs/NFTDescriptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"base64-sol/base64.sol\";\nimport \"./HexStrings.sol\";\nimport \"./NFTSVG.sol\";\n\nlibrary NFTDescriptor {\n    using Strings for uint256;\n    using HexStrings for uint256;\n\n    struct URIParams {\n        uint256 tokenId;\n        address owner;\n        string name;\n        string symbol;\n    }\n\n    function constructTokenURI(URIParams memory params)\n        public\n        pure\n        returns (string memory)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        bytes(\n                            abi.encodePacked(\n                                '{\"name\":\"',\n                                string(abi.encodePacked(params.name, \"-NFT\")),\n                                '\", \"description\":\"',\n                                generateDescription(),\n                                '\", \"image\": \"',\n                                \"data:image/svg+xml;base64,\",\n                                Base64.encode(bytes(generateSVGImage(params))),\n                                '\"}'\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function escapeQuotes(string memory symbol)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory symbolBytes = bytes(symbol);\n        uint8 quotesCount = 0;\n        for (uint8 i = 0; i < symbolBytes.length; i++) {\n            if (symbolBytes[i] == '\"') {\n                quotesCount++;\n            }\n        }\n        if (quotesCount > 0) {\n            bytes memory escapedBytes = new bytes(\n                symbolBytes.length + (quotesCount)\n            );\n            uint256 index;\n            for (uint8 i = 0; i < symbolBytes.length; i++) {\n                if (symbolBytes[i] == '\"') {\n                    escapedBytes[index++] = \"\\\\\";\n                }\n                escapedBytes[index++] = symbolBytes[i];\n            }\n            return string(escapedBytes);\n        }\n        return symbol;\n    }\n\n    function addressToString(address addr)\n        internal\n        pure\n        returns (string memory)\n    {\n        return uint256(uint160(addr)).toHexString(20);\n    }\n\n    function toColorHex(uint256 base, uint256 offset)\n        internal\n        pure\n        returns (string memory str)\n    {\n        return string((base >> offset).toHexStringNoPrefix(3));\n    }\n\n    function generateDescription() private pure returns (string memory) {\n        return\n            \"This NFT represents a 88mph bond. The owner of this NFT can change URI.\\\\n\";\n    }\n\n    function generateSVGImage(URIParams memory params)\n        internal\n        pure\n        returns (string memory svg)\n    {\n        NFTSVG.SVGParams memory svgParams = NFTSVG.SVGParams({\n            tokenId: params.tokenId,\n            name: params.name\n        });\n\n        return NFTSVG.generateSVG(svgParams);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides a function for encoding some bytes in base64\nlibrary Base64 {\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n        \n        // load the table into memory\n        string memory table = TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n            \n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n            \n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n            \n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n            \n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               dataPtr := add(dataPtr, 3)\n               \n               // read 3 bytes\n               let input := mload(dataPtr)\n               \n               // write 4 characters\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\n               resultPtr := add(resultPtr, 1)\n            }\n            \n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n        \n        return result;\n    }\n}\n"
    },
    "contracts/libs/HexStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// MODIFIED Uniswap-v3-periphery\npragma solidity 0.8.4;\n\nlibrary HexStrings {\n    bytes16 internal constant ALPHABET = \"0123456789abcdef\";\n\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/libs/NFTSVG.sol": {
      "content": "// SPDX-License-Identifier: MIT\n///@notice Inspired by Uniswap-v3-periphery NFTSVG.sol\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"base64-sol/base64.sol\";\nimport \"./HexStrings.sol\";\n\nlibrary NFTSVG {\n    using Strings for uint256;\n\n    struct SVGParams {\n        uint256 tokenId;\n        string name;\n    }\n\n    function generateSVG(SVGParams memory params)\n        internal\n        pure\n        returns (string memory svg)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    generateSVGDefs(params),\n                    generateSVGFigures(params),\n                    \"</svg>\"\n                )\n            );\n    }\n\n    function generateSVGDefs(SVGParams memory params)\n        private\n        pure\n        returns (string memory svg)\n    {\n        svg = string(\n            abi.encodePacked(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"500\" height=\"500\" fill=\"none\" xmlns:v=\"https://vecta.io/nano\"><path fill=\"',\n                isRare(params.tokenId, params.name) ? \"purple\" : \"black\",\n                '\" d=\"M0 0h500v500H0z\"/><g fill-rule=\"evenodd\"><path d=\"M235.903 292.745c6.13 10.812 21.708 10.812 27.838 0l5.902-10.41h-39.641l5.901 10.41zm-12.934-22.816l-14.066-24.811h81.839l-14.066 24.811h-53.707zm-21.1-37.216h95.906l14.066-24.811H187.803l14.066 24.811zm-21.099-37.217l-14.066-24.811H332.94l-14.066 24.811H180.77zm-21.099-37.217h180.302l16.624-29.322h-213.55l16.624 29.322zm-23.657-41.728l-5.476-9.66C124.491 96.225 132.195 83 144.456 83h210.732c12.261 0 19.966 13.225 13.919 23.891l-5.477 9.66H136.014z\" fill=\"url(#D)\"/><path d=\"M230.204 120.322c-12.086-1.977-80.192-10.49-85.513-10.642-2.28-.076-4.713-.228-5.321-.38s-2.66 0-4.56.38c-12.39 2.128-13.226 2.888-12.694 12.086.228 3.648.76 6.537 1.216 6.689s.836.912.836 1.748c0 .76.38 1.444.76 1.444.456 0 .76.532.76 1.14s.304 1.141.608 1.141c.38 0 1.065 1.216 1.673 2.66s1.292 2.66 1.672 2.66c.304 0 .608.532.608 1.141s.38 1.14.76 1.14c.456 0 .76.532.76 1.14s.38 1.14.76 1.14c.456 0 .76.532.76 1.14s.228 1.14.609 1.14c.304 0 1.216 1.293 2.052 2.813.836 1.596 2.128 3.42 2.812 4.104.76.684 1.368 1.445 1.368 1.597 0 1.064 7.602 8.209 10.262 9.577 3.725 1.976 11.934 4.713 14.062 4.713 2.432 0 1.748.988-2.28 3.268-2.053 1.14-4.181 2.889-4.637 3.725-1.064 1.976-.456 11.782.76 12.998.456.456.836 1.596.836 2.584s.38 1.748.76 1.748c.456 0 .761.989.761 2.281 0 1.216.304 2.28.684 2.28s.912 1.748 1.216 3.801c.304 2.128.836 3.8 1.216 3.8s.684.836.684 1.9.304 1.901.684 1.901.912.988 1.216 2.28c.304 1.216.836 2.28 1.217 2.28s.684.38.684.761c0 1.368 6.081 6.689 9.425 8.209 8.285 3.952 29.112 4.788 51.156 2.052 20.523-2.508 38.841-5.017 44.694-6.157 12.39-2.508 20.751-7.373 22.196-13.074.836-3.496-2.357-17.102-5.777-24.019-1.673-3.345-3.725-6.917-4.637-7.906-1.748-1.9-6.157-4.256-9.349-5.016l-2.205-.532 2.205-1.673c4.864-3.724 5.168-6.385 1.748-14.062-5.625-12.314-13.226-22.651-18.851-25.54-3.192-1.596-13.682-4.028-28.656-6.46zm126.483 18.242c-3.877-2.204-13.986-4.18-35.574-6.841-23.487-3.04-26.528-2.964-30.784.608-2.889 2.357-.684 11.098 6.385 25.54 3.268 6.765 5.777 9.578 10.109 11.402l2.889 1.216-1.901 2.28c-2.584 3.041-2.508 6.157.152 17.863 2.737 11.63 4.637 15.202 9.654 17.711 3.572 1.9 4.332 1.976 15.582 1.9 13.53 0 31.469-2.432 37.398-5.017 2.052-.836 4.56-2.66 5.625-3.952 1.9-2.205 1.976-2.661 1.596-8.438-.684-10.869-4.561-20.067-9.426-22.499l-2.432-1.216 1.672-1.672c2.357-2.357 1.977-6.613-1.368-14.823-3.268-8.133-5.929-12.009-9.577-14.062zm-166.237 4.941c-1.976-3.725-1.52-4.789 2.356-5.625 8.058-1.596 35.194 1.216 40.286 4.181 2.357 1.444 6.157 6.385 6.917 9.045.38 1.216.152 1.748-.836 1.976-1.748.38-36.713-1.292-38.233-1.9-.608-.228-2.053-.608-3.193-.836-2.66-.608-5.321-3.116-7.297-6.841zm36.713 38.082c-11.173.532-14.822 2.204-14.822 6.993 0 1.292.304 2.356.684 2.356s.912 1.14 1.141 2.584c.304 1.445 1.596 3.877 2.964 5.397 2.28 2.585 3.04 2.889 7.525 3.345 5.549.608 29.036-.988 32.077-2.205 1.596-.608 1.976-1.216 1.976-3.344 0-2.737-.988-5.929-2.28-7.525-.109-.13-.285-.353-.508-.635l-.003-.004-.002-.002h0l-.001-.001c-.559-.707-1.41-1.782-2.223-2.703-1.14-1.52-3.04-2.736-4.712-3.192-3.193-.76-15.127-1.368-21.816-1.064zm98.891-24.856c-3.192-1.14-5.625-7.677-3.268-8.589 2.66-1.14 17.406.228 20.447 1.824 1.368.76 3.04 3.496 4.028 6.689l.532 1.824-9.881-.456c-5.473-.304-10.794-.836-11.858-1.292zm10.414 22.803c-1.673.532-2.661 1.445-2.965 2.661-.684 2.66 1.901 10.185 3.725 11.173 1.596.837 16.646.304 19.155-.608 2.28-.912-.38-10.793-3.269-12.39-2.204-1.14-13.758-1.672-16.646-.836z\" fill=\"#fff\"/></g><g filter=\"url(#B)\"><path fill-rule=\"evenodd\" d=\"M240.973 255.316c-30.797 5.861-58.486 15.742-74.5 23.023a3.04 3.04 0 0 1-2.517-5.536c16.424-7.467 44.575-17.503 75.881-23.46 31.255-5.948 66.007-7.899 95.437 1.135a3.04 3.04 0 1 1-1.785 5.813c-28.055-8.612-61.668-6.845-92.516-.975z\" fill=\"#8720d2\"/></g><g filter=\"url(#C)\"><mask id=\"A\" maskUnits=\"userSpaceOnUse\" x=\"167.944\" y=\"166.317\" width=\"157\" height=\"115\" fill=\"#000\"><path fill=\"#fff\" d=\"M167.944 166.317h157v115h-157z\"/><path d=\"M174.782 246.284c-1.228.103-2.306-.328-3.233-1.291s-1.455-2.222-1.585-3.773c-.135-1.616.413-3.615 1.646-5.996s2.769-4.626 4.61-6.733c3.936-4.3 7.462-7.655 10.58-10.064l2.011-1.633c.997-.539 2.044-.855 3.143-.947a4.65 4.65 0 0 1 3.2.904c.964.635 1.487 1.437 1.569 2.407s-.008 1.856-.266 2.658-.562 1.447-.912 1.932l-1.623 2.772c-.177.21-.255.444-.234.703.016.194.154.28.412.258.324-.027 1.602-1.078 3.837-3.153 6.622-6.413 11.485-9.749 14.588-10.009 1.228-.103 2.294.198 3.2.903.964.636 1.484 1.406 1.56 2.311s-.05 1.729-.379 2.472c-.333.679-.82 1.468-1.461 2.368-1.05 1.455-1.561 2.344-1.534 2.667.022.259.259.369.711.331.517-.043 2.493-1.706 5.929-4.988s5.863-4.982 7.285-5.101 2.57.37 3.443 1.469c.932 1.028 1.447 2.124 1.545 3.287s-1.326 3.984-4.271 8.462c-2.949 4.413-4.4 6.91-4.351 7.492s.299.854.752.816c.382-.097.818-.329 1.308-.696s.961-.568 1.414-.606c.84-.071 1.29.249 1.35.96.178 2.133-.86 4.108-3.117 5.924-2.261 1.752-4.62 2.731-7.076 2.937-5.171.433-7.946-1.613-8.325-6.137-.076-.905.088-2.058.491-3.459.468-1.406.969-2.424 1.502-3.055.161-.404.236-.67.225-.8-.016-.193-.153-.28-.412-.258-.194.016-.444.135-.751.356-.312.156-1.605 1.436-3.877 3.84-6.218 6.574-10.588 9.967-13.109 10.178-1.357.114-2.432-.284-3.224-1.194-.798-.975-1.243-2.012-1.335-3.11-.167-2.004.618-4.283 2.357-6.837.166-.339.239-.638.217-.897-.027-.323-.17-.474-.428-.452s-.539.175-.84.461c-8.313 7.986-13.827 12.093-16.542 12.321z\"/><path d=\"M214.254 272.169c-.26-3.102.921-7.66 3.541-13.672 2.556-6.007 5.745-12.23 9.566-18.669 8.236-13.578 15.443-24.661 21.623-33.25l4.11-5.715c.894-.986 1.826-1.52 2.795-1.601s1.711.215 2.223.888.792 1.3.841 1.882c.043.517-.245 1.745-.863 3.685-.554 1.934-1.245 4.172-2.074 6.715l-1.412 4.122c-.048.199-.061.428-.04.686s.227.372.614.339c.453-.037 1.427-.835 2.924-2.392 4.62-4.684 8.19-7.131 10.711-7.342 4.589-.384 7.079 1.75 7.468 6.404-.122 2.419-1.317 5.643-3.583 9.673s-5.237 7.794-8.915 11.292c-3.618 3.427-7.075 5.279-10.372 5.556-1.422.119-2.68-.134-3.773-.758s-1.929-1.271-2.506-1.938-.962-.994-1.156-.977c-.129.01-.309.188-.541.533l-16.209 32.602c-2.804 5.377-5.758 8.195-8.86 8.455-1.616.136-3.003-.497-4.162-1.897-1.154-1.335-1.803-2.875-1.95-4.621zm50.457-57.341c-1.616.135-4.83 2.943-9.643 8.424-4.749 5.475-7.069 8.858-6.96 10.151.01.129.145.183.404.161 2.456-.205 5.948-2.809 10.476-7.809 4.522-5.066 6.705-8.536 6.548-10.41-.033-.388-.308-.56-.825-.517z\"/><path d=\"M318.438 230.146c-2.116 1.935-4.722 3.846-7.819 5.732-3.031 1.882-5.646 2.914-7.844 3.099-2.133.178-3.9-.325-5.301-1.509s-2.18-2.714-2.337-4.588c-.26-3.103 1.621-7.459 5.642-13.068.355-.42.525-.727.509-.921-.022-.259-.098-.383-.227-.372s-.6.213-1.414.607c-.754.323-2.827 1.994-6.219 5.012a145.76 145.76 0 0 0-9.853 9.418c-3.177 3.26-5.508 4.952-6.995 5.077-1.422.119-2.54-.406-3.354-1.574-.749-1.174-1.189-2.537-1.319-4.088-.4-4.783 2.707-12.366 9.322-22.749 6.68-10.388 13.773-19.737 21.278-28.047 7.5-8.374 12.381-12.656 14.643-12.845 1.099-.092 2.174.306 3.224 1.194 1.11.818 1.733 2.035 1.869 3.651.13 1.552-1.517 5.204-4.94 10.959s-7.275 11.837-11.554 18.249c-5.383 8.002-8.048 12.326-7.994 12.972a.34.34 0 0 0 .421.356c.258-.022 1.314-.631 3.166-1.828 1.847-1.261 3.864-2.439 6.05-3.534 2.181-1.159 3.687-1.838 4.516-2.038.889-.27 1.915-.453 3.078-.551a8.79 8.79 0 0 1 3.653.475c1.271.415 1.95 1.139 2.037 2.173.081.97-2.01 4.367-6.274 10.192-4.204 5.754-6.274 9.02-6.209 9.795.06.711.413 1.04 1.059.985 1.358-.113 3.889-1.757 7.593-4.932 1.4-1.159 2.224-1.813 2.472-1.964s.533-.24.856-.267c.905-.076 1.395.338 1.471 1.243.043.517-1.025 1.746-3.206 3.686z\"/></mask><path d=\"M174.782 246.284c-1.228.103-2.306-.328-3.233-1.291s-1.455-2.222-1.585-3.773c-.135-1.616.413-3.615 1.646-5.996s2.769-4.626 4.61-6.733c3.936-4.3 7.462-7.655 10.58-10.064l2.011-1.633c.997-.539 2.044-.855 3.143-.947a4.65 4.65 0 0 1 3.2.904c.964.635 1.487 1.437 1.569 2.407s-.008 1.856-.266 2.658-.562 1.447-.912 1.932l-1.623 2.772c-.177.21-.255.444-.234.703.016.194.154.28.412.258.324-.027 1.602-1.078 3.837-3.153 6.622-6.413 11.485-9.749 14.588-10.009 1.228-.103 2.294.198 3.2.903.964.636 1.484 1.406 1.56 2.311s-.05 1.729-.379 2.472c-.333.679-.82 1.468-1.461 2.368-1.05 1.455-1.561 2.344-1.534 2.667.022.259.259.369.711.331.517-.043 2.493-1.706 5.929-4.988s5.863-4.982 7.285-5.101 2.57.37 3.443 1.469c.932 1.028 1.447 2.124 1.545 3.287s-1.326 3.984-4.271 8.462c-2.949 4.413-4.4 6.91-4.351 7.492s.299.854.752.816c.382-.097.818-.329 1.308-.696s.961-.568 1.414-.606c.84-.071 1.29.249 1.35.96.178 2.133-.86 4.108-3.117 5.924-2.261 1.752-4.62 2.731-7.076 2.937-5.171.433-7.946-1.613-8.325-6.137-.076-.905.088-2.058.491-3.459.468-1.406.969-2.424 1.502-3.055.161-.404.236-.67.225-.8-.016-.193-.153-.28-.412-.258-.194.016-.444.135-.751.356-.312.156-1.605 1.436-3.877 3.84-6.218 6.574-10.588 9.967-13.109 10.178-1.357.114-2.432-.284-3.224-1.194-.798-.975-1.243-2.012-1.335-3.11-.167-2.004.618-4.283 2.357-6.837.166-.339.239-.638.217-.897-.027-.323-.17-.474-.428-.452s-.539.175-.84.461c-8.313 7.986-13.827 12.093-16.542 12.321z\" fill=\"url(#E)\"/><path d=\"M214.254 272.169c-.26-3.102.921-7.66 3.541-13.672 2.556-6.007 5.745-12.23 9.566-18.669 8.236-13.578 15.443-24.661 21.623-33.25l4.11-5.715c.894-.986 1.826-1.52 2.795-1.601s1.711.215 2.223.888.792 1.3.841 1.882c.043.517-.245 1.745-.863 3.685-.554 1.934-1.245 4.172-2.074 6.715l-1.412 4.122c-.048.199-.061.428-.04.686s.227.372.614.339c.453-.037 1.427-.835 2.924-2.392 4.62-4.684 8.19-7.131 10.711-7.342 4.589-.384 7.079 1.75 7.468 6.404-.122 2.419-1.317 5.643-3.583 9.673s-5.237 7.794-8.915 11.292c-3.618 3.427-7.075 5.279-10.372 5.556-1.422.119-2.68-.134-3.773-.758s-1.929-1.271-2.506-1.938-.962-.994-1.156-.977c-.129.01-.309.188-.541.533l-16.209 32.602c-2.804 5.377-5.758 8.195-8.86 8.455-1.616.136-3.003-.497-4.162-1.897-1.154-1.335-1.803-2.875-1.95-4.621zm50.457-57.341c-1.616.135-4.83 2.943-9.643 8.424-4.749 5.475-7.069 8.858-6.96 10.151.01.129.145.183.404.161 2.456-.205 5.948-2.809 10.476-7.809 4.522-5.066 6.705-8.536 6.548-10.41-.033-.388-.308-.56-.825-.517z\" fill=\"url(#E)\"/><path d=\"M318.438 230.146c-2.116 1.935-4.722 3.846-7.819 5.732-3.031 1.882-5.646 2.914-7.844 3.099-2.133.178-3.9-.325-5.301-1.509s-2.18-2.714-2.337-4.588c-.26-3.103 1.621-7.459 5.642-13.068.355-.42.525-.727.509-.921-.022-.259-.098-.383-.227-.372s-.6.213-1.414.607c-.754.323-2.827 1.994-6.219 5.012a145.76 145.76 0 0 0-9.853 9.418c-3.177 3.26-5.508 4.952-6.995 5.077-1.422.119-2.54-.406-3.354-1.574-.749-1.174-1.189-2.537-1.319-4.088-.4-4.783 2.707-12.366 9.322-22.749 6.68-10.388 13.773-19.737 21.278-28.047 7.5-8.374 12.381-12.656 14.643-12.845 1.099-.092 2.174.306 3.224 1.194 1.11.818 1.733 2.035 1.869 3.651.13 1.552-1.517 5.204-4.94 10.959s-7.275 11.837-11.554 18.249c-5.383 8.002-8.048 12.326-7.994 12.972a.34.34 0 0 0 .421.356c.258-.022 1.314-.631 3.166-1.828 1.847-1.261 3.864-2.439 6.05-3.534 2.181-1.159 3.687-1.838 4.516-2.038.889-.27 1.915-.453 3.078-.551a8.79 8.79 0 0 1 3.653.475c1.271.415 1.95 1.139 2.037 2.173.081.97-2.01 4.367-6.274 10.192-4.204 5.754-6.274 9.02-6.209 9.795.06.711.413 1.04 1.059.985 1.358-.113 3.889-1.757 7.593-4.932 1.4-1.159 2.224-1.813 2.472-1.964s.533-.24.856-.267c.905-.076 1.395.338 1.471 1.243.043.517-1.025 1.746-3.206 3.686z\" fill=\"url(#E)\"/><path d=\"M174.782 246.284c-1.228.103-2.306-.328-3.233-1.291s-1.455-2.222-1.585-3.773c-.135-1.616.413-3.615 1.646-5.996s2.769-4.626 4.61-6.733c3.936-4.3 7.462-7.655 10.58-10.064l2.011-1.633c.997-.539 2.044-.855 3.143-.947a4.65 4.65 0 0 1 3.2.904c.964.635 1.487 1.437 1.569 2.407s-.008 1.856-.266 2.658-.562 1.447-.912 1.932l-1.623 2.772c-.177.21-.255.444-.234.703.016.194.154.28.412.258.324-.027 1.602-1.078 3.837-3.153 6.622-6.413 11.485-9.749 14.588-10.009 1.228-.103 2.294.198 3.2.903.964.636 1.484 1.406 1.56 2.311s-.05 1.729-.379 2.472c-.333.679-.82 1.468-1.461 2.368-1.05 1.455-1.561 2.344-1.534 2.667.022.259.259.369.711.331.517-.043 2.493-1.706 5.929-4.988s5.863-4.982 7.285-5.101 2.57.37 3.443 1.469c.932 1.028 1.447 2.124 1.545 3.287s-1.326 3.984-4.271 8.462c-2.949 4.413-4.4 6.91-4.351 7.492s.299.854.752.816c.382-.097.818-.329 1.308-.696s.961-.568 1.414-.606c.84-.071 1.29.249 1.35.96.178 2.133-.86 4.108-3.117 5.924-2.261 1.752-4.62 2.731-7.076 2.937-5.171.433-7.946-1.613-8.325-6.137-.076-.905.088-2.058.491-3.459.468-1.406.969-2.424 1.502-3.055.161-.404.236-.67.225-.8-.016-.193-.153-.28-.412-.258-.194.016-.444.135-.751.356-.312.156-1.605 1.436-3.877 3.84-6.218 6.574-10.588 9.967-13.109 10.178-1.357.114-2.432-.284-3.224-1.194-.798-.975-1.243-2.012-1.335-3.11-.167-2.004.618-4.283 2.357-6.837.166-.339.239-.638.217-.897-.027-.323-.17-.474-.428-.452s-.539.175-.84.461c-8.313 7.986-13.827 12.093-16.542 12.321z\" stroke=\"url(#F)\" stroke-width=\"4\" mask=\"url(#A)\"/><path d=\"M214.254 272.169c-.26-3.102.921-7.66 3.541-13.672 2.556-6.007 5.745-12.23 9.566-18.669 8.236-13.578 15.443-24.661 21.623-33.25l4.11-5.715c.894-.986 1.826-1.52 2.795-1.601s1.711.215 2.223.888.792 1.3.841 1.882c.043.517-.245 1.745-.863 3.685-.554 1.934-1.245 4.172-2.074 6.715l-1.412 4.122c-.048.199-.061.428-.04.686s.227.372.614.339c.453-.037 1.427-.835 2.924-2.392 4.62-4.684 8.19-7.131 10.711-7.342 4.589-.384 7.079 1.75 7.468 6.404-.122 2.419-1.317 5.643-3.583 9.673s-5.237 7.794-8.915 11.292c-3.618 3.427-7.075 5.279-10.372 5.556-1.422.119-2.68-.134-3.773-.758s-1.929-1.271-2.506-1.938-.962-.994-1.156-.977c-.129.01-.309.188-.541.533l-16.209 32.602c-2.804 5.377-5.758 8.195-8.86 8.455-1.616.136-3.003-.497-4.162-1.897-1.154-1.335-1.803-2.875-1.95-4.621zm50.457-57.341c-1.616.135-4.83 2.943-9.643 8.424-4.749 5.475-7.069 8.858-6.96 10.151.01.129.145.183.404.161 2.456-.205 5.948-2.809 10.476-7.809 4.522-5.066 6.705-8.536 6.548-10.41-.033-.388-.308-.56-.825-.517z\" stroke=\"url(#F)\" stroke-width=\"4\" mask=\"url(#A)\"/><path d=\"M318.438 230.146c-2.116 1.935-4.722 3.846-7.819 5.732-3.031 1.882-5.646 2.914-7.844 3.099-2.133.178-3.9-.325-5.301-1.509s-2.18-2.714-2.337-4.588c-.26-3.103 1.621-7.459 5.642-13.068.355-.42.525-.727.509-.921-.022-.259-.098-.383-.227-.372s-.6.213-1.414.607c-.754.323-2.827 1.994-6.219 5.012a145.76 145.76 0 0 0-9.853 9.418c-3.177 3.26-5.508 4.952-6.995 5.077-1.422.119-2.54-.406-3.354-1.574-.749-1.174-1.189-2.537-1.319-4.088-.4-4.783 2.707-12.366 9.322-22.749 6.68-10.388 13.773-19.737 21.278-28.047 7.5-8.374 12.381-12.656 14.643-12.845 1.099-.092 2.174.306 3.224 1.194 1.11.818 1.733 2.035 1.869 3.651.13 1.552-1.517 5.204-4.94 10.959s-7.275 11.837-11.554 18.249c-5.383 8.002-8.048 12.326-7.994 12.972a.34.34 0 0 0 .421.356c.258-.022 1.314-.631 3.166-1.828 1.847-1.261 3.864-2.439 6.05-3.534 2.181-1.159 3.687-1.838 4.516-2.038.889-.27 1.915-.453 3.078-.551a8.79 8.79 0 0 1 3.653.475c1.271.415 1.95 1.139 2.037 2.173.081.97-2.01 4.367-6.274 10.192-4.204 5.754-6.274 9.02-6.209 9.795.06.711.413 1.04 1.059.985 1.358-.113 3.889-1.757 7.593-4.932 1.4-1.159 2.224-1.813 2.472-1.964s.533-.24.856-.267c.905-.076 1.395.338 1.471 1.243.043.517-1.025 1.746-3.206 3.686z\" stroke=\"url(#F)\" stroke-width=\"4\" mask=\"url(#A)\"/></g><defs><filter id=\"B\" x=\"158.174\" y=\"244.288\" width=\"183.249\" height=\"42.324\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\"><feFlood flood-opacity=\"0\" result=\"A\"/><feColorMatrix in=\"SourceAlpha\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"/><feOffset dy=\"4\"/><feGaussianBlur stdDeviation=\"2\"/><feColorMatrix values=\"0 0 0 0 0.898039 0 0 0 0 0.129412 0 0 0 0 0.615686 0 0 0 0.5 0\"/><feBlend in2=\"A\"/><feBlend in=\"SourceGraphic\"/></filter><filter id=\"C\" x=\"155.944\" y=\"159.316\" width=\"180.306\" height=\"137.389\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\"><feFlood flood-opacity=\"0\" result=\"A\"/><feColorMatrix in=\"SourceAlpha\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"/><feOffset dy=\"4\"/><feGaussianBlur stdDeviation=\"6\"/><feColorMatrix values=\"0 0 0 0 0.898039 0 0 0 0 0.129412 0 0 0 0 0.615686 0 0 0 0.5 0\"/><feBlend in2=\"A\"/><feBlend in=\"SourceGraphic\"/></filter><linearGradient id=\"D\" x1=\"249.822\" y1=\"300.854\" x2=\"249.822\" y2=\"83.787\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#ffe600\"/><stop offset=\".307\" stop-color=\"#faad14\"/><stop offset=\".672\" stop-color=\"#f7169c\"/><stop offset=\"1\" stop-color=\"#3435f5\"/></linearGradient><linearGradient id=\"E\" x1=\"252.249\" y1=\"189.416\" x2=\"279.994\" y2=\"284.81\" gradientUnits=\"userSpaceOnUse\"><stop offset=\".224\" stop-color=\"#ff009d\"/><stop offset=\".88\" stop-color=\"#3435f5\"/></linearGradient><linearGradient id=\"F\" x1=\"239.561\" y1=\"200.536\" x2=\"241.909\" y2=\"272.268\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#fff\"/><stop offset=\"1\" stop-color=\"#f7169c\"/></linearGradient></defs>'\n            )\n        );\n    }\n\n    function generateSVGFigures(SVGParams memory params)\n        private\n        pure\n        returns (string memory svg)\n    {\n        svg = generateSVGText(params);\n    }\n\n    function generateSVGText(SVGParams memory params)\n        private\n        pure\n        returns (string memory svg)\n    {\n        svg = string(\n            abi.encodePacked(\n                \"<style> .small { font: normal 16px sans-serif; } .large { font: bold 24px sans-serif; }</style>\",\n                '<text x=\"50%\" y=\"70%\" dominant-baseline=\"middle\" text-anchor=\"middle\" fill=\"#fff\" class=\"large\">',\n                params.name,\n                '</text><text x=\"50%\" y=\"80%\" dominant-baseline=\"middle\" text-anchor=\"middle\" fill=\"#fff\" class=\"small\">Token ID ',\n                params.tokenId.toString(),\n                \"</text>\"\n            )\n        );\n    }\n\n    function isRare(uint256 tokenId, string memory name)\n        internal\n        pure\n        returns (bool)\n    {\n        return uint256(keccak256(abi.encodePacked(tokenId, name))) > 5**tokenId;\n    }\n}\n"
    },
    "contracts/test/NFTDescriptorTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../libs/NFTDescriptor.sol\";\nimport \"../libs/NFTSVG.sol\";\nimport \"../libs/HexStrings.sol\";\n\ncontract NFTDescriptorTest {\n    using HexStrings for uint256;\n\n    function constructTokenURI(NFTDescriptor.URIParams calldata params)\n        external\n        pure\n        returns (string memory)\n    {\n        return NFTDescriptor.constructTokenURI(params);\n    }\n\n    function addressToString(address _address)\n        external\n        pure\n        returns (string memory)\n    {\n        return NFTDescriptor.addressToString(_address);\n    }\n\n    function generateSVGImage(NFTDescriptor.URIParams memory params)\n        external\n        pure\n        returns (string memory)\n    {\n        return NFTDescriptor.generateSVGImage(params);\n    }\n\n    function toColorHex(address token, uint256 offset)\n        external\n        pure\n        returns (string memory)\n    {\n        return NFTDescriptor.toColorHex(uint256(uint160(token)), offset);\n    }\n\n    function isRare(uint256 tokenId, string memory name)\n        external\n        pure\n        returns (bool)\n    {\n        return NFTSVG.isRare(tokenId, name);\n    }\n}\n"
    },
    "contracts/zero-coupon-bond/ZeroCouponBond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeERC20} from \"../libs/SafeERC20.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {NFT} from \"../tokens/NFT.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {Vesting02} from \"../rewards/Vesting02.sol\";\nimport {Sponsorable} from \"../libs/Sponsorable.sol\";\n\ncontract ZeroCouponBond is\n    ERC20Upgradeable,\n    ReentrancyGuardUpgradeable,\n    IERC721ReceiverUpgradeable,\n    Sponsorable\n{\n    using SafeERC20 for ERC20;\n\n    DInterest public pool;\n    ERC20 public stablecoin;\n    NFT public depositNFT;\n    Vesting02 public vesting;\n    uint64 public maturationTimestamp;\n    uint64 public depositID;\n    uint8 private _decimals;\n\n    event WithdrawDeposit();\n    event RedeemStablecoin(address indexed sender, uint256 amount);\n\n    function initialize(\n        address _creator,\n        address _pool,\n        address _vesting,\n        uint64 _maturationTimestamp,\n        uint256 _initialDepositAmount,\n        string calldata _tokenName,\n        string calldata _tokenSymbol\n    ) external initializer {\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __ReentrancyGuard_init();\n\n        pool = DInterest(_pool);\n        stablecoin = pool.stablecoin();\n        depositNFT = pool.depositNFT();\n        maturationTimestamp = _maturationTimestamp;\n        vesting = Vesting02(_vesting);\n\n        // set decimals to be the same as the underlying stablecoin\n        _decimals = pool.stablecoin().decimals();\n\n        // create deposit\n        stablecoin.safeTransferFrom(\n            _creator,\n            address(this),\n            _initialDepositAmount\n        );\n        stablecoin.safeIncreaseAllowance(address(pool), type(uint256).max);\n        uint256 interestAmount;\n        (depositID, interestAmount) = pool.deposit(\n            _initialDepositAmount,\n            maturationTimestamp\n        );\n        _mint(_creator, _initialDepositAmount + interestAmount);\n        vesting.safeTransferFrom(\n            address(this),\n            _creator,\n            vesting.depositIDToVestID(_pool, depositID)\n        );\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n        Public action functions\n     */\n    /**\n        @notice Mint zero coupon bonds by depositing `depositAmount` stablecoins.\n        @param depositAmount The amount to deposit for minting zero coupon bonds\n        @return mintedAmount The amount of bonds minted\n     */\n    function mint(uint256 depositAmount)\n        external\n        nonReentrant\n        returns (uint256 mintedAmount)\n    {\n        return _mintInternal(msg.sender, depositAmount, 0);\n    }\n\n    /**\n        @notice Mint zero coupon bonds by depositing `depositAmount` stablecoins.\n        @param depositAmount The amount to deposit for minting zero coupon bonds\n        @param minInterestAmount The minimum amount of fixed rate interest received\n        @return mintedAmount The amount of bonds minted\n     */\n    function mint(uint256 depositAmount, uint256 minInterestAmount)\n        external\n        nonReentrant\n        returns (uint256 mintedAmount)\n    {\n        return _mintInternal(msg.sender, depositAmount, minInterestAmount);\n    }\n\n    /**\n        @notice Withdraws the underlying deposit from the DInterest pool.\n     */\n    function withdrawDeposit() external nonReentrant {\n        uint256 balance = pool.getDeposit(depositID).virtualTokenTotalSupply;\n        require(balance > 0, \"ZeroCouponBond: already withdrawn\");\n        pool.withdraw(depositID, balance, false);\n\n        emit WithdrawDeposit();\n    }\n\n    /**\n        @notice Redeems zero coupon bonds 1-for-1 for the underlying stablecoins.\n        @param amount The amount of zero coupon bonds to burn\n        @param withdrawDepositIfNeeded True if withdrawDeposit() should be called if needed, false otherwise (to save gas)\n     */\n    function redeem(uint256 amount, bool withdrawDepositIfNeeded)\n        external\n        nonReentrant\n    {\n        _redeem(msg.sender, amount, withdrawDepositIfNeeded);\n    }\n\n    /**\n        Sponsored action functions\n     */\n    /**\n        @dev See {mint}\n     */\n    function sponsoredMint(\n        uint256 depositAmount,\n        uint256 minInterestAmount,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredMint.selector,\n            abi.encode(depositAmount)\n        )\n        returns (uint256 mintedAmount)\n    {\n        return\n            _mintInternal(sponsorship.sender, depositAmount, minInterestAmount);\n    }\n\n    /**\n        @dev See {redeem}\n     */\n    function sponsoredRedeem(\n        uint256 amount,\n        bool withdrawDepositIfNeeded,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredRedeem.selector,\n            abi.encode(amount, withdrawDepositIfNeeded)\n        )\n    {\n        _redeem(sponsorship.sender, amount, withdrawDepositIfNeeded);\n    }\n\n    /**\n        Public getter functions\n     */\n\n    /**\n        @notice Checks whether withdrawDeposit() needs to be called.\n        @return True if withdrawDeposit() should be called, false otherwise.\n     */\n    function withdrawDepositNeeded() external view returns (bool) {\n        return pool.getDeposit(depositID).virtualTokenTotalSupply > 0;\n    }\n\n    /**\n        Internal action functions\n     */\n\n    /**\n        @dev See {mint}\n     */\n    function _mintInternal(\n        address sender,\n        uint256 depositAmount,\n        uint256 minInterestAmount\n    ) internal returns (uint256 mintedAmount) {\n        // transfer stablecoins from `sender`\n        stablecoin.safeTransferFrom(sender, address(this), depositAmount);\n\n        // topup deposit\n        mintedAmount =\n            depositAmount +\n            pool.topupDeposit(depositID, depositAmount, minInterestAmount);\n\n        // mint zero coupon bonds to `msg.sender`\n        _mint(sender, mintedAmount);\n    }\n\n    /**\n        @dev See {redeem}\n     */\n    function _redeem(\n        address sender,\n        uint256 amount,\n        bool withdrawDepositIfNeeded\n    ) internal {\n        require(\n            block.timestamp >= maturationTimestamp,\n            \"ZeroCouponBond: not mature\"\n        );\n\n        if (withdrawDepositIfNeeded) {\n            uint256 balance = pool\n                .getDeposit(depositID)\n                .virtualTokenTotalSupply;\n            if (balance > 0) {\n                pool.withdraw(depositID, balance, false);\n                emit WithdrawDeposit();\n            }\n        }\n\n        // burn `amount` zero coupon bonds from `sender`\n        _burn(sender, amount);\n\n        // transfer `amount` stablecoins to `sender`\n        stablecoin.safeTransfer(sender, amount);\n\n        emit RedeemStablecoin(sender, amount);\n    }\n\n    function onERC721Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*tokenId*/\n        bytes memory /*data*/\n    ) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    uint256[43] private __gap;\n}\n"
    },
    "contracts/libs/Sponsorable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {SafeERC20} from \"./SafeERC20.sol\";\n\n/**\n    @notice Add support for meta-txs that use ERC20 tokens to pay for gas\n */\nabstract contract Sponsorable {\n    using SafeERC20 for IERC20;\n\n    /**\n        @dev Using uint256 for all numbers since this struct won't ever be in storage. This saves gas.\n        @param sender The user who made the meta-tx\n        @param sponsor The account that should receive the sponsor fee\n        @param sponsorFeeToken The ERC20 token address the sponsor fee is paid in\n        @param sponsorFeeAmount The amount of sponsor fee to transfer from `sender` to `sponsor`\n        @param nonce The signature nonce used for preventing replay attacks. Should equal accountNonce[sender].\n        @param deadline The timestamp after which the signature is invalid\n        @param v ECDSA signature component: Parity of the `y` coordinate of point `R`\n        @param r ECDSA signature component: x-coordinate of `R`\n        @param s ECDSA signature component: `s` value of the signature\n     */\n    struct Sponsorship {\n        address sender;\n        address sponsor;\n        address sponsorFeeToken;\n        uint256 sponsorFeeAmount;\n        uint256 nonce;\n        uint256 deadline;\n        uint256 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    mapping(address => uint256) public accountNonce;\n\n    /**\n        @dev Use this for functions that should support meta-txs.\n        @param sponsorship The sponsorship information\n        @param funcSignature The function signature (selector) of the function being called\n        @param encodedParams The parameters of the function, encoded using abi.encode()\n     */\n    modifier sponsored(\n        Sponsorship memory sponsorship,\n        bytes4 funcSignature,\n        bytes memory encodedParams\n    ) {\n        _validateSponsorship(sponsorship, funcSignature, encodedParams);\n        _paySponsor(\n            sponsorship.sender,\n            sponsorship.sponsor,\n            sponsorship.sponsorFeeToken,\n            sponsorship.sponsorFeeAmount\n        );\n        _;\n    }\n\n    /**\n        @dev Validates the signature of a meta-tx sponsorship, reverts if the signature is invalid.\n        @param sponsorship The sponsorship information\n        @param funcSignature The function signature (selector) of the function being called\n        @param encodedParams The parameters of the function, encoded using abi.encode()\n     */\n    function _validateSponsorship(\n        Sponsorship memory sponsorship,\n        bytes4 funcSignature,\n        bytes memory encodedParams\n    ) internal virtual {\n        require(\n            sponsorship.nonce == accountNonce[sponsorship.sender],\n            \"Sponsorable: BAD_NONCE\"\n        );\n        require(\n            block.timestamp <= sponsorship.deadline,\n            \"Sponsorable: SIG_DEAD\"\n        );\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(\n                    abi.encodePacked(\n                        abi.encode(\n                            chainId,\n                            address(this),\n                            sponsorship.sponsor,\n                            sponsorship.sponsorFeeToken,\n                            sponsorship.sponsorFeeAmount,\n                            sponsorship.nonce,\n                            sponsorship.deadline,\n                            funcSignature\n                        ),\n                        encodedParams\n                    )\n                )\n            )\n        );\n\n        address recoveredAddress = ECDSA.recover(\n            digest,\n            uint8(sponsorship.v),\n            sponsorship.r,\n            sponsorship.s\n        );\n        require(\n            recoveredAddress != address(0) &&\n                recoveredAddress == sponsorship.sender,\n            \"Sponsorable: BAD_SIG\"\n        );\n\n        // update nonce\n        accountNonce[sponsorship.sender] = sponsorship.nonce + 1;\n    }\n\n    /**\n        @dev Transfers `sponsorFeeAmount` of ERC20 token `sponsorFeeToken` from `sender` to `sponsor`.\n        @param sender The user who made the meta-tx\n        @param sponsor The account that should receive the sponsor fee\n        @param sponsorFeeToken The ERC20 token address the sponsor fee is paid in\n        @param sponsorFeeAmount The amount of sponsor fee to transfer from `sender` to `sponsor`\n     */\n    function _paySponsor(\n        address sender,\n        address sponsor,\n        address sponsorFeeToken,\n        uint256 sponsorFeeAmount\n    ) internal virtual {\n        if (sponsorFeeAmount == 0) {\n            return;\n        }\n\n        IERC20 token = IERC20(sponsorFeeToken);\n\n        // transfer tokens from sender to sponsor\n        token.safeTransferFrom(sender, sponsor, sponsorFeeAmount);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/mocks/HarvestStakingMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n* Synthetix: Rewards.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\npragma solidity 0.8.4;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SafeERC20} from \"../libs/SafeERC20.sol\";\n\nabstract contract IRewardDistributionRecipient is Ownable {\n    mapping(address => bool) public isRewardDistribution;\n\n    function notifyRewardAmount(uint256 reward) external virtual;\n\n    modifier onlyRewardDistribution() {\n        require(\n            isRewardDistribution[_msgSender()],\n            \"Caller is not reward distribution\"\n        );\n        _;\n    }\n\n    function setRewardDistribution(\n        address _rewardDistribution,\n        bool _isRewardDistribution\n    ) external onlyOwner {\n        isRewardDistribution[_rewardDistribution] = _isRewardDistribution;\n    }\n}\n\nabstract contract LPTokenWrapper {\n    using SafeERC20 for IERC20;\n\n    IERC20 public stakeToken;\n\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n\n    constructor(address _stakeToken) {\n        stakeToken = IERC20(_stakeToken);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply += amount;\n        _balances[msg.sender] += amount;\n        stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply -= amount;\n        _balances[msg.sender] -= amount;\n        stakeToken.safeTransfer(msg.sender, amount);\n    }\n}\n\ncontract HarvestStakingMock is LPTokenWrapper, IRewardDistributionRecipient {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    uint256 public constant DURATION = 7 days;\n\n    uint256 public starttime;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    modifier checkStart() {\n        require(block.timestamp >= starttime, \"Rewards: not start\");\n        _;\n    }\n\n    constructor(\n        address _stakeToken,\n        address _rewardToken,\n        uint256 _starttime\n    ) LPTokenWrapper(_stakeToken) {\n        rewardToken = IERC20(_rewardToken);\n        starttime = _starttime;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            (((lastTimeRewardApplicable() - lastUpdateTime) *\n                rewardRate *\n                1e18) / totalSupply());\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            (balanceOf(account) *\n                (rewardPerToken() - userRewardPerTokenPaid[account])) /\n            1e18 +\n            rewards[account];\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount)\n        public\n        override\n        updateReward(msg.sender)\n        checkStart\n    {\n        require(amount > 0, \"Rewards: cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        override\n        updateReward(msg.sender)\n        checkStart\n    {\n        require(amount > 0, \"Rewards: cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) checkStart {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        override\n        onlyRewardDistribution\n        updateReward(address(0))\n    {\n        // https://sips.synthetix.io/sips/sip-77\n        require(reward > 0, \"Rewards: reward == 0\");\n        require(\n            reward < type(uint256).max / 10**18,\n            \"Rewards: rewards too large, would lock\"\n        );\n        if (block.timestamp > starttime) {\n            if (block.timestamp >= periodFinish) {\n                rewardRate = reward / DURATION;\n            } else {\n                uint256 remaining = periodFinish - block.timestamp;\n                uint256 leftover = remaining * rewardRate;\n                rewardRate = (reward + leftover) / DURATION;\n            }\n            lastUpdateTime = block.timestamp;\n            periodFinish = block.timestamp + DURATION;\n            emit RewardAdded(reward);\n        } else {\n            rewardRate = reward / DURATION;\n            lastUpdateTime = starttime;\n            periodFinish = starttime + DURATION;\n            emit RewardAdded(reward);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/models/fee/PercentageFeeModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IFeeModel} from \"./IFeeModel.sol\";\n\ncontract PercentageFeeModel is IFeeModel, Ownable {\n    uint256 internal constant PRECISION = 10**18;\n    uint256 internal constant MAX_INTEREST_FEE = 50 * 10**16; // 50%\n    uint256 internal constant MAX_EARLY_WITHDRAW_FEE = 5 * 10**16; // 5%\n\n    struct FeeOverride {\n        bool isOverridden;\n        uint256 fee;\n    }\n\n    address payable public override beneficiary;\n    mapping(address => FeeOverride) public interestFeeOverrideForPool;\n    mapping(address => FeeOverride) public earlyWithdrawFeeOverrideForPool;\n    mapping(address => mapping(uint64 => FeeOverride))\n        public earlyWithdrawFeeOverrideForDeposit;\n\n    uint256 public interestFee;\n    uint256 public earlyWithdrawFee;\n\n    event SetBeneficiary(address newBeneficiary);\n    event SetInterestFee(uint256 newValue);\n    event SetEarlyWithdrawFee(uint256 newValue);\n    event OverrideInterestFeeForPool(address indexed pool, uint256 newFee);\n    event OverrideEarlyWithdrawFeeForPool(address indexed pool, uint256 newFee);\n    event OverrideEarlyWithdrawFeeForDeposit(\n        address indexed pool,\n        uint64 indexed depositID,\n        uint256 newFee\n    );\n\n    constructor(\n        address payable _beneficiary,\n        uint256 _interestFee,\n        uint256 _earlyWithdrawFee\n    ) {\n        require(\n            _beneficiary != address(0) &&\n                _interestFee <= MAX_INTEREST_FEE &&\n                _earlyWithdrawFee <= MAX_EARLY_WITHDRAW_FEE,\n            \"PercentageFeeModel: invalid input\"\n        );\n        beneficiary = _beneficiary;\n        interestFee = _interestFee;\n        earlyWithdrawFee = _earlyWithdrawFee;\n    }\n\n    function getInterestFeeAmount(address pool, uint256 interestAmount)\n        external\n        view\n        override\n        returns (uint256 feeAmount)\n    {\n        uint256 feeRate;\n        FeeOverride memory feeOverrideForPool = interestFeeOverrideForPool[\n            pool\n        ];\n        if (feeOverrideForPool.isOverridden) {\n            // fee has been overridden for pool\n            feeRate = feeOverrideForPool.fee;\n        } else {\n            // use default fee\n            feeRate = interestFee;\n        }\n        return (interestAmount * feeRate) / PRECISION;\n    }\n\n    function getEarlyWithdrawFeeAmount(\n        address pool,\n        uint64 depositID,\n        uint256 withdrawnDepositAmount\n    ) external view override returns (uint256 feeAmount) {\n        uint256 feeRate;\n        FeeOverride\n            memory feeOverrideForDeposit = earlyWithdrawFeeOverrideForDeposit[\n                pool\n            ][depositID];\n        if (feeOverrideForDeposit.isOverridden) {\n            // fee has been overridden for deposit\n            feeRate = feeOverrideForDeposit.fee;\n        } else {\n            FeeOverride\n                memory feeOverrideForPool = earlyWithdrawFeeOverrideForPool[\n                    pool\n                ];\n            if (feeOverrideForPool.isOverridden) {\n                // fee has been overridden for pool\n                feeRate = feeOverrideForPool.fee;\n            } else {\n                // use default fee\n                feeRate = earlyWithdrawFee;\n            }\n        }\n        return (withdrawnDepositAmount * feeRate) / PRECISION;\n    }\n\n    function setBeneficiary(address payable newValue) external onlyOwner {\n        require(newValue != address(0), \"PercentageFeeModel: 0 address\");\n        beneficiary = newValue;\n        emit SetBeneficiary(newValue);\n    }\n\n    function setInterestFee(uint256 newValue) external onlyOwner {\n        require(newValue <= MAX_INTEREST_FEE, \"PercentageFeeModel: too big\");\n        interestFee = newValue;\n        emit SetInterestFee(newValue);\n    }\n\n    function setEarlyWithdrawFee(uint256 newValue) external onlyOwner {\n        require(\n            newValue <= MAX_EARLY_WITHDRAW_FEE,\n            \"PercentageFeeModel: too big\"\n        );\n        earlyWithdrawFee = newValue;\n        emit SetEarlyWithdrawFee(newValue);\n    }\n\n    function overrideInterestFeeForPool(address pool, uint256 newFee)\n        external\n        onlyOwner\n    {\n        require(newFee <= interestFee, \"PercentageFeeModel: too big\");\n        interestFeeOverrideForPool[pool] = FeeOverride({\n            isOverridden: true,\n            fee: newFee\n        });\n        emit OverrideInterestFeeForPool(pool, newFee);\n    }\n\n    function overrideEarlyWithdrawFeeForPool(address pool, uint256 newFee)\n        external\n        onlyOwner\n    {\n        require(newFee <= earlyWithdrawFee, \"PercentageFeeModel: too big\");\n        earlyWithdrawFeeOverrideForPool[pool] = FeeOverride({\n            isOverridden: true,\n            fee: newFee\n        });\n        emit OverrideEarlyWithdrawFeeForPool(pool, newFee);\n    }\n\n    function overrideEarlyWithdrawFeeForDeposit(\n        address pool,\n        uint64 depositID,\n        uint256 newFee\n    ) external onlyOwner {\n        require(newFee <= earlyWithdrawFee, \"PercentageFeeModel: too big\");\n        earlyWithdrawFeeOverrideForDeposit[pool][depositID] = FeeOverride({\n            isOverridden: true,\n            fee: newFee\n        });\n        emit OverrideEarlyWithdrawFeeForDeposit(pool, depositID, newFee);\n    }\n}\n"
    },
    "contracts/moneymarkets/geist/GeistMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {ILendingPool} from \"./imports/ILendingPool.sol\";\nimport {ILendingPoolAddressesProvider} from \"./imports/ILendingPoolAddressesProvider.sol\";\nimport {IGeistMining} from \"./imports/IGeistMining.sol\";\n\ncontract GeistMarket is MoneyMarket {\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    uint16 internal constant REFERRALCODE = 20; // Aave referral program code\n\n    ILendingPoolAddressesProvider public provider; // Used for fetching the current address of LendingPool\n    ERC20 public override stablecoin;\n    ERC20 public aToken;\n    IGeistMining public geistMining;\n    address public rewards;\n\n    function initialize(\n        address _provider,\n        address _aToken,\n        address _geistMining,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _provider.isContract() &&\n                _aToken.isContract() &&\n                _geistMining.isContract() &&\n                _rewards != address(0) &&\n                _stablecoin.isContract(),\n            \"AaveMarket: An input address is not a contract\"\n        );\n\n        provider = ILendingPoolAddressesProvider(_provider);\n        stablecoin = ERC20(_stablecoin);\n        geistMining = IGeistMining(_geistMining);\n        aToken = ERC20(_aToken);\n        rewards = _rewards;\n\n        // Redirect reward tokens\n        IGeistMining(_geistMining).setClaimReceiver(address(this), _rewards);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"AaveMarket: amount is 0\");\n\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve `amount` stablecoin to lendingPool\n        stablecoin.safeIncreaseAllowance(address(lendingPool), amount);\n\n        // Deposit `amount` stablecoin to lendingPool\n        lendingPool.deposit(\n            address(stablecoin),\n            amount,\n            address(this),\n            REFERRALCODE\n        );\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(amountInUnderlying > 0, \"AaveMarket: amountInUnderlying is 0\");\n\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\n        // Redeem `amountInUnderlying` aToken, since 1 aToken = 1 stablecoin\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        lendingPool.withdraw(\n            address(stablecoin),\n            amountInUnderlying,\n            msg.sender\n        );\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external override {\n        address[] memory assets = new address[](1);\n        assets[0] = address(aToken);\n        geistMining.claim(address(this), assets);\n    }\n\n    /**\n        Param setters\n     */\n    function setRewards(address newValue) external override onlyOwner {\n        require(newValue != address(0), \"AaveMarket: 0 address\");\n        rewards = newValue;\n\n        // Redirect reward tokens\n        geistMining.setClaimReceiver(address(this), newValue);\n\n        emit ESetParamAddress(msg.sender, \"rewards\", newValue);\n    }\n\n    /**\n        @dev IMPORTANT MUST READ\n        This function is for restricting unauthorized accounts from taking funds\n        and ensuring only tokens not used by the MoneyMarket can be rescued.\n        IF YOU DON'T GET IT RIGHT YOU WILL LOSE PEOPLE'S MONEY\n        MAKE SURE YOU DO ALL OF THE FOLLOWING\n        1) You MUST override it in a MoneyMarket implementation.\n        2) You MUST make `super._authorizeRescue(token, target);` the first line of your overriding function.\n        3) You MUST revert during a call to this function if a token used by the MoneyMarket is being rescued.\n        4) You SHOULD look at how existing MoneyMarkets do it as an example.\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(aToken), \"AaveMarket: no steal\");\n    }\n\n    function _totalValue(\n        uint256 /*currentIncomeIndex*/\n    ) internal view override returns (uint256) {\n        return aToken.balanceOf(address(this));\n    }\n\n    function _incomeIndex() internal view override returns (uint256 index) {\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n        index = lendingPool.getReserveNormalizedIncome(address(stablecoin));\n        require(index > 0, \"AaveMarket: BAD_INDEX\");\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/moneymarkets/geist/imports/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\n// Aave lending pool interface\n// Documentation: https://docs.aave.com/developers/the-core-protocol/lendingpool/ilendingpool\n// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\ninterface ILendingPool {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/geist/imports/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n}\n"
    },
    "contracts/moneymarkets/geist/imports/IGeistMining.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\ninterface IGeistMining {\n    function setClaimReceiver(address _user, address _receiver) external;\n\n    function claim(address _user, address[] calldata _tokens) external;\n}\n"
    },
    "contracts/moneymarkets/benqi/BenqiERC20Market.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {ICERC20} from \"./imports/ICERC20.sol\";\nimport {IComptroller} from \"./imports/IComptroller.sol\";\n\ncontract BenqiERC20Market is MoneyMarket {\n    using PRBMathUD60x18 for uint256;\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    uint256 internal constant ERRCODE_OK = 0;\n\n    ICERC20 public cToken;\n    IComptroller public comptroller;\n    address public rewards;\n    ERC20 public override stablecoin;\n\n    function initialize(\n        address _cToken,\n        address _comptroller,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _cToken.isContract() &&\n                _comptroller.isContract() &&\n                _rewards != address(0) &&\n                _stablecoin.isContract(),\n            \"BenqiERC20Market: Invalid input address\"\n        );\n\n        cToken = ICERC20(_cToken);\n        comptroller = IComptroller(_comptroller);\n        rewards = _rewards;\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"BenqiERC20Market: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Deposit `amount` stablecoin into cToken\n        stablecoin.safeIncreaseAllowance(address(cToken), amount);\n        require(\n            cToken.mint(amount) == ERRCODE_OK,\n            \"BenqiERC20Market: Failed to mint cTokens\"\n        );\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"BenqiERC20Market: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInUnderlying` stablecoin from cToken\n        require(\n            cToken.redeemUnderlying(amountInUnderlying) == ERRCODE_OK,\n            \"BenqiERC20Market: Failed to redeem\"\n        );\n\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        stablecoin.safeTransfer(msg.sender, amountInUnderlying);\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external override {\n        comptroller.claimReward(0, payable(address(this))); // claim QI\n        comptroller.claimReward(1, payable(address(this))); // claim AVAX\n        ERC20 qi = ERC20(comptroller.qiAddress());\n        address _rewards = rewards;\n        qi.safeTransfer(_rewards, qi.balanceOf(address(this)));\n        payable(_rewards).transfer(address(this).balance);\n    }\n\n    /**\n        Param setters\n     */\n    function setRewards(address newValue) external override onlyOwner {\n        require(newValue != address(0), \"BenqiERC20Market: 0 address\");\n        rewards = newValue;\n        emit ESetParamAddress(msg.sender, \"rewards\", newValue);\n    }\n\n    /**\n        @dev IMPORTANT MUST READ\n        This function is for restricting unauthorized accounts from taking funds\n        and ensuring only tokens not used by the MoneyMarket can be rescued.\n        IF YOU DON'T GET IT RIGHT YOU WILL LOSE PEOPLE'S MONEY\n        MAKE SURE YOU DO ALL OF THE FOLLOWING\n        1) You MUST override it in a MoneyMarket implementation.\n        2) You MUST make `super._authorizeRescue(token, target);` the first line of your overriding function.\n        3) You MUST revert during a call to this function if a token used by the MoneyMarket is being rescued.\n        4) You SHOULD look at how existing MoneyMarkets do it as an example.\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(cToken), \"BenqiERC20Market: no steal\");\n    }\n\n    function _totalValue(uint256 currentIncomeIndex)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        uint256 cTokenBalance = cToken.balanceOf(address(this));\n        return cTokenBalance.mul(currentIncomeIndex);\n    }\n\n    function _incomeIndex() internal override returns (uint256 index) {\n        index = cToken.exchangeRateCurrent();\n        require(index > 0, \"BenqiERC20Market: BAD_INDEX\");\n    }\n\n    receive() external payable {}\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/moneymarkets/benqi/imports/ICERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n// Compound finance ERC20 market interface\n// Documentation: https://compound.finance/docs/ctokens\ninterface ICERC20 {\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account)\n        external\n        view\n        returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function accrueInterest() external returns (uint256);\n\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        returns (uint256);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        address cTokenCollateral\n    ) external returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/benqi/imports/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n// Compound finance Comptroller interface\n// Documentation: https://compound.finance/docs/comptroller\ninterface IComptroller {\n    function claimReward(uint8 rewardType, address payable holder) external;\n\n    function qiAddress() external view returns (address);\n}\n"
    },
    "contracts/rewards/MPHMinterFantomFix.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {Vesting02} from \"./Vesting02.sol\";\nimport {FundingMultitoken} from \"../tokens/FundingMultitoken.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {MPHToken} from \"./MPHToken.sol\";\n\ncontract MPHMinterFantomFix is AccessControlUpgradeable {\n    using AddressUpgradeable for address;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n    bytes32 public constant WHITELISTER_ROLE = keccak256(\"WHITELISTER_ROLE\");\n    bytes32 public constant WHITELISTED_POOL_ROLE =\n        keccak256(\"WHITELISTED_POOL_ROLE\");\n    bytes32 public constant LEGACY_MINTER_ROLE =\n        keccak256(\"LEGACY_MINTER_ROLE\");\n    bytes32 public constant CONVERTER_ROLE = keccak256(\"CONVERTER_ROLE\");\n\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n    event ESetParamUint(\n        address indexed sender,\n        string indexed paramName,\n        address pool,\n        uint256 newValue\n    );\n    event MintDepositorReward(\n        address indexed sender,\n        address indexed to,\n        uint256 depositorReward\n    );\n    event MintFunderReward(\n        address indexed sender,\n        address indexed to,\n        uint256 funderReward\n    );\n\n    /**\n        @notice The multiplier applied when minting MPH for a pool's depositor reward.\n                Unit is MPH-wei per depositToken-wei per second. (wei here is the smallest decimal place)\n                Scaled by 10^18.\n                NOTE: The depositToken's decimals matter!\n     */\n    mapping(address => uint256) public poolDepositorRewardMintMultiplier;\n    /**\n        @notice The multiplier applied when minting MPH for a pool's funder reward.\n                Unit is MPH-wei per depositToken-wei. (wei here is the smallest decimal place)\n                Scaled by 10^18.\n                NOTE: The depositToken's decimals matter!\n     */\n    mapping(address => uint256) public poolFunderRewardMultiplier;\n    /**\n        @notice Multiplier used for calculating dev reward\n     */\n    uint256 public devRewardMultiplier;\n    /**\n        @notice Multiplier used for calculating gov reward\n     */\n    uint256 public govRewardMultiplier;\n\n    /**\n        External contracts\n     */\n    MPHToken public mph;\n    address public govTreasury;\n    address public devWallet;\n    Vesting02 public vesting02;\n\n    bool public hasFixedFantomRoles;\n\n    function __MPHMinter_init(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) internal initializer {\n        __AccessControl_init();\n        __MPHMinter_init_unchained(\n            _mph,\n            _govTreasury,\n            _devWallet,\n            _vesting02,\n            _devRewardMultiplier,\n            _govRewardMultiplier\n        );\n    }\n\n    function __MPHMinter_init_unchained(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) internal initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        // only accounts with the whitelister role can whitelist pools\n        _setRoleAdmin(WHITELISTED_POOL_ROLE, WHITELISTER_ROLE);\n\n        mph = MPHToken(_mph);\n        govTreasury = _govTreasury;\n        devWallet = _devWallet;\n        vesting02 = Vesting02(_vesting02);\n        devRewardMultiplier = _devRewardMultiplier;\n        govRewardMultiplier = _govRewardMultiplier;\n    }\n\n    function initialize(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) external initializer {\n        __MPHMinter_init(\n            _mph,\n            _govTreasury,\n            _devWallet,\n            _vesting02,\n            _devRewardMultiplier,\n            _govRewardMultiplier\n        );\n    }\n\n    function fantomFixRoles() external {\n        require(!hasFixedFantomRoles, \"MPHMinterFantomFix: FIXED\");\n        require(msg.sender == govTreasury, \"MPHMinterFantomFix: WHO?\");\n\n        // grant WHITELISTER_ROLE and DEFAULT_ADMIN_ROLE to govTreasury\n        _setupRole(DEFAULT_ADMIN_ROLE, govTreasury);\n        _setupRole(WHITELISTER_ROLE, govTreasury);\n\n        // prevent calling function again\n        hasFixedFantomRoles = true;\n    }\n\n    function createVestForDeposit(address account, uint64 depositID)\n        external\n        onlyRole(WHITELISTED_POOL_ROLE)\n    {\n        vesting02.createVestForDeposit(\n            account,\n            msg.sender,\n            depositID,\n            poolDepositorRewardMintMultiplier[msg.sender]\n        );\n    }\n\n    function updateVestForDeposit(\n        uint64 depositID,\n        uint256 currentDepositAmount,\n        uint256 depositAmount\n    ) external onlyRole(WHITELISTED_POOL_ROLE) {\n        vesting02.updateVestForDeposit(\n            msg.sender,\n            depositID,\n            currentDepositAmount,\n            depositAmount,\n            poolDepositorRewardMintMultiplier[msg.sender]\n        );\n    }\n\n    function mintVested(address account, uint256 amount)\n        external\n        returns (uint256 mintedAmount)\n    {\n        require(msg.sender == address(vesting02), \"MPHMinter: not vesting02\");\n        if (mph.owner() != address(this)) {\n            // not the owner of the MPH token, cannot mint\n            return 0;\n        }\n        if (amount > 0) {\n            mph.ownerMint(account, amount);\n        }\n        uint256 devReward = amount.mul(devRewardMultiplier);\n        if (devReward > 0) {\n            mph.ownerMint(devWallet, devReward);\n        }\n        uint256 govReward = amount.mul(govRewardMultiplier);\n        if (govReward > 0) {\n            mph.ownerMint(govTreasury, govReward);\n        }\n        return amount;\n    }\n\n    function distributeFundingRewards(uint64 fundingID, uint256 interestAmount)\n        external\n        onlyRole(WHITELISTED_POOL_ROLE)\n    {\n        if (interestAmount == 0 || mph.owner() != address(this)) {\n            return;\n        }\n        uint256 mintMPHAmount = interestAmount.mul(\n            poolFunderRewardMultiplier[msg.sender]\n        );\n        if (mintMPHAmount == 0) {\n            return;\n        }\n        FundingMultitoken fundingMultitoken = DInterest(msg.sender)\n            .fundingMultitoken();\n        mph.ownerMint(address(this), mintMPHAmount);\n        mph.increaseAllowance(address(fundingMultitoken), mintMPHAmount);\n        fundingMultitoken.distributeDividends(\n            fundingID,\n            address(mph),\n            mintMPHAmount\n        );\n\n        uint256 devReward = mintMPHAmount.mul(devRewardMultiplier);\n        if (devReward > 0) {\n            mph.ownerMint(devWallet, devReward);\n        }\n        uint256 govReward = mintMPHAmount.mul(govRewardMultiplier);\n        if (govReward > 0) {\n            mph.ownerMint(govTreasury, govReward);\n        }\n    }\n\n    /**\n        @dev Used for supporting the v2 MPHMinterLegacy\n     */\n    function legacyMintFunderReward(\n        address pool,\n        address to,\n        uint256 depositAmount,\n        uint256 fundingCreationTimestamp,\n        uint256 maturationTimestamp,\n        uint256, /*interestPayoutAmount*/\n        bool early\n    ) external onlyRole(LEGACY_MINTER_ROLE) returns (uint256) {\n        require(hasRole(WHITELISTED_POOL_ROLE, pool), \"MPHMinter: not pool\");\n\n        if (mph.owner() != address(this)) {\n            // not the owner of the MPH token, cannot mint\n            return 0;\n        }\n\n        uint256 funderReward;\n        uint256 devReward;\n        uint256 govReward;\n        if (!early) {\n            funderReward = maturationTimestamp > fundingCreationTimestamp\n                ? depositAmount *\n                    (maturationTimestamp - fundingCreationTimestamp).mul(\n                        poolFunderRewardMultiplier[pool]\n                    )\n                : 0;\n            devReward = funderReward.mul(devRewardMultiplier);\n            govReward = funderReward.mul(govRewardMultiplier);\n        } else {\n            return 0;\n        }\n\n        // mint and vest funder reward\n        if (funderReward > 0) {\n            mph.ownerMint(to, funderReward);\n        }\n        if (devReward > 0) {\n            mph.ownerMint(devWallet, devReward);\n        }\n        if (govReward > 0) {\n            mph.ownerMint(govTreasury, govReward);\n        }\n\n        return funderReward;\n    }\n\n    function converterMint(address to, uint256 amount)\n        external\n        onlyRole(CONVERTER_ROLE)\n    {\n        mph.ownerMint(to, amount);\n    }\n\n    /**\n        Param setters\n     */\n    function setPoolDepositorRewardMintMultiplier(\n        address pool,\n        uint256 newMultiplier\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(pool.isContract(), \"MPHMinter: pool not contract\");\n        poolDepositorRewardMintMultiplier[pool] = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"poolDepositorRewardMintMultiplier\",\n            pool,\n            newMultiplier\n        );\n    }\n\n    function setPoolFunderRewardMultiplier(address pool, uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(pool.isContract(), \"MPHMinter: pool not contract\");\n        poolFunderRewardMultiplier[pool] = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"poolFunderRewardMultiplier\",\n            pool,\n            newMultiplier\n        );\n    }\n\n    function setDevRewardMultiplier(uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newMultiplier <= PRECISION, \"MPHMinter: invalid multiplier\");\n        devRewardMultiplier = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"devRewardMultiplier\",\n            address(0),\n            newMultiplier\n        );\n    }\n\n    function setGovRewardMultiplier(uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newMultiplier <= PRECISION, \"MPHMinter: invalid multiplier\");\n        govRewardMultiplier = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"govRewardMultiplier\",\n            address(0),\n            newMultiplier\n        );\n    }\n\n    function setGovTreasury(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        govTreasury = newValue;\n        emit ESetParamAddress(msg.sender, \"govTreasury\", newValue);\n    }\n\n    function setDevWallet(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        devWallet = newValue;\n        emit ESetParamAddress(msg.sender, \"devWallet\", newValue);\n    }\n\n    function setMPHTokenOwner(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        mph.transferOwnership(newValue);\n        emit ESetParamAddress(msg.sender, \"mphTokenOwner\", newValue);\n    }\n\n    function setMPHTokenOwnerToZero() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        mph.renounceOwnership();\n        emit ESetParamAddress(msg.sender, \"mphTokenOwner\", address(0));\n    }\n\n    function setVesting02(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue.isContract(), \"MPHMinter: not contract\");\n        vesting02 = Vesting02(newValue);\n        emit ESetParamAddress(msg.sender, \"vesting02\", newValue);\n    }\n\n    uint256[42] private __gap;\n}\n"
    },
    "contracts/Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {FundingMultitoken} from \"./tokens/FundingMultitoken.sol\";\nimport {NFTWithSVG} from \"./tokens/NFTWithSVG.sol\";\nimport {ZeroCouponBond} from \"./zero-coupon-bond/ZeroCouponBond.sol\";\nimport {EMAOracle} from \"./models/interest-oracle/EMAOracle.sol\";\nimport {AaveMarket} from \"./moneymarkets/aave/AaveMarket.sol\";\nimport {BProtocolMarket} from \"./moneymarkets/bprotocol/BProtocolMarket.sol\";\nimport {CompoundERC20Market} from \"./moneymarkets/compound/CompoundERC20Market.sol\";\nimport {CreamERC20Market} from \"./moneymarkets/cream/CreamERC20Market.sol\";\nimport {HarvestMarket} from \"./moneymarkets/harvest/HarvestMarket.sol\";\nimport {YVaultMarket} from \"./moneymarkets/yvault/YVaultMarket.sol\";\nimport {DInterest} from \"./DInterest.sol\";\nimport {DInterestWithDepositFee} from \"./DInterestWithDepositFee.sol\";\n\ncontract Factory {\n    using Clones for address;\n\n    event CreateClone(\n        string indexed contractName,\n        address template,\n        bytes32 salt,\n        address clone\n    );\n\n    function createNFT(\n        address template,\n        bytes32 salt,\n        string calldata _tokenName,\n        string calldata _tokenSymbol\n    ) external returns (NFTWithSVG) {\n        NFTWithSVG clone = NFTWithSVG(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(_tokenName, _tokenSymbol);\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"NFTWithSVG\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createFundingMultitoken(\n        address template,\n        bytes32 salt,\n        string calldata _uri,\n        address[] calldata _dividendTokens,\n        address _wrapperTemplate,\n        bool _deployWrapperOnMint,\n        string memory _baseName,\n        string memory _baseSymbol,\n        uint8 _decimals\n    ) external returns (FundingMultitoken) {\n        FundingMultitoken clone = FundingMultitoken(\n            template.cloneDeterministic(salt)\n        );\n\n        // initialize\n        clone.initialize(\n            msg.sender,\n            _uri,\n            _dividendTokens,\n            _wrapperTemplate,\n            _deployWrapperOnMint,\n            _baseName,\n            _baseSymbol,\n            _decimals\n        );\n\n        emit CreateClone(\"FundingMultitoken\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createZeroCouponBond(\n        address template,\n        bytes32 salt,\n        address _pool,\n        address _vesting,\n        uint64 _maturationTimetstamp,\n        uint256 _initialDepositAmount,\n        string calldata _tokenName,\n        string calldata _tokenSymbol\n    ) external returns (ZeroCouponBond) {\n        ZeroCouponBond clone = ZeroCouponBond(\n            template.cloneDeterministic(salt)\n        );\n\n        // initialize\n        clone.initialize(\n            msg.sender,\n            _pool,\n            _vesting,\n            _maturationTimetstamp,\n            _initialDepositAmount,\n            _tokenName,\n            _tokenSymbol\n        );\n\n        emit CreateClone(\"ZeroCouponBond\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createEMAOracle(\n        address template,\n        bytes32 salt,\n        uint256 _emaInitial,\n        uint256 _updateInterval,\n        uint256 _smoothingFactor,\n        uint256 _averageWindowInIntervals,\n        address _moneyMarket\n    ) external returns (EMAOracle) {\n        EMAOracle clone = EMAOracle(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(\n            _emaInitial,\n            _updateInterval,\n            _smoothingFactor,\n            _averageWindowInIntervals,\n            _moneyMarket\n        );\n\n        emit CreateClone(\"EMAOracle\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createAaveMarket(\n        address template,\n        bytes32 salt,\n        address _provider,\n        address _aToken,\n        address _aaveMining,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (AaveMarket) {\n        AaveMarket clone = AaveMarket(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(\n            _provider,\n            _aToken,\n            _aaveMining,\n            _rewards,\n            _rescuer,\n            _stablecoin\n        );\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"AaveMarket\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createBProtocolMarket(\n        address template,\n        bytes32 salt,\n        address _bToken,\n        address _bComptroller,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (BProtocolMarket) {\n        BProtocolMarket clone = BProtocolMarket(\n            template.cloneDeterministic(salt)\n        );\n\n        // initialize\n        clone.initialize(\n            _bToken,\n            _bComptroller,\n            _rewards,\n            _rescuer,\n            _stablecoin\n        );\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"BProtocolMarket\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createCompoundERC20Market(\n        address template,\n        bytes32 salt,\n        address _cToken,\n        address _comptroller,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (CompoundERC20Market) {\n        CompoundERC20Market clone = CompoundERC20Market(\n            template.cloneDeterministic(salt)\n        );\n\n        // initialize\n        clone.initialize(\n            _cToken,\n            _comptroller,\n            _rewards,\n            _rescuer,\n            _stablecoin\n        );\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"CompoundERC20Market\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createCreamERC20Market(\n        address template,\n        bytes32 salt,\n        address _cToken,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (CreamERC20Market) {\n        CreamERC20Market clone = CreamERC20Market(\n            template.cloneDeterministic(salt)\n        );\n\n        // initialize\n        clone.initialize(_cToken, _rescuer, _stablecoin);\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"CreamERC20Market\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createHarvestMarket(\n        address template,\n        bytes32 salt,\n        address _vault,\n        address _rewards,\n        address _stakingPool,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (HarvestMarket) {\n        HarvestMarket clone = HarvestMarket(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(_vault, _rewards, _stakingPool, _rescuer, _stablecoin);\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"HarvestMarket\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createYVaultMarket(\n        address template,\n        bytes32 salt,\n        address _vault,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (YVaultMarket) {\n        YVaultMarket clone = YVaultMarket(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(_vault, _rescuer, _stablecoin);\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"YVaultMarket\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createDInterest(\n        address template,\n        bytes32 salt,\n        uint64 _MaxDepositPeriod,\n        uint256 _MinDepositAmount,\n        address _feeModel,\n        address _interestModel,\n        address _interestOracle,\n        address _depositNFT,\n        address _fundingMultitoken,\n        address _mphMinter\n    ) external returns (DInterest) {\n        DInterest clone = DInterest(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(\n            _MaxDepositPeriod,\n            _MinDepositAmount,\n            _feeModel,\n            _interestModel,\n            _interestOracle,\n            _depositNFT,\n            _fundingMultitoken,\n            _mphMinter\n        );\n        clone.transferOwnership(msg.sender, true, false);\n\n        emit CreateClone(\"DInterest\", template, salt, address(clone));\n        return clone;\n    }\n\n    struct DInterestWithDepositFeeParams {\n        uint64 _MaxDepositPeriod;\n        uint256 _MinDepositAmount;\n        uint256 _DepositFee;\n        address _feeModel;\n        address _interestModel;\n        address _interestOracle;\n        address _depositNFT;\n        address _fundingMultitoken;\n        address _mphMinter;\n    }\n\n    function createDInterestWithDepositFee(\n        address template,\n        bytes32 salt,\n        DInterestWithDepositFeeParams calldata params\n    ) external returns (DInterestWithDepositFee) {\n        DInterestWithDepositFee clone = DInterestWithDepositFee(\n            template.cloneDeterministic(salt)\n        );\n\n        // initialize\n        clone.initialize(\n            params._MaxDepositPeriod,\n            params._MinDepositAmount,\n            params._DepositFee,\n            params._feeModel,\n            params._interestModel,\n            params._interestOracle,\n            params._depositNFT,\n            params._fundingMultitoken,\n            params._mphMinter\n        );\n        clone.transferOwnership(msg.sender, true, false);\n\n        emit CreateClone(\n            \"DInterestWithDepositFee\",\n            template,\n            salt,\n            address(clone)\n        );\n        return clone;\n    }\n\n    function predictAddress(address template, bytes32 salt)\n        external\n        view\n        returns (address)\n    {\n        return template.predictDeterministicAddress(salt);\n    }\n}\n"
    },
    "contracts/models/interest-oracle/EMAOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {IInterestOracle} from \"./IInterestOracle.sol\";\nimport {MoneyMarket} from \"../../moneymarkets/MoneyMarket.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract EMAOracle is IInterestOracle, Initializable {\n    using PRBMathUD60x18 for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n\n    /**\n        Immutable parameters\n     */\n    uint256 public UPDATE_INTERVAL;\n    uint256 public UPDATE_MULTIPLIER;\n    uint256 public ONE_MINUS_UPDATE_MULTIPLIER;\n\n    /**\n        Public variables\n     */\n    uint256 public emaStored;\n    uint256 public lastIncomeIndex;\n    uint256 public lastUpdateTimestamp;\n\n    /**\n        External contracts\n     */\n    MoneyMarket public override moneyMarket;\n\n    function initialize(\n        uint256 _emaInitial,\n        uint256 _updateInterval,\n        uint256 _smoothingFactor,\n        uint256 _averageWindowInIntervals,\n        address _moneyMarket\n    ) external initializer {\n        emaStored = _emaInitial;\n        UPDATE_INTERVAL = _updateInterval;\n        lastUpdateTimestamp = block.timestamp;\n\n        uint256 updateMultiplier = _smoothingFactor /\n            (_averageWindowInIntervals + 1);\n        UPDATE_MULTIPLIER = updateMultiplier;\n        ONE_MINUS_UPDATE_MULTIPLIER = PRECISION - updateMultiplier;\n\n        moneyMarket = MoneyMarket(_moneyMarket);\n        lastIncomeIndex = moneyMarket.incomeIndex();\n    }\n\n    function updateAndQuery()\n        external\n        override\n        returns (bool updated, uint256 value)\n    {\n        uint256 timeElapsed = block.timestamp - lastUpdateTimestamp;\n        if (timeElapsed < UPDATE_INTERVAL) {\n            return (false, emaStored);\n        }\n\n        // save gas by loading storage variables to memory\n        uint256 _lastIncomeIndex = lastIncomeIndex;\n        uint256 _emaStored = emaStored;\n\n        uint256 newIncomeIndex = moneyMarket.incomeIndex();\n        if (newIncomeIndex < _lastIncomeIndex) {\n            // Shouldn't revert (which would block execution)\n            // Assume no interest was accrued and use the last index as the new one\n            // which would push the EMA towards zero if there's e.g. an exploit\n            // in the underlying yield protocol\n            newIncomeIndex = _lastIncomeIndex;\n        }\n        // incomingValue = log2(newIncomeIndex / _lastIncomeIndex) * (1 / timeElapsed)\n        uint256 incomingValue = newIncomeIndex.div(_lastIncomeIndex).log2().mul(\n            PRBMathUD60x18.SCALE / timeElapsed\n        );\n\n        updated = true;\n        value =\n            (incomingValue *\n                UPDATE_MULTIPLIER +\n                _emaStored *\n                ONE_MINUS_UPDATE_MULTIPLIER) /\n            PRECISION;\n        emaStored = value;\n        lastIncomeIndex = newIncomeIndex;\n        lastUpdateTimestamp = block.timestamp;\n    }\n\n    function query() external view override returns (uint256 value) {\n        return emaStored;\n    }\n\n    uint256[43] private __gap;\n}\n"
    },
    "contracts/moneymarkets/aave/AaveMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {ILendingPool} from \"./imports/ILendingPool.sol\";\nimport {ILendingPoolAddressesProvider} from \"./imports/ILendingPoolAddressesProvider.sol\";\nimport {IAaveMining} from \"./imports/IAaveMining.sol\";\n\ncontract AaveMarket is MoneyMarket {\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    uint16 internal constant REFERRALCODE = 20; // Aave referral program code\n\n    ILendingPoolAddressesProvider public provider; // Used for fetching the current address of LendingPool\n    ERC20 public override stablecoin;\n    ERC20 public aToken;\n    IAaveMining public aaveMining;\n    address public rewards;\n\n    function initialize(\n        address _provider,\n        address _aToken,\n        address _aaveMining,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _provider.isContract() &&\n                _aToken.isContract() &&\n                _aaveMining.isContract() &&\n                _rewards != address(0) &&\n                _stablecoin.isContract(),\n            \"AaveMarket: An input address is not a contract\"\n        );\n\n        provider = ILendingPoolAddressesProvider(_provider);\n        stablecoin = ERC20(_stablecoin);\n        aaveMining = IAaveMining(_aaveMining);\n        aToken = ERC20(_aToken);\n        rewards = _rewards;\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"AaveMarket: amount is 0\");\n\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve `amount` stablecoin to lendingPool\n        stablecoin.safeIncreaseAllowance(address(lendingPool), amount);\n\n        // Deposit `amount` stablecoin to lendingPool\n        lendingPool.deposit(\n            address(stablecoin),\n            amount,\n            address(this),\n            REFERRALCODE\n        );\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(amountInUnderlying > 0, \"AaveMarket: amountInUnderlying is 0\");\n\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\n        // Redeem `amountInUnderlying` aToken, since 1 aToken = 1 stablecoin\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        lendingPool.withdraw(\n            address(stablecoin),\n            amountInUnderlying,\n            msg.sender\n        );\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external override {\n        address[] memory assets = new address[](1);\n        assets[0] = address(aToken);\n        aaveMining.claimRewards(assets, type(uint256).max, rewards);\n    }\n\n    /**\n        Param setters\n     */\n    function setRewards(address newValue) external override onlyOwner {\n        require(newValue != address(0), \"AaveMarket: 0 address\");\n        rewards = newValue;\n        emit ESetParamAddress(msg.sender, \"rewards\", newValue);\n    }\n\n    /**\n        @dev IMPORTANT MUST READ\n        This function is for restricting unauthorized accounts from taking funds\n        and ensuring only tokens not used by the MoneyMarket can be rescued.\n        IF YOU DON'T GET IT RIGHT YOU WILL LOSE PEOPLE'S MONEY\n        MAKE SURE YOU DO ALL OF THE FOLLOWING\n        1) You MUST override it in a MoneyMarket implementation.\n        2) You MUST make `super._authorizeRescue(token, target);` the first line of your overriding function.\n        3) You MUST revert during a call to this function if a token used by the MoneyMarket is being rescued.\n        4) You SHOULD look at how existing MoneyMarkets do it as an example.\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(aToken), \"AaveMarket: no steal\");\n    }\n\n    function _totalValue(\n        uint256 /*currentIncomeIndex*/\n    ) internal view override returns (uint256) {\n        return aToken.balanceOf(address(this));\n    }\n\n    function _incomeIndex() internal view override returns (uint256 index) {\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n        index = lendingPool.getReserveNormalizedIncome(address(stablecoin));\n        require(index > 0, \"AaveMarket: BAD_INDEX\");\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/moneymarkets/bprotocol/BProtocolMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {IBToken} from \"./imports/IBToken.sol\";\nimport {IBComptroller} from \"./imports/IBComptroller.sol\";\n\ncontract BProtocolMarket is MoneyMarket {\n    using PRBMathUD60x18 for uint256;\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    uint256 internal constant ERRCODE_OK = 0;\n\n    IBToken public bToken;\n    IBComptroller public bComptroller;\n    address public rewards;\n    ERC20 public override stablecoin;\n\n    function initialize(\n        address _bToken,\n        address _bComptroller,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _bToken.isContract() &&\n                _bComptroller.isContract() &&\n                _rewards != address(0) &&\n                _stablecoin.isContract(),\n            \"BProtocolMarket: Invalid input address\"\n        );\n\n        bToken = IBToken(_bToken);\n        bComptroller = IBComptroller(_bComptroller);\n        rewards = _rewards;\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"BProtocolMarket: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Deposit `amount` stablecoin into bToken\n        stablecoin.safeIncreaseAllowance(address(bToken), amount);\n        require(\n            bToken.mint(amount) == ERRCODE_OK,\n            \"BProtocolMarket: Failed to mint bTokens\"\n        );\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"BProtocolMarket: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInUnderlying` stablecoin from bToken\n        require(\n            bToken.redeemUnderlying(amountInUnderlying) == ERRCODE_OK,\n            \"BProtocolMarket: Failed to redeem\"\n        );\n\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        stablecoin.safeTransfer(msg.sender, amountInUnderlying);\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external override {\n        ERC20 comp = ERC20(bComptroller.registry().comp());\n        uint256 beforeBalance = comp.balanceOf(address(this));\n        bComptroller.claimComp(address(this));\n        comp.safeTransfer(\n            rewards,\n            comp.balanceOf(address(this)) - beforeBalance\n        );\n    }\n\n    /**\n        Param setters\n     */\n    function setRewards(address newValue) external override onlyOwner {\n        require(newValue != address(0), \"BProtocolMarket: 0 address\");\n        rewards = newValue;\n        emit ESetParamAddress(msg.sender, \"rewards\", newValue);\n    }\n\n    /**\n        @dev IMPORTANT MUST READ\n        This function is for restricting unauthorized accounts from taking funds\n        and ensuring only tokens not used by the MoneyMarket can be rescued.\n        IF YOU DON'T GET IT RIGHT YOU WILL LOSE PEOPLE'S MONEY\n        MAKE SURE YOU DO ALL OF THE FOLLOWING\n        1) You MUST override it in a MoneyMarket implementation.\n        2) You MUST make `super._authorizeRescue(token, target);` the first line of your overriding function.\n        3) You MUST revert during a call to this function if a token used by the MoneyMarket is being rescued.\n        4) You SHOULD look at how existing MoneyMarkets do it as an example.\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(bToken), \"BProtocolMarket: no steal\");\n    }\n\n    function _totalValue(uint256 currentIncomeIndex)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        uint256 bTokenBalance = bToken.balanceOf(address(this));\n        return bTokenBalance.mul(currentIncomeIndex);\n    }\n\n    function _incomeIndex() internal override returns (uint256 index) {\n        index = bToken.exchangeRateCurrent();\n        require(index > 0, \"BProtocolMarket: BAD_INDEX\");\n    }\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/moneymarkets/compound/CompoundERC20Market.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {ICERC20} from \"./imports/ICERC20.sol\";\nimport {IComptroller} from \"./imports/IComptroller.sol\";\n\ncontract CompoundERC20Market is MoneyMarket {\n    using PRBMathUD60x18 for uint256;\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    uint256 internal constant ERRCODE_OK = 0;\n\n    ICERC20 public cToken;\n    IComptroller public comptroller;\n    address public rewards;\n    ERC20 public override stablecoin;\n\n    function initialize(\n        address _cToken,\n        address _comptroller,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _cToken.isContract() &&\n                _comptroller.isContract() &&\n                _rewards != address(0) &&\n                _stablecoin.isContract(),\n            \"CompoundERC20Market: Invalid input address\"\n        );\n\n        cToken = ICERC20(_cToken);\n        comptroller = IComptroller(_comptroller);\n        rewards = _rewards;\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"CompoundERC20Market: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Deposit `amount` stablecoin into cToken\n        stablecoin.safeIncreaseAllowance(address(cToken), amount);\n        require(\n            cToken.mint(amount) == ERRCODE_OK,\n            \"CompoundERC20Market: Failed to mint cTokens\"\n        );\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"CompoundERC20Market: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInUnderlying` stablecoin from cToken\n        require(\n            cToken.redeemUnderlying(amountInUnderlying) == ERRCODE_OK,\n            \"CompoundERC20Market: Failed to redeem\"\n        );\n\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        stablecoin.safeTransfer(msg.sender, amountInUnderlying);\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external override {\n        ERC20 comp = ERC20(comptroller.getCompAddress());\n        uint256 beforeBalance = comp.balanceOf(address(this));\n        comptroller.claimComp(address(this));\n        comp.safeTransfer(\n            rewards,\n            comp.balanceOf(address(this)) - beforeBalance\n        );\n    }\n\n    /**\n        Param setters\n     */\n    function setRewards(address newValue) external override onlyOwner {\n        require(newValue != address(0), \"CompoundERC20Market: 0 address\");\n        rewards = newValue;\n        emit ESetParamAddress(msg.sender, \"rewards\", newValue);\n    }\n\n    /**\n        @dev IMPORTANT MUST READ\n        This function is for restricting unauthorized accounts from taking funds\n        and ensuring only tokens not used by the MoneyMarket can be rescued.\n        IF YOU DON'T GET IT RIGHT YOU WILL LOSE PEOPLE'S MONEY\n        MAKE SURE YOU DO ALL OF THE FOLLOWING\n        1) You MUST override it in a MoneyMarket implementation.\n        2) You MUST make `super._authorizeRescue(token, target);` the first line of your overriding function.\n        3) You MUST revert during a call to this function if a token used by the MoneyMarket is being rescued.\n        4) You SHOULD look at how existing MoneyMarkets do it as an example.\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(cToken), \"CompoundERC20Market: no steal\");\n    }\n\n    function _totalValue(uint256 currentIncomeIndex)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        uint256 cTokenBalance = cToken.balanceOf(address(this));\n        return cTokenBalance.mul(currentIncomeIndex);\n    }\n\n    function _incomeIndex() internal override returns (uint256 index) {\n        index = cToken.exchangeRateCurrent();\n        require(index > 0, \"CompoundERC20Market: BAD_INDEX\");\n    }\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/moneymarkets/cream/CreamERC20Market.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {ICrERC20} from \"./imports/ICrERC20.sol\";\n\ncontract CreamERC20Market is MoneyMarket {\n    using PRBMathUD60x18 for uint256;\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    uint256 internal constant ERRCODE_OK = 0;\n\n    ICrERC20 public cToken;\n    ERC20 public override stablecoin;\n\n    function initialize(\n        address _cToken,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n        // Verify input addresses\n        require(\n            _cToken.isContract() && _stablecoin.isContract(),\n            \"CreamERC20Market: An input address is not a contract\"\n        );\n\n        cToken = ICrERC20(_cToken);\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"CreamERC20Market: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Deposit `amount` stablecoin into cToken\n        stablecoin.safeIncreaseAllowance(address(cToken), amount);\n        require(\n            cToken.mint(amount) == ERRCODE_OK,\n            \"CreamERC20Market: Failed to mint cTokens\"\n        );\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"CreamERC20Market: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInUnderlying` stablecoin from cToken\n        require(\n            cToken.redeemUnderlying(amountInUnderlying) == ERRCODE_OK,\n            \"CreamERC20Market: Failed to redeem\"\n        );\n\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        stablecoin.safeTransfer(msg.sender, amountInUnderlying);\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external override {}\n\n    function setRewards(address newValue) external override onlyOwner {}\n\n    /**\n        @dev IMPORTANT MUST READ\n        This function is for restricting unauthorized accounts from taking funds\n        and ensuring only tokens not used by the MoneyMarket can be rescued.\n        IF YOU DON'T GET IT RIGHT YOU WILL LOSE PEOPLE'S MONEY\n        MAKE SURE YOU DO ALL OF THE FOLLOWING\n        1) You MUST override it in a MoneyMarket implementation.\n        2) You MUST make `super._authorizeRescue(token, target);` the first line of your overriding function.\n        3) You MUST revert during a call to this function if a token used by the MoneyMarket is being rescued.\n        4) You SHOULD look at how existing MoneyMarkets do it as an example.\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(cToken), \"CreamERC20Market: no steal\");\n    }\n\n    function _totalValue(uint256 currentIncomeIndex)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        uint256 cTokenBalance = cToken.balanceOf(address(this));\n        return cTokenBalance.mul(currentIncomeIndex);\n    }\n\n    function _incomeIndex() internal override returns (uint256 index) {\n        index = cToken.exchangeRateCurrent();\n        require(index > 0, \"CreamERC20Market: BAD_INDEX\");\n    }\n\n    uint256[48] private __gap;\n}\n"
    },
    "contracts/moneymarkets/harvest/HarvestMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {HarvestVault} from \"./imports/HarvestVault.sol\";\nimport {HarvestStaking} from \"./imports/HarvestStaking.sol\";\n\ncontract HarvestMarket is MoneyMarket {\n    using PRBMathUD60x18 for uint256;\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    HarvestVault public vault;\n    address public rewards;\n    HarvestStaking public stakingPool;\n    ERC20 public override stablecoin;\n\n    function initialize(\n        address _vault,\n        address _rewards,\n        address _stakingPool,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _vault.isContract() &&\n                _rewards != address(0) &&\n                _stakingPool.isContract() &&\n                _stablecoin.isContract(),\n            \"HarvestMarket: Invalid input address\"\n        );\n\n        vault = HarvestVault(_vault);\n        rewards = _rewards;\n        stakingPool = HarvestStaking(_stakingPool);\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"HarvestMarket: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve `amount` stablecoin to vault\n        stablecoin.safeIncreaseAllowance(address(vault), amount);\n\n        // Deposit `amount` stablecoin to vault\n        vault.deposit(amount);\n\n        // Stake vault token balance into staking pool\n        uint256 vaultShareBalance = vault.balanceOf(address(this));\n        vault.approve(address(stakingPool), vaultShareBalance);\n        stakingPool.stake(vaultShareBalance);\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"HarvestMarket: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInShares` shares from vault\n        uint256 sharePrice = vault.getPricePerFullShare();\n        uint256 amountInShares = amountInUnderlying.div(sharePrice);\n        if (amountInShares > 0) {\n            stakingPool.withdraw(amountInShares);\n            vault.withdraw(amountInShares);\n        }\n\n        // Transfer stablecoin to `msg.sender`\n        actualAmountWithdrawn = stablecoin.balanceOf(address(this));\n        if (actualAmountWithdrawn > 0) {\n            stablecoin.safeTransfer(msg.sender, actualAmountWithdrawn);\n        }\n    }\n\n    function claimRewards() external override {\n        stakingPool.getReward();\n        ERC20 rewardToken = ERC20(stakingPool.rewardToken());\n        rewardToken.safeTransfer(rewards, rewardToken.balanceOf(address(this)));\n    }\n\n    /**\n        Param setters\n     */\n    function setRewards(address newValue) external override onlyOwner {\n        require(newValue != address(0), \"HarvestMarket: 0 address\");\n        rewards = newValue;\n        emit ESetParamAddress(msg.sender, \"rewards\", newValue);\n    }\n\n    /**\n        @dev IMPORTANT MUST READ\n        This function is for restricting unauthorized accounts from taking funds\n        and ensuring only tokens not used by the MoneyMarket can be rescued.\n        IF YOU DON'T GET IT RIGHT YOU WILL LOSE PEOPLE'S MONEY\n        MAKE SURE YOU DO ALL OF THE FOLLOWING\n        1) You MUST override it in a MoneyMarket implementation.\n        2) You MUST make `super._authorizeRescue(token, target);` the first line of your overriding function.\n        3) You MUST revert during a call to this function if a token used by the MoneyMarket is being rescued.\n        4) You SHOULD look at how existing MoneyMarkets do it as an example.\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(stakingPool), \"HarvestMarket: no steal\");\n    }\n\n    function _totalValue(uint256 currentIncomeIndex)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // not including vault token balance\n        // because it should be 0 during normal operation\n        // if tokens are sent to contract by mistake\n        // they will be rescued\n        uint256 shareBalance = stakingPool.balanceOf(address(this));\n        return shareBalance.mul(currentIncomeIndex);\n    }\n\n    function _incomeIndex() internal view override returns (uint256 index) {\n        index = vault.getPricePerFullShare();\n        require(index > 0, \"HarvestMarket: BAD_INDEX\");\n    }\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/moneymarkets/yvault/YVaultMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {Vault} from \"./imports/Vault.sol\";\n\ncontract YVaultMarket is MoneyMarket {\n    using PRBMathUD60x18 for uint256;\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    Vault public vault;\n    ERC20 public override stablecoin;\n\n    function initialize(\n        address _vault,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _vault.isContract() && _stablecoin.isContract(),\n            \"YVaultMarket: An input address is not a contract\"\n        );\n\n        vault = Vault(_vault);\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"YVaultMarket: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve `amount` stablecoin to vault\n        stablecoin.safeIncreaseAllowance(address(vault), amount);\n\n        // Deposit `amount` stablecoin to vault\n        vault.deposit(amount);\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"YVaultMarket: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInShares` shares from vault\n        uint256 sharePrice = vault.pricePerShare();\n        uint256 amountInShares = amountInUnderlying.div(sharePrice);\n        if (amountInShares > 0) {\n            // maxLoss = 0\n            actualAmountWithdrawn = vault.withdraw(\n                amountInShares,\n                msg.sender,\n                0\n            );\n        }\n    }\n\n    function claimRewards() external override {}\n\n    function setRewards(address newValue) external override {}\n\n    /**\n        @dev IMPORTANT MUST READ\n        This function is for restricting unauthorized accounts from taking funds\n        and ensuring only tokens not used by the MoneyMarket can be rescued.\n        IF YOU DON'T GET IT RIGHT YOU WILL LOSE PEOPLE'S MONEY\n        MAKE SURE YOU DO ALL OF THE FOLLOWING\n        1) You MUST override it in a MoneyMarket implementation.\n        2) You MUST make `super._authorizeRescue(token, target);` the first line of your overriding function.\n        3) You MUST revert during a call to this function if a token used by the MoneyMarket is being rescued.\n        4) You SHOULD look at how existing MoneyMarkets do it as an example.\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(vault), \"YVaultMarket: no steal\");\n    }\n\n    function _totalValue(uint256 currentIncomeIndex)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        uint256 shareBalance = vault.balanceOf(address(this));\n        return shareBalance.mul(currentIncomeIndex);\n    }\n\n    function _incomeIndex() internal view override returns (uint256 index) {\n        index = vault.pricePerShare();\n        require(index > 0, \"YVaultMarket: BAD_INDEX\");\n    }\n\n    uint256[48] private __gap;\n}\n"
    },
    "contracts/DInterestWithDepositFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {DInterest} from \"./DInterest.sol\";\n\n/**\n    @dev A variant of DInterest that supports money markets with deposit fees\n */\ncontract DInterestWithDepositFee is DInterest {\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public DepositFee; // The deposit fee charged by the money market\n\n    /**\n        @param _MaxDepositPeriod The maximum deposit period, in seconds\n        @param _MinDepositAmount The minimum deposit amount, in stablecoins\n        @param _DepositFee The fee charged by the underlying money market\n        @param _feeModel Address of the FeeModel contract that determines how fees are charged\n        @param _interestModel Address of the InterestModel contract that determines how much interest to offer\n        @param _interestOracle Address of the InterestOracle contract that provides the average interest rate\n        @param _depositNFT Address of the NFT representing ownership of deposits (owner must be set to this DInterest contract)\n        @param _fundingMultitoken Address of the ERC1155 multitoken representing ownership of fundings (this DInterest contract must have the minter-burner role)\n        @param _mphMinter Address of the contract for handling minting MPH to users\n     */\n    function initialize(\n        uint64 _MaxDepositPeriod,\n        uint256 _MinDepositAmount,\n        uint256 _DepositFee,\n        address _feeModel,\n        address _interestModel,\n        address _interestOracle,\n        address _depositNFT,\n        address _fundingMultitoken,\n        address _mphMinter\n    ) external virtual initializer {\n        __DInterest_init(\n            _MaxDepositPeriod,\n            _MinDepositAmount,\n            _feeModel,\n            _interestModel,\n            _interestOracle,\n            _depositNFT,\n            _fundingMultitoken,\n            _mphMinter\n        );\n        DepositFee = _DepositFee;\n    }\n\n    /**\n        Internal action functions\n     */\n\n    /**\n        @dev See {deposit}\n     */\n    function _deposit(\n        address sender,\n        uint256 depositAmount,\n        uint64 maturationTimestamp,\n        bool rollover,\n        uint256 minimumInterestAmount,\n        string memory uri\n    )\n        internal\n        virtual\n        override\n        returns (uint64 depositID, uint256 interestAmount)\n    {\n        (depositID, interestAmount) = _depositRecordData(\n            sender,\n            _applyDepositFee(depositAmount),\n            maturationTimestamp,\n            minimumInterestAmount,\n            uri\n        );\n        _depositTransferFunds(sender, depositAmount, rollover);\n    }\n\n    /**\n        @dev See {topupDeposit}\n     */\n    function _topupDeposit(\n        address sender,\n        uint64 depositID,\n        uint256 depositAmount,\n        uint256 minimumInterestAmount\n    ) internal virtual override returns (uint256 interestAmount) {\n        interestAmount = _topupDepositRecordData(\n            sender,\n            depositID,\n            _applyDepositFee(depositAmount),\n            minimumInterestAmount\n        );\n        _topupDepositTransferFunds(sender, depositAmount);\n    }\n\n    /**\n        @dev See {fund}\n     */\n    function _fund(\n        address sender,\n        uint64 depositID,\n        uint256 fundAmount,\n        uint256 minPrincipalFunded\n    )\n        internal\n        virtual\n        override\n        returns (\n            uint64 fundingID,\n            uint256 fundingMultitokensMinted,\n            uint256 actualFundAmount,\n            uint256 principalFunded\n        )\n    {\n        (\n            fundingID,\n            fundingMultitokensMinted,\n            actualFundAmount,\n            principalFunded\n        ) = _fundRecordData(\n            sender,\n            depositID,\n            _applyDepositFee(fundAmount),\n            minPrincipalFunded\n        );\n        _fundTransferFunds(sender, _unapplyDepositFee(actualFundAmount));\n    }\n\n    /**\n        Internal getter functions\n     */\n\n    /**\n        @dev Applies a flat percentage deposit fee to a value.\n        @param amount The before-fee amount\n        @return The after-fee amount\n     */\n    function _applyDepositFee(uint256 amount)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return amount.mul(PRECISION - DepositFee);\n    }\n\n    /**\n        @dev Unapplies a flat percentage deposit fee to a value.\n        @param amount The after-fee amount\n        @return The before-fee amount\n     */\n    function _unapplyDepositFee(uint256 amount)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return amount.div(PRECISION - DepositFee);\n    }\n\n    /**\n        Param setters (only callable by the owner)\n     */\n\n    function setDepositFee(uint256 newValue) external onlyOwner {\n        require(newValue < PRECISION, \"BAD_VALUE\");\n        DepositFee = newValue;\n        emit ESetParamUint(msg.sender, \"DepositFee\", newValue);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/moneymarkets/aave/imports/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\n// Aave lending pool interface\n// Documentation: https://docs.aave.com/developers/the-core-protocol/lendingpool/ilendingpool\n// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\ninterface ILendingPool {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/aave/imports/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n}\n"
    },
    "contracts/moneymarkets/aave/imports/IAaveMining.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\n\ninterface IAaveMining {\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/bprotocol/imports/IBToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n// B.Protocol bToken interface\ninterface IBToken {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/bprotocol/imports/IBComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport \"./IRegistry.sol\";\n\n// B.Protocol BComptroller interface\ninterface IBComptroller {\n    function claimComp(address holder) external;\n\n    function registry() external returns (IRegistry);\n}\n"
    },
    "contracts/moneymarkets/bprotocol/imports/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n// B.Protocol Registry interface\ninterface IRegistry {\n    function comp() external returns (address);\n}\n"
    },
    "contracts/moneymarkets/compound/imports/ICERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n// Compound finance ERC20 market interface\n// Documentation: https://compound.finance/docs/ctokens\ninterface ICERC20 {\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account)\n        external\n        view\n        returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function accrueInterest() external returns (uint256);\n\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        returns (uint256);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        address cTokenCollateral\n    ) external returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/compound/imports/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n// Compound finance Comptroller interface\n// Documentation: https://compound.finance/docs/comptroller\ninterface IComptroller {\n    function claimComp(address holder) external;\n\n    function getCompAddress() external view returns (address);\n}\n"
    },
    "contracts/moneymarkets/cream/imports/ICrERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n// Cream ERC20 market interface\ninterface ICrERC20 {\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account)\n        external\n        view\n        returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function accrueInterest() external returns (uint256);\n\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        returns (uint256);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        address cTokenCollateral\n    ) external returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/harvest/imports/HarvestVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface HarvestVault {\n    function deposit(uint256) external;\n\n    function withdraw(uint256) external;\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/moneymarkets/harvest/imports/HarvestStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface HarvestStaking {\n    function stake(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function getReward() external;\n\n    function rewardToken() external returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/yvault/imports/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface Vault {\n    function deposit(uint256 amount) external;\n\n    function withdraw(\n        uint256 shareAmount,\n        address recipient,\n        uint256 maxLoss\n    ) external returns (uint256);\n\n    function pricePerShare() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/rewards/xMPH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {SafeERC20} from \"../libs/SafeERC20.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\n\n/**\n    @title Staked MPH\n    @author Zefram Lou\n    @notice The MPH staking contract\n */\ncontract xMPH is ERC20Upgradeable, AccessControlUpgradeable {\n    using SafeERC20 for ERC20;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n    uint256 internal constant MAX_REWARD_UNLOCK_PERIOD = 365 days;\n    bytes32 public constant DISTRIBUTOR_ROLE = keccak256(\"DISTRIBUTOR_ROLE\");\n    uint256 public constant MIN_AMOUNT = 10**9;\n\n    ERC20 public mph;\n    uint256 public rewardUnlockPeriod;\n    uint256 public currentUnlockEndTimestamp;\n    uint256 public lastRewardTimestamp;\n    uint256 public lastRewardAmount;\n\n    event DistributeReward(uint256 rewardAmount);\n\n    function __xMPH_init(\n        address _mph,\n        uint256 _rewardUnlockPeriod,\n        address _distributor\n    ) internal initializer {\n        __ERC20_init(\"Staked MPH\", \"xMPH\");\n        __AccessControl_init();\n        __xMPH_init_unchained(_mph, _rewardUnlockPeriod, _distributor);\n    }\n\n    function __xMPH_init_unchained(\n        address _mph,\n        uint256 _rewardUnlockPeriod,\n        address _distributor\n    ) internal initializer {\n        // Validate input\n        require(\n            _mph != address(0) && _distributor != address(0),\n            \"xMPH: 0 address\"\n        );\n        require(\n            _rewardUnlockPeriod > 0 &&\n                _rewardUnlockPeriod <= MAX_REWARD_UNLOCK_PERIOD,\n            \"xMPH: invalid _rewardUnlockPeriod\"\n        );\n\n        // _distributor and msg.sender are given DISTRIBUTOR_ROLE\n        // DISTRIBUTOR_ROLE is managed by itself\n        // msg.sender is given DEFAULT_ADMIN_ROLE which enables\n        // calling setRewardUnlockPeriod()\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(DISTRIBUTOR_ROLE, msg.sender);\n        _setupRole(DISTRIBUTOR_ROLE, _distributor);\n        _setRoleAdmin(DISTRIBUTOR_ROLE, DISTRIBUTOR_ROLE);\n        mph = ERC20(_mph);\n        rewardUnlockPeriod = _rewardUnlockPeriod;\n\n        // force the deployer to deposit to prevent rounding schenanigans\n        _deposit(MIN_AMOUNT);\n    }\n\n    /**\n        @param _mph The MPH token\n        @param _rewardUnlockPeriod The length of each reward distribution period, in seconds\n        @param _distributor The account that will call distributeReward()\n     */\n    function initialize(\n        address _mph,\n        uint256 _rewardUnlockPeriod,\n        address _distributor\n    ) external initializer {\n        __xMPH_init(_mph, _rewardUnlockPeriod, _distributor);\n    }\n\n    /**\n        @notice Deposit MPH to get xMPH\n        @dev The amount can't be 0\n        @param _mphAmount The amount of MPH to deposit\n        @return shareAmount The amount of xMPH minted\n     */\n    function deposit(uint256 _mphAmount)\n        external\n        virtual\n        returns (uint256 shareAmount)\n    {\n        return _deposit(_mphAmount);\n    }\n\n    /**\n        @notice Withdraw MPH using xMPH\n        @dev The amount can't be 0\n        @param _shareAmount The amount of xMPH to burn\n        @return mphAmount The amount of MPH withdrawn\n     */\n    function withdraw(uint256 _shareAmount)\n        external\n        virtual\n        returns (uint256 mphAmount)\n    {\n        return _withdraw(_shareAmount);\n    }\n\n    /**\n        @notice Compute the amount of MPH that can be withdrawn by burning\n                1 xMPH. Increases linearly during a reward distribution period.\n        @dev Initialized to be PRECISION (representing 1 MPH = 1 xMPH)\n        @return The amount of MPH that can be withdrawn by burning\n                1 xMPH\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 mphBalance = mph.balanceOf(address(this));\n        if (totalShares == 0 || mphBalance == 0) {\n            return PRECISION;\n        }\n        uint256 _lastRewardAmount = lastRewardAmount;\n        uint256 _currentUnlockEndTimestamp = currentUnlockEndTimestamp;\n        if (\n            _lastRewardAmount == 0 ||\n            block.timestamp >= _currentUnlockEndTimestamp\n        ) {\n            // no rewards or rewards fully unlocked\n            // entire balance is withdrawable\n            return mphBalance.div(totalShares);\n        } else {\n            // rewards not fully unlocked\n            // deduct locked rewards from balance\n            uint256 _lastRewardTimestamp = lastRewardTimestamp;\n            uint256 lockedRewardAmount = (_lastRewardAmount *\n                (_currentUnlockEndTimestamp - block.timestamp)) /\n                (_currentUnlockEndTimestamp - _lastRewardTimestamp);\n            return (mphBalance - lockedRewardAmount).div(totalShares);\n        }\n    }\n\n    /**\n        @notice Distributes MPH rewards to xMPH holders\n        @dev When not in a distribution period, start a new one with rewardUnlockPeriod seconds.\n             When in a distribution period, add rewards to current period\n     */\n    function distributeReward(uint256 rewardAmount) external virtual {\n        _distributeReward(rewardAmount);\n    }\n\n    function setRewardUnlockPeriod(uint256 newValue) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"xMPH: not admin\");\n        require(\n            newValue > 0 && newValue <= MAX_REWARD_UNLOCK_PERIOD,\n            \"xMPH: invalid value\"\n        );\n        rewardUnlockPeriod = newValue;\n    }\n\n    /**\n        @dev See {deposit}\n     */\n    function _deposit(uint256 _mphAmount)\n        internal\n        virtual\n        returns (uint256 shareAmount)\n    {\n        require(_mphAmount > 0, \"xMPH: amount\");\n        shareAmount = _mphAmount.div(getPricePerFullShare());\n        _mint(msg.sender, shareAmount);\n        mph.safeTransferFrom(msg.sender, address(this), _mphAmount);\n    }\n\n    /**\n        @dev See {withdraw}\n     */\n    function _withdraw(uint256 _shareAmount)\n        internal\n        virtual\n        returns (uint256 mphAmount)\n    {\n        require(\n            totalSupply() >= _shareAmount + MIN_AMOUNT && _shareAmount > 0,\n            \"xMPH: amount\"\n        );\n        mphAmount = _shareAmount.mul(getPricePerFullShare());\n        _burn(msg.sender, _shareAmount);\n        mph.safeTransfer(msg.sender, mphAmount);\n    }\n\n    /**\n        @dev See {distributeReward}\n     */\n    function _distributeReward(uint256 rewardAmount) internal {\n        require(totalSupply() >= MIN_AMOUNT, \"xMPH: supply\");\n        require(rewardAmount >= MIN_AMOUNT, \"xMPH: reward\");\n        require(\n            rewardAmount < type(uint256).max / PRECISION,\n            \"xMPH: rewards too large, would lock\"\n        );\n        require(hasRole(DISTRIBUTOR_ROLE, msg.sender), \"xMPH: not distributor\");\n\n        // transfer rewards from sender\n        mph.safeTransferFrom(msg.sender, address(this), rewardAmount);\n\n        if (block.timestamp >= currentUnlockEndTimestamp) {\n            // start new reward period\n            currentUnlockEndTimestamp = block.timestamp + rewardUnlockPeriod;\n            lastRewardTimestamp = block.timestamp;\n            lastRewardAmount = rewardAmount;\n        } else {\n            // add rewards to current reward period\n            uint256 lockedRewardAmount = (lastRewardAmount *\n                (currentUnlockEndTimestamp - block.timestamp)) /\n                (currentUnlockEndTimestamp - lastRewardTimestamp);\n            lastRewardTimestamp = block.timestamp;\n            lastRewardAmount = rewardAmount + lockedRewardAmount;\n        }\n        emit DistributeReward(rewardAmount);\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/rewards/dumpers/OneSplitDumper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {OneSplitAudit} from \"./imports/OneSplitAudit.sol\";\nimport {xMPH} from \"../xMPH.sol\";\nimport {AdminControlled} from \"../../libs/AdminControlled.sol\";\n\ncontract OneSplitDumper is AdminControlled {\n    using SafeERC20 for IERC20;\n\n    address public constant GOV_TREASURY =\n        0x56f34826Cc63151f74FA8f701E4f73C5EAae52AD;\n\n    OneSplitAudit public oneSplit;\n    xMPH public xMPHToken;\n    IERC20 public rewardToken;\n\n    function __OneSplitDumper_init(address _oneSplit, address _xMPHToken)\n        internal\n        initializer\n    {\n        __AdminControlled_init();\n        oneSplit = OneSplitAudit(_oneSplit);\n        xMPHToken = xMPH(_xMPHToken);\n        rewardToken = IERC20(address(xMPHToken.mph()));\n    }\n\n    function postUpgrade() external onlyAdmin {\n        rewardToken = IERC20(address(xMPHToken.mph()));\n    }\n\n    function getDumpParams(address tokenAddress, uint256 parts)\n        external\n        view\n        returns (uint256 returnAmount, uint256[] memory distribution)\n    {\n        IERC20 token = IERC20(tokenAddress);\n        uint256 tokenBalance = token.balanceOf(address(this));\n        (returnAmount, distribution) = oneSplit.getExpectedReturn(\n            tokenAddress,\n            address(rewardToken),\n            tokenBalance,\n            parts,\n            0\n        );\n    }\n\n    function dump(\n        address tokenAddress,\n        uint256 returnAmount,\n        uint256[] calldata distribution\n    ) external onlyAdmin {\n        // dump token for rewardToken\n        IERC20 token = IERC20(tokenAddress);\n        uint256 tokenBalance = token.balanceOf(address(this));\n        token.safeIncreaseAllowance(address(oneSplit), tokenBalance);\n\n        uint256 rewardTokenBalanceBefore = rewardToken.balanceOf(address(this));\n        oneSplit.swap(\n            tokenAddress,\n            address(rewardToken),\n            tokenBalance,\n            returnAmount,\n            distribution,\n            0\n        );\n        uint256 rewardTokenBalanceAfter = rewardToken.balanceOf(address(this));\n        require(\n            rewardTokenBalanceAfter > rewardTokenBalanceBefore,\n            \"OneSplitDumper: receivedRewardTokenAmount == 0\"\n        );\n    }\n\n    function notify() external onlyAdmin {\n        uint256 halfBalance = rewardToken.balanceOf(address(this)) / 2;\n\n        // split up balance between xMPH and gov treasury\n        rewardToken.safeIncreaseAllowance(address(xMPHToken), halfBalance);\n        xMPHToken.distributeReward(halfBalance);\n\n        rewardToken.safeTransfer(GOV_TREASURY, halfBalance);\n    }\n}\n"
    },
    "contracts/rewards/dumpers/imports/OneSplitAudit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface OneSplitAudit {\n    function swap(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata distribution,\n        uint256 flags\n    ) external payable;\n\n    function getExpectedReturn(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 flags // See constants in IOneSplit.sol\n    )\n        external\n        view\n        returns (uint256 returnAmount, uint256[] memory distribution);\n}\n"
    },
    "contracts/libs/AdminControlled.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nabstract contract AdminControlled is AccessControlUpgradeable {\n    function __AdminControlled_init() internal initializer {\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier onlyAdmin() {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender),\n            \"AdminControlled: not admin\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/rewards/dumpers/withdrawers/StakedAaveWithdrawer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {AdminControlled} from \"../../../libs/AdminControlled.sol\";\nimport {StakedAave} from \"../imports/StakedAave.sol\";\n\ncontract StakedAaveWithdrawer is AdminControlled {\n    StakedAave public constant STAKED_AAVE =\n        StakedAave(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\n\n    function stakedAaveCooldown() external onlyAdmin {\n        STAKED_AAVE.cooldown();\n    }\n\n    function stakedAaveRedeem() external onlyAdmin {\n        STAKED_AAVE.redeem(address(this), type(uint256).max);\n    }\n}\n"
    },
    "contracts/rewards/dumpers/imports/StakedAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface StakedAave {\n    function cooldown() external;\n\n    function redeem(address to, uint256 amount) external;\n}\n"
    },
    "contracts/rewards/dumpers/Dumper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {OneSplitDumper} from \"./OneSplitDumper.sol\";\nimport {CurveLPWithdrawer} from \"./withdrawers/CurveLPWithdrawer.sol\";\nimport {YearnWithdrawer} from \"./withdrawers/YearnWithdrawer.sol\";\nimport {StakedAaveWithdrawer} from \"./withdrawers/StakedAaveWithdrawer.sol\";\n\ncontract Dumper is\n    OneSplitDumper,\n    CurveLPWithdrawer,\n    YearnWithdrawer,\n    StakedAaveWithdrawer\n{\n    function initialize(address _oneSplit, address _xMPHToken)\n        external\n        initializer\n    {\n        __OneSplitDumper_init(_oneSplit, _xMPHToken);\n    }\n}\n"
    },
    "contracts/rewards/dumpers/withdrawers/CurveLPWithdrawer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ICurveFi, Zap} from \"../imports/Curve.sol\";\nimport {AdminControlled} from \"../../../libs/AdminControlled.sol\";\n\ncontract CurveLPWithdrawer is AdminControlled {\n    function curveWithdraw2(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[2] calldata minAmounts\n    ) external onlyAdmin {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdraw3(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[3] calldata minAmounts\n    ) external onlyAdmin {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdraw4(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[4] calldata minAmounts\n    ) external onlyAdmin {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdraw5(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[5] calldata minAmounts\n    ) external onlyAdmin {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdrawOneCoin(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        int128 coinIndex,\n        uint256 minAmount\n    ) external onlyAdmin {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        Zap curvePool = Zap(curvePoolAddress);\n        curvePool.remove_liquidity_one_coin(\n            lpTokenBalance,\n            coinIndex,\n            minAmount\n        );\n    }\n}\n"
    },
    "contracts/rewards/dumpers/withdrawers/YearnWithdrawer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {AdminControlled} from \"../../../libs/AdminControlled.sol\";\nimport {yERC20} from \"../imports/yERC20.sol\";\n\ncontract YearnWithdrawer is AdminControlled {\n    function yearnWithdraw(address yTokenAddress) external onlyAdmin {\n        yERC20 yToken = yERC20(yTokenAddress);\n        uint256 balance = yToken.balanceOf(address(this));\n        yToken.withdraw(balance);\n    }\n}\n"
    },
    "contracts/rewards/dumpers/imports/Curve.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface ICurveFi {\n    function remove_liquidity_imbalance(\n        uint256[2] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[3] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[4] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[5] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity(uint256 _amount, uint256[2] calldata amounts)\n        external;\n\n    function remove_liquidity(uint256 _amount, uint256[3] calldata amounts)\n        external;\n\n    function remove_liquidity(uint256 _amount, uint256[4] calldata amounts)\n        external;\n\n    function remove_liquidity(uint256 _amount, uint256[5] calldata amounts)\n        external;\n}\n\ninterface Zap {\n    function remove_liquidity_one_coin(\n        uint256,\n        int128,\n        uint256\n    ) external;\n}\n"
    },
    "contracts/rewards/dumpers/imports/yERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n// NOTE: Basically an alias for Vaults\ninterface yERC20 {\n    function balanceOf(address owner) external view returns (uint256);\n\n    function deposit(uint256 _amount) external;\n\n    function withdraw(uint256 _amount) external;\n\n    function getPricePerFullShare() external view returns (uint256);\n}\n"
    },
    "contracts/echidna/xMPHEchidnaTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.4;\n\nimport {MPHToken} from \"../rewards/MPHToken.sol\";\nimport {xMPH} from \"../rewards/xMPH.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {Asserts} from \"./Asserts.sol\";\n\ncontract xMPHEchidnaTest is Asserts {\n    using PRBMathUD60x18 for uint256;\n\n    uint256 private constant REWARD_UNLOCK_PERIOD = 14 days;\n\n    MPHToken private mphToken;\n    xMPH private xMPHToken;\n\n    constructor() {\n        // initialize\n        mphToken = new MPHToken();\n        mphToken.initialize();\n\n        // mint this contract some MPH\n        mphToken.ownerMint(address(this), 100 * PRECISION);\n\n        // deploy xMPH\n        xMPHToken = new xMPH();\n        uint256 mphAmount = xMPHToken.MIN_AMOUNT();\n        mphToken.increaseAllowance(address(xMPHToken), mphAmount);\n        xMPHToken.initialize(\n            address(mphToken),\n            REWARD_UNLOCK_PERIOD,\n            address(this)\n        );\n    }\n\n    /**\n        Checks\n     */\n\n    function sanityChecks_deposit(uint256 _mphAmount) external {\n        uint256 beforeMPHBalance = mphToken.balanceOf(address(this));\n        uint256 beforePricePerFullShare = xMPHToken.getPricePerFullShare();\n        uint256 beforeShareBalance = xMPHToken.balanceOf(address(this));\n\n        mphToken.increaseAllowance(address(xMPHToken), _mphAmount);\n        uint256 shareAmount = xMPHToken.deposit(_mphAmount);\n\n        uint256 afterMPHBalance = mphToken.balanceOf(address(this));\n        uint256 afterPricePerFullShare = xMPHToken.getPricePerFullShare();\n        uint256 afterShareBalance = xMPHToken.balanceOf(address(this));\n\n        Assert(beforeMPHBalance - afterMPHBalance == _mphAmount);\n        AssertEpsilonEqual(beforePricePerFullShare, afterPricePerFullShare);\n        Assert(\n            afterShareBalance - beforeShareBalance ==\n                _mphAmount.div(beforePricePerFullShare)\n        );\n        Assert(afterShareBalance - beforeShareBalance == shareAmount);\n    }\n\n    function sanityChecks_withdraw(uint256 _shareAmount) external {\n        uint256 beforeMPHBalance = mphToken.balanceOf(address(this));\n        uint256 beforePricePerFullShare = xMPHToken.getPricePerFullShare();\n        uint256 beforeShareBalance = xMPHToken.balanceOf(address(this));\n\n        uint256 mphAmount = xMPHToken.withdraw(_shareAmount);\n\n        uint256 afterMPHBalance = mphToken.balanceOf(address(this));\n        uint256 afterPricePerFullShare = xMPHToken.getPricePerFullShare();\n        uint256 afterShareBalance = xMPHToken.balanceOf(address(this));\n\n        Assert(\n            afterMPHBalance - beforeMPHBalance ==\n                _shareAmount.mul(beforePricePerFullShare)\n        );\n        Assert(afterMPHBalance - beforeMPHBalance == mphAmount);\n        AssertEpsilonEqual(beforePricePerFullShare, afterPricePerFullShare);\n        Assert(beforeShareBalance - afterShareBalance == _shareAmount);\n    }\n\n    function sanityChecks_distributeReward(uint256 rewardAmount) external {\n        uint256 beforeMPHBalance = mphToken.balanceOf(address(this));\n        uint256 beforePricePerFullShare = xMPHToken.getPricePerFullShare();\n\n        mphToken.increaseAllowance(address(xMPHToken), rewardAmount);\n        xMPHToken.distributeReward(rewardAmount);\n\n        uint256 afterMPHBalance = mphToken.balanceOf(address(this));\n        uint256 afterPricePerFullShare = xMPHToken.getPricePerFullShare();\n\n        Assert(xMPHToken.hasRole(xMPHToken.DISTRIBUTOR_ROLE(), address(this)));\n        Assert(beforeMPHBalance - afterMPHBalance == rewardAmount);\n        AssertEpsilonEqual(beforePricePerFullShare, afterPricePerFullShare);\n    }\n\n    /**\n        Actions\n     */\n    function action_sendMPHToContract(uint256 mphAmount) external {\n        mphToken.transfer(address(xMPHToken), mphAmount);\n    }\n}\n"
    },
    "contracts/echidna/Asserts.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n    @notice Lets Echidna work with solidity 0.8 asserts\n */\ncontract Asserts {\n    uint256 internal constant EPSILON = 10**9;\n    uint256 internal constant PRECISION = 10**18;\n\n    event AssertionFailed();\n\n    function Assert(bool condition) internal {\n        if (!condition) {\n            emit AssertionFailed();\n        }\n    }\n\n    function AssertEpsilonEqual(uint256 a, uint256 b) internal {\n        if (a == 0 || b == 0) {\n            if (Math.max(a, b) > EPSILON) {\n                emit AssertionFailed();\n            }\n        } else {\n            uint256 hi = Math.max(a, b);\n            uint256 lo = Math.min(a, b);\n            uint256 delta = ((hi - lo) * PRECISION) / lo;\n            if (delta > EPSILON) {\n                emit AssertionFailed();\n            }\n        }\n    }\n}\n"
    },
    "contracts/mocks/VaultWithDepositFeeMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract VaultWithDepositFeeMock is ERC20 {\n    using PRBMathUD60x18 for uint256;\n\n    uint256 PRECISION = 10**18;\n\n    ERC20 public underlying;\n    uint256 public depositFee;\n    uint256 public feeCollected;\n\n    constructor(address _underlying, uint256 _depositFee)\n        ERC20(\"yUSD\", \"yUSD\")\n    {\n        underlying = ERC20(_underlying);\n        depositFee = _depositFee;\n    }\n\n    function deposit(uint256 tokenAmount) public {\n        uint256 sharePrice = getPricePerFullShare();\n        uint256 shareAmountAfterFee = tokenAmount.div(sharePrice).mul(\n            PRECISION - depositFee\n        );\n        uint256 tokenFee = tokenAmount.mul(depositFee);\n        _mint(msg.sender, shareAmountAfterFee);\n\n        underlying.transferFrom(msg.sender, address(this), tokenAmount);\n\n        feeCollected = feeCollected + tokenFee;\n    }\n\n    function withdraw(uint256 sharesAmount) public {\n        uint256 sharePrice = getPricePerFullShare();\n        uint256 underlyingAmount = sharesAmount.mul(sharePrice);\n        _burn(msg.sender, sharesAmount);\n\n        underlying.transfer(msg.sender, underlyingAmount);\n    }\n\n    function getPricePerFullShare() public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return 10**18;\n        }\n        return\n            (underlying.balanceOf(address(this)) - feeCollected).div(\n                _totalSupply\n            );\n    }\n\n    function pricePerShare() external view returns (uint256) {\n        return getPricePerFullShare();\n    }\n}\n"
    },
    "contracts/mocks/VaultMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract VaultMock is ERC20 {\n    using PRBMathUD60x18 for uint256;\n\n    ERC20 public underlying;\n\n    constructor(address _underlying) ERC20(\"yUSD\", \"yUSD\") {\n        underlying = ERC20(_underlying);\n    }\n\n    function deposit(uint256 tokenAmount) public {\n        uint256 sharePrice = getPricePerFullShare();\n        _mint(msg.sender, tokenAmount.div(sharePrice));\n\n        underlying.transferFrom(msg.sender, address(this), tokenAmount);\n    }\n\n    function withdraw(uint256 sharesAmount)\n        public\n        returns (uint256 underlyingAmount)\n    {\n        uint256 sharePrice = getPricePerFullShare();\n        underlyingAmount = sharesAmount.mul(sharePrice);\n        _burn(msg.sender, sharesAmount);\n\n        underlying.transfer(msg.sender, underlyingAmount);\n    }\n\n    function withdraw(\n        uint256 sharesAmount,\n        address recipient,\n        uint256 maxLoss\n    ) public returns (uint256 underlyingAmount) {\n        uint256 sharePrice = getPricePerFullShare();\n        underlyingAmount = sharesAmount.mul(sharePrice);\n        _burn(msg.sender, sharesAmount);\n\n        underlying.transfer(recipient, underlyingAmount);\n    }\n\n    function getPricePerFullShare() public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return 10**18;\n        }\n        return underlying.balanceOf(address(this)).div(_totalSupply);\n    }\n\n    function pricePerShare() external view returns (uint256) {\n        return getPricePerFullShare();\n    }\n}\n"
    },
    "contracts/mocks/LendingPoolMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ATokenMock} from \"./ATokenMock.sol\";\n\ncontract LendingPoolMock {\n    mapping(address => address) internal reserveAToken;\n\n    function setReserveAToken(address _reserve, address _aTokenAddress)\n        external\n    {\n        reserveAToken[_reserve] = _aTokenAddress;\n    }\n\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16\n    ) external {\n        // Transfer asset\n        ERC20 token = ERC20(asset);\n        token.transferFrom(msg.sender, address(this), amount);\n\n        // Mint aTokens\n        address aTokenAddress = reserveAToken[asset];\n        ATokenMock aToken = ATokenMock(aTokenAddress);\n        aToken.mint(onBehalfOf, amount);\n    }\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        // Burn aTokens\n        address aTokenAddress = reserveAToken[asset];\n        ATokenMock aToken = ATokenMock(aTokenAddress);\n        aToken.burn(msg.sender, amount);\n\n        // Transfer asset\n        ERC20 token = ERC20(asset);\n        token.transfer(to, amount);\n        return amount;\n    }\n\n    // The equivalent of exchangeRateStored() for Compound cTokens\n    function getReserveNormalizedIncome(address asset)\n        external\n        view\n        returns (uint256)\n    {\n        address aTokenAddress = reserveAToken[asset];\n        ATokenMock aToken = ATokenMock(aTokenAddress);\n        return aToken.normalizedIncome();\n    }\n}\n"
    },
    "contracts/mocks/ATokenMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract ATokenMock is ERC20 {\n    using PRBMathUD60x18 for uint256;\n\n    uint256 internal constant YEAR = 31556952; // Number of seconds in one Gregorian calendar year (365.2425 days)\n\n    ERC20 public dai;\n    uint256 public liquidityRate;\n    uint256 public normalizedIncome;\n    address[] public users;\n    mapping(address => bool) public isUser;\n\n    constructor(address _dai) ERC20(\"aDAI\", \"aDAI\") {\n        dai = ERC20(_dai);\n\n        liquidityRate = 10**26; // 10% APY\n        normalizedIncome = 10**27;\n    }\n\n    function mint(address _user, uint256 _amount) external {\n        _mint(_user, _amount);\n        if (!isUser[_user]) {\n            users.push(_user);\n            isUser[_user] = true;\n        }\n    }\n\n    function burn(address _user, uint256 _amount) external {\n        _burn(_user, _amount);\n    }\n\n    function mintInterest(uint256 _seconds) external {\n        uint256 interest;\n        address user;\n        for (uint256 i = 0; i < users.length; i++) {\n            user = users[i];\n            interest =\n                (balanceOf(user) * _seconds * liquidityRate) /\n                (YEAR * 10**27);\n            _mint(user, interest);\n        }\n        normalizedIncome +=\n            (normalizedIncome * _seconds * liquidityRate) /\n            (YEAR * 10**27);\n    }\n\n    function setLiquidityRate(uint256 _liquidityRate) external {\n        liquidityRate = _liquidityRate;\n    }\n}\n"
    },
    "contracts/EchidnaDepositWithdrawTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.4;\n\nimport \"./mocks/ERC20Mock.sol\";\nimport \"./mocks/ATokenMock.sol\";\nimport \"./DInterest.sol\";\n\n// --------------------------------------------------------------------------------\n// tests that `deposit` and `withdraw`:\n// 1) revert if they should\n// 2) don't revert if they shouldn't\n// 3) return correct values\n// 4) transfer correct amounts\n// --------------------------------------------------------------------------------\n\ncontract EchidnaDepositWithdrawTest {\n    // --------------------------------------------------------------------------------\n    // event declarations\n    // --------------------------------------------------------------------------------\n\n    event Log(string message);\n    event LogUint256(string message, uint256 x);\n\n    // Echidna interprets emissions of this event as assertion failures\n    event AssertionFailed(string message);\n\n    // --------------------------------------------------------------------------------\n    // contracts under test\n    // --------------------------------------------------------------------------------\n\n    DInterest private dinterest =\n        DInterest(0x13d5Bf6416c98E81f667752Ee9591fAF8E98e029);\n    ERC20Mock private mockToken =\n        ERC20Mock(0xfFDF5B3243395e561f1b09aCAfB94cBD9e590a09);\n\n    // --------------------------------------------------------------------------------\n    // related to the generation of suitable maturation timestamps\n    // --------------------------------------------------------------------------------\n\n    // must be identical to `maxTimeDelay` in echidna config\n    uint256 private MAX_POSITIVE_TIME_DELAY = 7500;\n    // 25% chance of choosing a time in the past\n    uint256 private MAX_NEGATIVE_TIME_DELAY = 2500;\n    uint256 private TIME_DELAY_RANGE_LENGTH =\n        MAX_NEGATIVE_TIME_DELAY + MAX_POSITIVE_TIME_DELAY;\n\n    // returns a maturation timestamp equally distributed in the range\n    // block.timestamp - MAX_NEGATIVE_TIME_DELAY to block.timestamp + MAX_POSITIVE_TIME_DELAY\n    function randomMaturationTimestamp(uint256 seed)\n        private\n        view\n        returns (uint64)\n    {\n        uint256 offset = seed % TIME_DELAY_RANGE_LENGTH;\n        return uint64(block.timestamp - MAX_NEGATIVE_TIME_DELAY + offset);\n    }\n\n    // --------------------------------------------------------------------------------\n    // related to minting interest\n    // --------------------------------------------------------------------------------\n\n    uint256 private lastMintingOfInterest = 0;\n    ATokenMock private aTokenMock =\n        ATokenMock(0x246956d319b8a075D59A801f73309fB26e7AB9a2);\n\n    constructor() {\n        lastMintingOfInterest = block.timestamp;\n    }\n\n    function mintInterest() private {\n        aTokenMock.mintInterest(block.timestamp - lastMintingOfInterest);\n        lastMintingOfInterest = block.timestamp;\n    }\n\n    // --------------------------------------------------------------------------------\n    // remember state we need later.\n    // exposed as optimization tests via `echidna_` prefix.\n    // run with `--test-mode optimization` to verify\n    // that the system is reaching expected states.\n    // --------------------------------------------------------------------------------\n\n    function echidna_mintedAmount() external view returns (uint256) {\n        return mockToken.balanceOf(address(this));\n    }\n\n    function echidna_allowedAmount() external view returns (uint256) {\n        return mockToken.allowance(address(this), address(dinterest));\n    }\n\n    uint256 public echidna_interestAmount = 0;\n    uint64 public echidna_depositID = 0;\n\n    uint256 public echidna_depositedAmount = 0;\n\n    uint256 public echidna_matureWithdrawnAmount = 0;\n    uint256 public echidna_immatureWithdrawnAmount = 0;\n\n    uint256 public echidna_successfulWithdrawCount = 0;\n\n    // --------------------------------------------------------------------------------\n    // required, else `deposit` fails due to `this` not being able to receive the NFT\n    // --------------------------------------------------------------------------------\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4) {\n        return EchidnaDepositWithdrawTest.onERC721Received.selector;\n    }\n\n    // --------------------------------------------------------------------------------\n    // functions called by echidna\n    // --------------------------------------------------------------------------------\n\n    // mint some tokens so they can be approved\n    function mint(uint256 seed) external {\n        uint256 decimals = mockToken.decimals();\n        assert(decimals == 6);\n        uint256 exaScalingFactor = 18;\n        // limit amount to 1 exa exa mockToken so tests are not cluttered with overflow errors\n        // 18 * 3 = 54\n        uint256 amount = seed %\n            10**(decimals + exaScalingFactor + exaScalingFactor);\n        require(mockToken.balanceOf(address(this)) == 0);\n        mockToken.mint(address(this), amount);\n    }\n\n    // approve some assets so they can be deposited\n    function approveAll() external {\n        require(\n            mockToken.allowance(address(this), address(dinterest)) !=\n                mockToken.balanceOf(address(this))\n        );\n        mockToken.approve(\n            address(dinterest),\n            mockToken.balanceOf(address(this))\n        );\n    }\n\n    function deposit(uint256 amount, uint256 seed) external {\n        // ensure we're all caught up\n        mintInterest();\n\n        // we get `BAD_INTEREST` if the amount is too low\n        require(amount >= 10**mockToken.decimals());\n        assert(10**mockToken.decimals() == 1000000);\n        uint64 maturationTimestamp = randomMaturationTimestamp(seed);\n        uint256 balanceBefore = mockToken.balanceOf(address(this));\n        uint256 allowanceBefore = mockToken.allowance(\n            address(this),\n            address(dinterest)\n        );\n\n        // --------------------------------------------------------------------------------\n        // detect success or failure\n        // --------------------------------------------------------------------------------\n\n        bool success = true;\n        emit LogUint256(\n            \"dinterest.MinDepositAmount()\",\n            dinterest.MinDepositAmount()\n        );\n        try dinterest.deposit(amount, maturationTimestamp) returns (\n            uint64 depositID,\n            uint256 interestAmount\n        ) {\n            emit Log(\"deposit success\");\n            uint256 balanceAfter = mockToken.balanceOf(address(this));\n            uint256 transferredAmount = balanceBefore - balanceAfter;\n            if (amount != transferredAmount) {\n                emit AssertionFailed(\"deposit must transfer exactly `amount`\");\n            }\n            if (depositID == 0) {\n                emit AssertionFailed(\"deposit must return non-zero deposit ID\");\n            }\n            if (interestAmount == 0) {\n                emit AssertionFailed(\"deposit must return non-zero interest\");\n            }\n            echidna_depositID = depositID;\n            echidna_depositedAmount = amount;\n            echidna_interestAmount = interestAmount;\n            echidna_matureWithdrawnAmount = 0;\n            echidna_immatureWithdrawnAmount = 0;\n        } catch {\n            success = false;\n        }\n\n        // --------------------------------------------------------------------------------\n        // detect unexpected successes and stop on expected failures\n        // --------------------------------------------------------------------------------\n\n        if (amount > balanceBefore) {\n            if (success) {\n                emit AssertionFailed(\n                    \"deposit must revert if sender doesn't own at least `amount`\"\n                );\n            } else {\n                return;\n            }\n        }\n\n        if (amount > allowanceBefore) {\n            if (success) {\n                emit AssertionFailed(\n                    \"deposit must revert if sender hasn't approved at least `amount`\"\n                );\n                assert(false);\n            } else {\n                return;\n            }\n        }\n\n        if (amount < dinterest.MinDepositAmount()) {\n            if (success) {\n                emit AssertionFailed(\n                    \"deposit must revert if `amount` is below the minimum\"\n                );\n            } else {\n                return;\n            }\n        }\n\n        if (maturationTimestamp <= block.timestamp) {\n            if (success) {\n                emit AssertionFailed(\n                    \"deposit must revert if `maturationTimestamp` is not in the future\"\n                );\n            } else {\n                return;\n            }\n        }\n\n        uint256 depositPeriod = maturationTimestamp - block.timestamp;\n        if (depositPeriod > dinterest.MaxDepositPeriod()) {\n            if (success) {\n                emit AssertionFailed(\n                    \"deposit must revert if deposit period is above maximum\"\n                );\n            } else {\n                return;\n            }\n        }\n\n        uint256 interest = dinterest.calculateInterestAmount(\n            amount,\n            depositPeriod\n        );\n        if (interest == 0) {\n            if (success) {\n                emit AssertionFailed(\"deposit must revert if interest is 0\");\n            } else {\n                return;\n            }\n        }\n\n        // --------------------------------------------------------------------------------\n        // detect unexpected failures\n        // --------------------------------------------------------------------------------\n\n        if (!success) {\n            emit AssertionFailed(\n                \"deposit must not revert if all preconditions are met\"\n            );\n        }\n    }\n\n    function withdraw(uint256 amount, bool early) external {\n        // ensure we're all caught up\n        mintInterest();\n\n        // --------------------------------------------------------------------------------\n        // detect success or failure\n        // --------------------------------------------------------------------------------\n\n        uint256 balanceBefore = mockToken.balanceOf(address(this));\n        uint256 depositAmountPlusInterest = 0;\n        // the check is required because getDeposit fails with integer underflow otherwise\n        if (dinterest.depositsLength() != 0) {\n            depositAmountPlusInterest = dinterest\n                .getDeposit(echidna_depositID)\n                .virtualTokenTotalSupply;\n        }\n        emit LogUint256(\"depositAmountPlusInterest\", depositAmountPlusInterest);\n\n        bool success = true;\n        try dinterest.withdraw(echidna_depositID, amount, early) returns (\n            uint256 returnedAmount\n        ) {\n            emit Log(\"withdraw success\");\n            uint256 balanceAfter = mockToken.balanceOf(address(this));\n            uint256 transferredAmount = balanceAfter - balanceBefore;\n            if (returnedAmount != transferredAmount) {\n                emit AssertionFailed(\n                    \"withdraw must return amount that it transferred\"\n                );\n            }\n\n            if (transferredAmount > depositAmountPlusInterest) {\n                emit AssertionFailed(\n                    \"withdraw must not transfer more than the deposited amount plus interest\"\n                );\n            }\n            // TODO withdraw must transfer expected amount\n            // uint256 expectedWithdrawnAmount =\n            // TODO one should get exactly the promised interest\n\n            if (early) {\n                echidna_immatureWithdrawnAmount += returnedAmount;\n            } else {\n                echidna_matureWithdrawnAmount += returnedAmount;\n            }\n        } catch {\n            success = false;\n        }\n\n        // --------------------------------------------------------------------------------\n        // detect unexpected successes and stop on expected failures\n        // --------------------------------------------------------------------------------\n\n        if (echidna_depositID == 0) {\n            if (success) {\n                emit AssertionFailed(\n                    \"withdraw must revert if no deposit with `depositID` exists\"\n                );\n            } else {\n                return;\n            }\n        }\n\n        if (amount == 0) {\n            if (success) {\n                emit AssertionFailed(\n                    \"withdraw must revert if `amount` is zero\"\n                );\n            } else {\n                return;\n            }\n        }\n\n        uint64 maturationTimestamp = dinterest\n            .getDeposit(echidna_depositID)\n            .maturationTimestamp;\n        bool isActuallyEarly = block.timestamp < maturationTimestamp;\n        if (early != isActuallyEarly) {\n            if (success) {\n                emit AssertionFailed(\n                    \"withdraw must revert if `early` doesn't match deposit state\"\n                );\n            } else {\n                return;\n            }\n        }\n\n        // --------------------------------------------------------------------------------\n        // detect unexpected failures\n        // --------------------------------------------------------------------------------\n\n        if (!success) {\n            emit AssertionFailed(\n                \"withdraw must not revert if all preconditions are met\"\n            );\n        }\n\n        echidna_successfulWithdrawCount += 1;\n    }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20(\"\", \"\") {\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    function _beforeTokenTransfer(\n        address, /*from*/\n        address, /*to*/\n        uint256 amount\n    ) internal pure override {\n        require(amount > 0, \"ERC20Mock: amount 0\");\n    }\n}\n"
    },
    "contracts/mocks/ComptrollerMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n// interfaces\nimport {ERC20Mock} from \"./ERC20Mock.sol\";\n\ncontract ComptrollerMock {\n    uint256 public constant CLAIM_AMOUNT = 10**18;\n    ERC20Mock public comp;\n\n    constructor(address _comp) {\n        comp = ERC20Mock(_comp);\n    }\n\n    function claimComp(address holder) external {\n        comp.mint(holder, CLAIM_AMOUNT);\n    }\n\n    function getCompAddress() external view returns (address) {\n        return address(comp);\n    }\n}\n"
    },
    "contracts/mocks/RegistryMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n// interfaces\nimport {ERC20Mock} from \"./ERC20Mock.sol\";\n\ncontract RegistryMock {\n    ERC20Mock public comp;\n\n    constructor(address _comp) {\n        comp = ERC20Mock(_comp);\n    }\n}\n"
    },
    "contracts/mocks/BComptrollerMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n// interfaces\nimport {RegistryMock} from \"./RegistryMock.sol\";\n\ncontract BComptrollerMock {\n    uint256 public constant CLAIM_AMOUNT = 10**18;\n    RegistryMock public registry;\n\n    constructor(address _registry) {\n        registry = RegistryMock(_registry);\n    }\n\n    function claimComp(address holder) external {\n        registry.comp().mint(holder, CLAIM_AMOUNT);\n    }\n}\n"
    },
    "contracts/mocks/AaveMiningMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n// interfaces\nimport {ERC20Mock} from \"./ERC20Mock.sol\";\n\ncontract AaveMiningMock {\n    uint256 public constant CLAIM_AMOUNT = 10**18;\n    ERC20Mock public aave;\n\n    constructor(address _aave) {\n        aave = ERC20Mock(_aave);\n    }\n\n    function claimRewards(\n        address[] calldata, /*assets*/\n        uint256, /*amount*/\n        address to\n    ) external returns (uint256) {\n        aave.mint(to, CLAIM_AMOUNT);\n        return CLAIM_AMOUNT;\n    }\n}\n"
    },
    "contracts/mocks/CERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n    Modified from https://github.com/bugduino/idle-contracts/blob/master/contracts/mocks/cDAIMock.sol\n    at commit b85dafa8e55e053cb2d403fc4b28cfe86f2116d4\n\n    Original license:\n    Copyright 2020 Idle Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n */\n\npragma solidity 0.8.4;\n\n// interfaces\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract CERC20Mock is ERC20 {\n    address public dai;\n\n    uint256 internal _supplyRate;\n    uint256 internal _exchangeRate;\n\n    constructor(address _dai) ERC20(\"cDAI\", \"cDAI\") {\n        dai = _dai;\n        uint256 daiDecimals = ERC20(_dai).decimals();\n        _exchangeRate = 2 * (10**(daiDecimals + 8)); // 1 cDAI = 0.02 DAI\n        _supplyRate = 45290900000; // 10% supply rate per year\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n\n    function mint(uint256 amount) external returns (uint256) {\n        require(\n            ERC20(dai).transferFrom(msg.sender, address(this), amount),\n            \"Error during transferFrom\"\n        ); // 1 DAI\n        _mint(msg.sender, (amount * 10**18) / _exchangeRate);\n        return 0;\n    }\n\n    function redeemUnderlying(uint256 amount) external returns (uint256) {\n        _burn(msg.sender, (amount * 10**18) / _exchangeRate);\n        require(\n            ERC20(dai).transfer(msg.sender, amount),\n            \"Error during transfer\"\n        ); // 1 DAI\n        return 0;\n    }\n\n    function exchangeRateStored() external view returns (uint256) {\n        return _exchangeRate;\n    }\n\n    function exchangeRateCurrent() external view returns (uint256) {\n        return _exchangeRate;\n    }\n\n    function _setExchangeRateStored(uint256 _rate) external {\n        _exchangeRate = _rate;\n    }\n\n    function supplyRatePerBlock() external view returns (uint256) {\n        return _supplyRate;\n    }\n\n    function _setSupplyRatePerBlock(uint256 _rate) external {\n        _supplyRate = _rate;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/libs/OZProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract OZProxy is TransparentUpgradeableProxy {\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/models/interest/LinearDecayInterestModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {IInterestModel} from \"./IInterestModel.sol\";\n\ncontract LinearDecayInterestModel is IInterestModel {\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant PRECISION = 10**18;\n    uint256 public immutable multiplierIntercept;\n    uint256 public immutable multiplierSlope;\n\n    constructor(uint256 _multiplierIntercept, uint256 _multiplierSlope) {\n        multiplierIntercept = _multiplierIntercept;\n        multiplierSlope = _multiplierSlope;\n    }\n\n    function getIRMultiplier(uint256 depositPeriodInSeconds)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 multiplierDecrease = depositPeriodInSeconds * multiplierSlope;\n        if (multiplierDecrease >= multiplierIntercept) {\n            return 0;\n        } else {\n            return multiplierIntercept - multiplierDecrease;\n        }\n    }\n\n    function calculateInterestAmount(\n        uint256 depositAmount,\n        uint256 depositPeriodInSeconds,\n        uint256 moneyMarketInterestRatePerSecond,\n        bool, /*surplusIsNegative*/\n        uint256 /*surplusAmount*/\n    ) external view override returns (uint256 interestAmount) {\n        // interestAmount = depositAmount * (2 ** (moneyMarketInterestRatePerSecond * depositPeriodInSeconds) - 1) * IRMultiplier\n        interestAmount = depositAmount\n            .mul(\n                (moneyMarketInterestRatePerSecond * depositPeriodInSeconds)\n                    .exp2() - PRECISION\n            )\n            .mul(getIRMultiplier(depositPeriodInSeconds));\n    }\n}\n"
    },
    "contracts/DInterestLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport {DInterest} from \"./DInterest.sol\";\n\ncontract DInterestLens {\n    using PRBMathUD60x18 for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n    /**\n        @dev used for sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex\n     */\n    uint256 internal constant EXTRA_PRECISION = 10**27;\n    /**\n        @dev used for funding.principalPerToken\n     */\n    uint256 internal constant ULTRA_PRECISION = 2**128;\n\n    /**\n        @notice Computes the amount of stablecoins that can be withdrawn\n                by burning `virtualTokenAmount` virtual tokens from the deposit\n                with ID `depositID` at time `timestamp`.\n        @dev The queried timestamp should >= the deposit's lastTopupTimestamp, since\n             the information before this time is forgotten.\n        @param pool The DInterest pool\n        @param depositID The ID of the deposit\n        @param virtualTokenAmount The amount of virtual tokens to burn\n        @return withdrawableAmount The amount of stablecoins (after fee) that can be withdrawn\n        @return feeAmount The amount of fees that will be given to the beneficiary\n     */\n    function withdrawableAmountOfDeposit(\n        DInterest pool,\n        uint64 depositID,\n        uint256 virtualTokenAmount\n    ) external view returns (uint256 withdrawableAmount, uint256 feeAmount) {\n        // Verify input\n        DInterest.Deposit memory depositEntry = pool.getDeposit(depositID);\n        if (virtualTokenAmount == 0) {\n            return (0, 0);\n        } else {\n            if (virtualTokenAmount > depositEntry.virtualTokenTotalSupply) {\n                virtualTokenAmount = depositEntry.virtualTokenTotalSupply;\n            }\n        }\n\n        // Compute token amounts\n        bool early = block.timestamp < depositEntry.maturationTimestamp;\n        uint256 depositAmount = virtualTokenAmount.div(\n            depositEntry.interestRate + PRECISION\n        );\n        uint256 interestAmount = early ? 0 : virtualTokenAmount - depositAmount;\n        withdrawableAmount = depositAmount + interestAmount;\n\n        if (early) {\n            // apply fee to withdrawAmount\n            uint256 earlyWithdrawFee = pool\n                .feeModel()\n                .getEarlyWithdrawFeeAmount(\n                    address(pool),\n                    depositID,\n                    withdrawableAmount\n                );\n            feeAmount = earlyWithdrawFee;\n            withdrawableAmount -= earlyWithdrawFee;\n        } else {\n            feeAmount = depositAmount.mul(depositEntry.feeRate);\n        }\n    }\n\n    /**\n        @notice Computes the floating-rate interest accrued in the floating-rate\n                bond with ID `fundingID`.\n        @param pool The DInterest pool\n        @param fundingID The ID of the floating-rate bond\n        @return fundingInterestAmount The interest accrued, in stablecoins\n     */\n    function accruedInterestOfFunding(DInterest pool, uint64 fundingID)\n        external\n        returns (uint256 fundingInterestAmount)\n    {\n        DInterest.Funding memory f = pool.getFunding(fundingID);\n        uint256 fundingTokenTotalSupply = pool.fundingMultitoken().totalSupply(\n            fundingID\n        );\n        uint256 recordedFundedPrincipalAmount = (fundingTokenTotalSupply *\n            f.principalPerToken) / ULTRA_PRECISION;\n        uint256 recordedMoneyMarketIncomeIndex = f\n            .recordedMoneyMarketIncomeIndex;\n        uint256 currentMoneyMarketIncomeIndex = pool\n            .moneyMarket()\n            .incomeIndex();\n        require(currentMoneyMarketIncomeIndex > 0, \"DInterest: BAD_INDEX\");\n\n        // Compute interest to funders\n        fundingInterestAmount =\n            (recordedFundedPrincipalAmount * currentMoneyMarketIncomeIndex) /\n            recordedMoneyMarketIncomeIndex -\n            recordedFundedPrincipalAmount;\n    }\n\n    /**\n        @notice A floating-rate bond is no longer active if its principalPerToken becomes 0,\n                which occurs when the corresponding deposit is completely withdrawn. When\n                such a deposit is topped up, a new Funding struct and floating-rate bond will\n                be created.\n        @param pool The DInterest pool\n        @param fundingID The ID of the floating-rate bond\n        @return True if the funding is active, false otherwise\n     */\n    function fundingIsActive(DInterest pool, uint64 fundingID)\n        external\n        view\n        returns (bool)\n    {\n        return pool.getFunding(fundingID).principalPerToken > 0;\n    }\n\n    /**\n        @notice Computes the floating interest amount owed to deficit funders, which will be paid out\n                when a funded deposit is withdrawn.\n                Formula: \\sum_i recordedFundedPrincipalAmount_i * (incomeIndex / recordedMoneyMarketIncomeIndex_i - 1)\n                = incomeIndex * (\\sum_i recordedFundedPrincipalAmount_i / recordedMoneyMarketIncomeIndex_i)\n                - \\sum_i recordedFundedPrincipalAmount_i\n                where i refers to a funding\n        @param pool The DInterest pool\n        @return interestOwed The floating-rate interest accrued to all floating-rate bond holders\n     */\n    function totalInterestOwedToFunders(DInterest pool)\n        public\n        virtual\n        returns (uint256 interestOwed)\n    {\n        uint256 currentValue = (pool.moneyMarket().incomeIndex() *\n            pool.sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex()) /\n            EXTRA_PRECISION;\n        uint256 initialValue = pool.totalFundedPrincipalAmount();\n        if (currentValue < initialValue) {\n            return 0;\n        }\n        return currentValue - initialValue;\n    }\n\n    /**\n        @notice Computes the surplus of a deposit, which is the raw surplus of the\n                unfunded part of the deposit. If the deposit is not funded, this will\n                return the same value as {rawSurplusOfDeposit}.\n        @param depositID The ID of the deposit\n        @return isNegative True if the surplus is negative, false otherwise\n        @return surplusAmount The absolute value of the surplus, in stablecoins\n     */\n    function surplusOfDeposit(DInterest pool, uint64 depositID)\n        public\n        virtual\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        (isNegative, surplusAmount) = rawSurplusOfDeposit(pool, depositID);\n\n        DInterest.Deposit memory depositEntry = pool.getDeposit(depositID);\n        if (depositEntry.fundingID != 0) {\n            uint256 totalPrincipal = _depositVirtualTokenToPrincipal(\n                depositEntry,\n                depositEntry.virtualTokenTotalSupply\n            );\n            uint256 principalPerToken = pool\n                .getFunding(depositEntry.fundingID)\n                .principalPerToken;\n            uint256 unfundedPrincipalAmount = totalPrincipal -\n                (pool.fundingMultitoken().totalSupply(depositEntry.fundingID) *\n                    principalPerToken) /\n                ULTRA_PRECISION;\n            surplusAmount =\n                (surplusAmount * unfundedPrincipalAmount) /\n                totalPrincipal;\n        }\n    }\n\n    /**\n        @notice Computes the raw surplus of a deposit, which is the current value of the\n                deposit in the money market minus the amount owed (deposit + interest + fee).\n                The deposit's funding status is not considered here, meaning even if a deposit's\n                fixed-rate interest is fully funded, it likely will still have a non-zero surplus.\n        @param depositID The ID of the deposit\n        @return isNegative True if the surplus is negative, false otherwise\n        @return surplusAmount The absolute value of the surplus, in stablecoins\n     */\n    function rawSurplusOfDeposit(DInterest pool, uint64 depositID)\n        public\n        virtual\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        return\n            _rawSurplusOfDeposit(\n                pool,\n                depositID,\n                pool.moneyMarket().incomeIndex()\n            );\n    }\n\n    /**\n        @dev See {rawSurplusOfDeposit}\n        @param currentMoneyMarketIncomeIndex The moneyMarket's current incomeIndex\n     */\n    function _rawSurplusOfDeposit(\n        DInterest pool,\n        uint64 depositID,\n        uint256 currentMoneyMarketIncomeIndex\n    ) internal virtual returns (bool isNegative, uint256 surplusAmount) {\n        DInterest.Deposit memory depositEntry = pool.getDeposit(depositID);\n        uint256 depositAmount = depositEntry.virtualTokenTotalSupply.div(\n            depositEntry.interestRate + PRECISION\n        );\n        uint256 interestAmount = depositEntry.virtualTokenTotalSupply -\n            depositAmount;\n        uint256 feeAmount = depositAmount.mul(depositEntry.feeRate);\n        uint256 currentDepositValue = (depositAmount *\n            currentMoneyMarketIncomeIndex) /\n            depositEntry.averageRecordedIncomeIndex;\n        uint256 owed = depositAmount + interestAmount + feeAmount;\n        if (currentDepositValue >= owed) {\n            // Locked value more than owed deposits, positive surplus\n            isNegative = false;\n            surplusAmount = currentDepositValue - owed;\n        } else {\n            // Locked value less than owed deposits, negative surplus\n            isNegative = true;\n            surplusAmount = owed - currentDepositValue;\n        }\n    }\n\n    /**\n        @dev Converts a virtual token value into the corresponding principal value.\n             Principal refers to deposit + full interest + fee.\n        @param depositEntry The deposit struct\n        @param virtualTokenAmount The virtual token value\n        @return The corresponding principal value\n     */\n    function _depositVirtualTokenToPrincipal(\n        DInterest.Deposit memory depositEntry,\n        uint256 virtualTokenAmount\n    ) internal pure virtual returns (uint256) {\n        uint256 depositInterestRate = depositEntry.interestRate;\n        return\n            virtualTokenAmount.div(depositInterestRate + PRECISION).mul(\n                depositInterestRate + depositEntry.feeRate + PRECISION\n            );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}