{
  "language": "Solidity",
  "sources": {
    "contracts/DInterest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"./libs/SafeERC20.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {\n    AddressUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    MulticallUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\";\nimport {MoneyMarket} from \"./moneymarkets/MoneyMarket.sol\";\nimport {IFeeModel} from \"./models/fee/IFeeModel.sol\";\nimport {IInterestModel} from \"./models/interest/IInterestModel.sol\";\nimport {NFT} from \"./tokens/NFT.sol\";\nimport {FundingMultitoken} from \"./tokens/FundingMultitoken.sol\";\nimport {MPHMinter} from \"./rewards/MPHMinter.sol\";\nimport {IInterestOracle} from \"./models/interest-oracle/IInterestOracle.sol\";\nimport {DecMath} from \"./libs/DecMath.sol\";\nimport {Rescuable} from \"./libs/Rescuable.sol\";\nimport {Sponsorable} from \"./libs/Sponsorable.sol\";\nimport {console} from \"hardhat/console.sol\";\n\n/**\n    @title DeLorean Interest -- It's coming back from the future!\n    @author Zefram Lou\n    @notice The main pool contract for fixed-rate deposits\n    @dev The contract to interact with for most actions\n */\ncontract DInterest is\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    Rescuable,\n    MulticallUpgradeable,\n    Sponsorable\n{\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n    using DecMath for uint256;\n\n    // Constants\n    uint256 internal constant PRECISION = 10**18;\n    /**\n        @dev used for sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex\n     */\n    uint256 internal constant EXTRA_PRECISION = 10**27;\n    /**\n        @dev used for funding.principalPerToken\n     */\n    uint256 internal constant ULTRA_PRECISION = 2**128;\n    /**\n        @dev Specifies the threshold for paying out funder interests\n     */\n    uint256 internal constant FUNDER_PAYOUT_THRESHOLD_DIVISOR = 10**10;\n\n    // User deposit data\n    // Each deposit has an ID used in the depositNFT, which is equal to its index in `deposits` plus 1\n    struct Deposit {\n        uint256 virtualTokenTotalSupply; // depositAmount + interestAmount, behaves like a zero coupon bond\n        uint256 interestRate; // interestAmount = interestRate * depositAmount\n        uint256 feeRate; // feeAmount = feeRate * depositAmount\n        uint256 averageRecordedIncomeIndex; // Average income index at time of deposit, used for computing deposit surplus\n        uint64 maturationTimestamp; // Unix timestamp after which the deposit may be withdrawn, in seconds\n        uint64 fundingID; // The ID of the associated Funding struct. 0 if not funded.\n    }\n    Deposit[] internal deposits;\n\n    // Funding data\n    // Each funding has an ID used in the fundingMultitoken, which is equal to its index in `fundingList` plus 1\n    struct Funding {\n        uint64 depositID; // The ID of the associated Deposit struct.\n        uint64 lastInterestPayoutTimestamp; // Unix timestamp of the most recent interest payout, in seconds\n        uint256 recordedMoneyMarketIncomeIndex; // the income index at the last update (creation or withdrawal)\n        uint256 principalPerToken; // The amount of stablecoins that's earning interest for you per funding token you own. Scaled to 18 decimals regardless of stablecoin decimals.\n    }\n    Funding[] internal fundingList;\n    // the sum of (recordedFundedPrincipalAmount / recordedMoneyMarketIncomeIndex) of all fundings\n    uint256 public sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex;\n\n    // Params\n    /**\n        @dev Maximum deposit period, in seconds\n     */\n    uint64 public MaxDepositPeriod;\n    /**\n        @dev Minimum deposit amount, in stablecoins\n     */\n    uint256 public MinDepositAmount;\n\n    // Global variables\n    uint256 public totalDeposit;\n    uint256 public totalInterestOwed;\n    uint256 public totalFeeOwed;\n    uint256 public totalFundedPrincipalAmount;\n\n    // External smart contracts\n    MoneyMarket public moneyMarket;\n    ERC20 public stablecoin;\n    IFeeModel public feeModel;\n    IInterestModel public interestModel;\n    IInterestOracle public interestOracle;\n    NFT public depositNFT;\n    FundingMultitoken public fundingMultitoken;\n    MPHMinter public mphMinter;\n\n    // Extra params\n    /**\n        @dev The maximum amount of deposit in the pool. Set to 0 to disable the cap.\n     */\n    uint256 public GlobalDepositCap;\n\n    // Events\n    event EDeposit(\n        address indexed sender,\n        uint256 indexed depositID,\n        uint256 depositAmount,\n        uint256 interestAmount,\n        uint256 feeAmount,\n        uint64 maturationTimestamp\n    );\n    event ETopupDeposit(\n        address indexed sender,\n        uint64 indexed depositID,\n        uint256 depositAmount,\n        uint256 interestAmount,\n        uint256 feeAmount\n    );\n    event ERolloverDeposit(\n        address indexed sender,\n        uint64 indexed depositID,\n        uint64 indexed newDepositID\n    );\n    event EWithdraw(\n        address indexed sender,\n        uint256 indexed depositID,\n        bool indexed early,\n        uint256 virtualTokenAmount,\n        uint256 feeAmount\n    );\n    event EFund(\n        address indexed sender,\n        uint64 indexed fundingID,\n        uint256 fundAmount,\n        uint256 tokenAmount\n    );\n    event EPayFundingInterest(\n        uint256 indexed fundingID,\n        uint256 interestAmount,\n        uint256 refundAmount\n    );\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n    event ESetParamUint(\n        address indexed sender,\n        string indexed paramName,\n        uint256 newValue\n    );\n\n    function __DInterest_init(\n        uint64 _MaxDepositPeriod,\n        uint256 _MinDepositAmount,\n        address _moneyMarket,\n        address _stablecoin,\n        address _feeModel,\n        address _interestModel,\n        address _interestOracle,\n        address _depositNFT,\n        address _fundingMultitoken,\n        address _mphMinter\n    ) internal initializer {\n        __ReentrancyGuard_init();\n        __Ownable_init();\n\n        moneyMarket = MoneyMarket(_moneyMarket);\n        stablecoin = ERC20(_stablecoin);\n        feeModel = IFeeModel(_feeModel);\n        interestModel = IInterestModel(_interestModel);\n        interestOracle = IInterestOracle(_interestOracle);\n        depositNFT = NFT(_depositNFT);\n        fundingMultitoken = FundingMultitoken(_fundingMultitoken);\n        mphMinter = MPHMinter(_mphMinter);\n        MaxDepositPeriod = _MaxDepositPeriod;\n        MinDepositAmount = _MinDepositAmount;\n    }\n\n    /**\n        @param _MaxDepositPeriod The maximum deposit period, in seconds\n        @param _MinDepositAmount The minimum deposit amount, in stablecoins\n        @param _moneyMarket Address of MoneyMarket that's used for generating interest (owner must be set to this DInterest contract)\n        @param _stablecoin Address of the stablecoin used to store funds\n        @param _feeModel Address of the FeeModel contract that determines how fees are charged\n        @param _interestModel Address of the InterestModel contract that determines how much interest to offer\n        @param _interestOracle Address of the InterestOracle contract that provides the average interest rate\n        @param _depositNFT Address of the NFT representing ownership of deposits (owner must be set to this DInterest contract)\n        @param _fundingMultitoken Address of the ERC1155 multitoken representing ownership of fundings (this DInterest contract must have the minter-burner role)\n        @param _mphMinter Address of the contract for handling minting MPH to users\n     */\n    function initialize(\n        uint64 _MaxDepositPeriod,\n        uint256 _MinDepositAmount,\n        address _moneyMarket,\n        address _stablecoin,\n        address _feeModel,\n        address _interestModel,\n        address _interestOracle,\n        address _depositNFT,\n        address _fundingMultitoken,\n        address _mphMinter\n    ) external virtual initializer {\n        __DInterest_init(\n            _MaxDepositPeriod,\n            _MinDepositAmount,\n            _moneyMarket,\n            _stablecoin,\n            _feeModel,\n            _interestModel,\n            _interestOracle,\n            _depositNFT,\n            _fundingMultitoken,\n            _mphMinter\n        );\n    }\n\n    /**\n        Public action functions\n     */\n\n    /**\n        @notice Create a deposit using `depositAmount` stablecoin that matures at timestamp `maturationTimestamp`.\n        @dev The ERC-721 NFT representing deposit ownership is given to msg.sender\n        @param depositAmount The amount of deposit, in stablecoin\n        @param maturationTimestamp The Unix timestamp of maturation, in seconds\n        @return depositID The ID of the created deposit\n        @return interestAmount The amount of fixed-rate interest\n     */\n    function deposit(uint256 depositAmount, uint64 maturationTimestamp)\n        external\n        nonReentrant\n        returns (uint64 depositID, uint256 interestAmount)\n    {\n        return _deposit(msg.sender, depositAmount, maturationTimestamp, false);\n    }\n\n    /**\n        @notice Add `depositAmount` stablecoin to the existing deposit with ID `depositID`.\n        @dev The interest rate for the topped up funds will be the current oracle rate.\n        @param depositID The deposit to top up\n        @param depositAmount The amount to top up, in stablecoin\n        @return interestAmount The amount of interest that will be earned by the topped up funds at maturation\n     */\n    function topupDeposit(uint64 depositID, uint256 depositAmount)\n        external\n        nonReentrant\n        returns (uint256 interestAmount)\n    {\n        return _topupDeposit(msg.sender, depositID, depositAmount);\n    }\n\n    /**\n        @notice Withdraw all funds from deposit with ID `depositID` and use them\n                to create a new deposit that matures at time `maturationTimestamp`\n        @param depositID The deposit to roll over\n        @param maturationTimestamp The Unix timestamp of the new deposit, in seconds\n        @return newDepositID The ID of the new deposit\n     */\n    function rolloverDeposit(uint64 depositID, uint64 maturationTimestamp)\n        external\n        nonReentrant\n        returns (uint256 newDepositID, uint256 interestAmount)\n    {\n        return _rolloverDeposit(msg.sender, depositID, maturationTimestamp);\n    }\n\n    /**\n        @notice Withdraws funds from the deposit with ID `depositID`.\n        @dev Virtual tokens behave like zero coupon bonds, after maturation withdrawing 1 virtual token\n             yields 1 stablecoin. The total supply is given by deposit.virtualTokenTotalSupply\n        @param depositID the deposit to withdraw from\n        @param virtualTokenAmount the amount of virtual tokens to withdraw\n        @param early True if intend to withdraw before maturation, false otherwise\n        @return withdrawnStablecoinAmount the amount of stablecoins withdrawn\n     */\n    function withdraw(\n        uint64 depositID,\n        uint256 virtualTokenAmount,\n        bool early\n    ) external nonReentrant returns (uint256 withdrawnStablecoinAmount) {\n        return\n            _withdraw(msg.sender, depositID, virtualTokenAmount, early, false);\n    }\n\n    /**\n        @notice Funds the fixed-rate interest of the deposit with ID `depositID`.\n                In exchange, the funder receives the future floating-rate interest\n                generated by the portion of the deposit whose interest was funded.\n        @dev The sender receives ERC-1155 multitokens (fundingMultitoken) representing\n             their floating-rate bonds.\n        @param depositID The deposit whose fixed-rate interest will be funded\n        @param fundAmount The amount of fixed-rate interest to fund.\n                          If it exceeds surplusOfDeposit(depositID), it will be set to\n                          the surplus value instead.\n        @param fundingID The ID of the fundingMultitoken the sender received\n     */\n    function fund(uint64 depositID, uint256 fundAmount)\n        external\n        nonReentrant\n        returns (uint64 fundingID)\n    {\n        return _fund(msg.sender, depositID, fundAmount);\n    }\n\n    /**\n        @notice Distributes the floating-rate interest accrued by a deposit to the\n                floating-rate bond holders.\n        @param fundingID The ID of the floating-rate bond\n        @return interestAmount The amount of interest distributed, in stablecoins\n     */\n    function payInterestToFunders(uint64 fundingID)\n        external\n        nonReentrant\n        returns (uint256 interestAmount)\n    {\n        return _payInterestToFunders(fundingID, moneyMarket.incomeIndex());\n    }\n\n    /**\n        Sponsored action functions\n     */\n\n    function sponsoredDeposit(\n        uint256 depositAmount,\n        uint64 maturationTimestamp,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredDeposit.selector,\n            abi.encode(depositAmount, maturationTimestamp)\n        )\n        returns (uint64 depositID, uint256 interestAmount)\n    {\n        return\n            _deposit(\n                sponsorship.sender,\n                depositAmount,\n                maturationTimestamp,\n                false\n            );\n    }\n\n    function sponsoredTopupDeposit(\n        uint64 depositID,\n        uint256 depositAmount,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredTopupDeposit.selector,\n            abi.encode(depositID, depositAmount)\n        )\n        returns (uint256 interestAmount)\n    {\n        return _topupDeposit(sponsorship.sender, depositID, depositAmount);\n    }\n\n    function sponsoredRolloverDeposit(\n        uint64 depositID,\n        uint64 maturationTimestamp,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredRolloverDeposit.selector,\n            abi.encode(depositID, maturationTimestamp)\n        )\n        returns (uint256 newDepositID, uint256 interestAmount)\n    {\n        return\n            _rolloverDeposit(\n                sponsorship.sender,\n                depositID,\n                maturationTimestamp\n            );\n    }\n\n    function sponsoredWithdraw(\n        uint64 depositID,\n        uint256 virtualTokenAmount,\n        bool early,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredWithdraw.selector,\n            abi.encode(depositID, virtualTokenAmount, early)\n        )\n        returns (uint256 withdrawnStablecoinAmount)\n    {\n        return\n            _withdraw(\n                sponsorship.sender,\n                depositID,\n                virtualTokenAmount,\n                early,\n                false\n            );\n    }\n\n    function sponsoredFund(\n        uint64 depositID,\n        uint256 fundAmount,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredFund.selector,\n            abi.encode(depositID, fundAmount)\n        )\n        returns (uint64 fundingID)\n    {\n        return _fund(sponsorship.sender, depositID, fundAmount);\n    }\n\n    function sponsoredPayInterestToFunders(\n        uint64 fundingID,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredPayInterestToFunders.selector,\n            abi.encode(fundingID)\n        )\n        returns (uint256 interestAmount)\n    {\n        return _payInterestToFunders(fundingID, moneyMarket.incomeIndex());\n    }\n\n    /**\n        Public getter functions\n     */\n\n    /**\n        @notice Computes the amount of fixed-rate interest (before fees) that\n                will be given to a deposit of `depositAmount` stablecoins that\n                matures in `depositPeriodInSeconds` seconds.\n        @param depositAmount The deposit amount, in stablecoins\n        @param depositPeriodInSeconds The deposit period, in seconds\n        @return interestAmount The amount of fixed-rate interest (before fees)\n     */\n    function calculateInterestAmount(\n        uint256 depositAmount,\n        uint256 depositPeriodInSeconds\n    ) public virtual returns (uint256 interestAmount) {\n        (, uint256 moneyMarketInterestRatePerSecond) =\n            interestOracle.updateAndQuery();\n        (bool surplusIsNegative, uint256 surplusAmount) = surplus();\n\n        return\n            interestModel.calculateInterestAmount(\n                depositAmount,\n                depositPeriodInSeconds,\n                moneyMarketInterestRatePerSecond,\n                surplusIsNegative,\n                surplusAmount\n            );\n    }\n\n    /**\n        @notice Computes the pool's overall surplus, which is the value of its holdings\n                in the `moneyMarket` minus the amount owed to depositors, funders, and\n                the fee beneficiary.\n        @return isNegative True if the surplus is negative, false otherwise\n        @return surplusAmount The absolute value of the surplus, in stablecoins\n     */\n    function surplus()\n        public\n        virtual\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        return _surplus(moneyMarket.incomeIndex());\n    }\n\n    /**\n        @notice Computes the raw surplus of a deposit, which is the current value of the\n                deposit in the money market minus the amount owed (deposit + interest + fee).\n                The deposit's funding status is not considered here, meaning even if a deposit's\n                fixed-rate interest is fully funded, it likely will still have a non-zero surplus.\n        @param depositID The ID of the deposit\n        @return isNegative True if the surplus is negative, false otherwise\n        @return surplusAmount The absolute value of the surplus, in stablecoins\n     */\n    function rawSurplusOfDeposit(uint64 depositID)\n        public\n        virtual\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        return _rawSurplusOfDeposit(depositID, moneyMarket.incomeIndex());\n    }\n\n    /**\n        @notice Returns the total number of deposits.\n        @return deposits.length\n     */\n    function depositsLength() external view returns (uint256) {\n        return deposits.length;\n    }\n\n    /**\n        @notice Returns the total number of floating-rate bonds.\n        @return fundingList.length\n     */\n    function fundingListLength() external view returns (uint256) {\n        return fundingList.length;\n    }\n\n    /**\n        @notice Returns the Deposit struct associated with the deposit with ID\n                `depositID`.\n        @param depositID The ID of the deposit\n        @return The deposit struct\n     */\n    function getDeposit(uint64 depositID)\n        external\n        view\n        returns (Deposit memory)\n    {\n        return deposits[depositID - 1];\n    }\n\n    /**\n        @notice Returns the Funding struct associated with the floating-rate bond with ID\n                `fundingID`.\n        @param fundingID The ID of the floating-rate bond\n        @return The Funding struct\n     */\n    function getFunding(uint64 fundingID)\n        external\n        view\n        returns (Funding memory)\n    {\n        return fundingList[fundingID - 1];\n    }\n\n    /**\n        Internal action functions\n     */\n\n    /**\n        @dev See {deposit}\n     */\n    function _deposit(\n        address sender,\n        uint256 depositAmount,\n        uint64 maturationTimestamp,\n        bool rollover\n    ) internal virtual returns (uint64 depositID, uint256 interestAmount) {\n        (depositID, interestAmount) = _depositRecordData(\n            sender,\n            depositAmount,\n            maturationTimestamp\n        );\n        _depositTransferFunds(sender, depositAmount, rollover);\n    }\n\n    function _depositRecordData(\n        address sender,\n        uint256 depositAmount,\n        uint64 maturationTimestamp\n    ) internal virtual returns (uint64 depositID, uint256 interestAmount) {\n        // Ensure input is valid\n        require(depositAmount >= MinDepositAmount, \"DInterest: BAD_AMOUNT\");\n        uint256 depositPeriod = maturationTimestamp - block.timestamp;\n        require(depositPeriod <= MaxDepositPeriod, \"DInterest: BAD_TIME\");\n\n        // Calculate interest\n        interestAmount = calculateInterestAmount(depositAmount, depositPeriod);\n        require(interestAmount > 0, \"DInterest: BAD_INTEREST\");\n\n        // Calculate fee\n        uint256 feeAmount =\n            feeModel.getInterestFeeAmount(address(this), interestAmount);\n        interestAmount -= feeAmount;\n\n        // Record deposit data\n        deposits.push(\n            Deposit({\n                virtualTokenTotalSupply: depositAmount + interestAmount,\n                interestRate: interestAmount.decdiv(depositAmount),\n                feeRate: feeAmount.decdiv(depositAmount),\n                maturationTimestamp: maturationTimestamp,\n                fundingID: 0,\n                averageRecordedIncomeIndex: moneyMarket.incomeIndex()\n            })\n        );\n        require(deposits.length <= type(uint64).max, \"DInterest: OVERFLOW\");\n        depositID = uint64(deposits.length);\n\n        // Update global values\n        totalDeposit += depositAmount;\n        {\n            uint256 depositCap = GlobalDepositCap;\n            require(\n                depositCap == 0 || totalDeposit <= depositCap,\n                \"DInterest: CAP\"\n            );\n        }\n        totalInterestOwed += interestAmount;\n        totalFeeOwed += feeAmount;\n\n        // Mint depositNFT\n        depositNFT.mint(sender, depositID);\n\n        // Emit event\n        emit EDeposit(\n            sender,\n            depositID,\n            depositAmount,\n            interestAmount,\n            feeAmount,\n            maturationTimestamp\n        );\n\n        // Vest MPH to sender\n        mphMinter.createVestForDeposit(sender, depositID);\n    }\n\n    function _depositTransferFunds(\n        address sender,\n        uint256 depositAmount,\n        bool rollover\n    ) internal virtual {\n        // Only transfer funds from sender if it's not a rollover\n        // because if it is the funds are already in the contract\n        if (!rollover) {\n            // Transfer `depositAmount` stablecoin to DInterest\n            stablecoin.safeTransferFrom(sender, address(this), depositAmount);\n\n            // Lend `depositAmount` stablecoin to money market\n            stablecoin.safeApprove(address(moneyMarket), depositAmount);\n            moneyMarket.deposit(depositAmount);\n        }\n    }\n\n    /**\n        @dev See {topupDeposit}\n     */\n    function _topupDeposit(\n        address sender,\n        uint64 depositID,\n        uint256 depositAmount\n    ) internal virtual returns (uint256 interestAmount) {\n        interestAmount = _topupDepositRecordData(\n            sender,\n            depositID,\n            depositAmount\n        );\n        _topupDepositTransferFunds(sender, depositAmount);\n    }\n\n    function _topupDepositRecordData(\n        address sender,\n        uint64 depositID,\n        uint256 depositAmount\n    ) internal virtual returns (uint256 interestAmount) {\n        Deposit storage depositEntry = _getDeposit(depositID);\n        require(\n            depositNFT.ownerOf(depositID) == sender,\n            \"DInterest: NOT_OWNER\"\n        );\n\n        // underflow check prevents topups after maturation\n        uint256 depositPeriod =\n            depositEntry.maturationTimestamp - block.timestamp;\n\n        // Calculate interest\n        interestAmount = calculateInterestAmount(depositAmount, depositPeriod);\n        require(interestAmount > 0, \"DInterest: BAD_INTEREST\");\n\n        // Calculate fee\n        uint256 feeAmount =\n            feeModel.getInterestFeeAmount(address(this), interestAmount);\n        interestAmount -= feeAmount;\n\n        // Update deposit struct\n        uint256 interestRate = depositEntry.interestRate;\n        uint256 currentDepositAmount =\n            depositEntry.virtualTokenTotalSupply.decdiv(\n                interestRate + PRECISION\n            );\n        depositEntry.virtualTokenTotalSupply += depositAmount + interestAmount;\n        depositEntry.interestRate =\n            (PRECISION * interestAmount + currentDepositAmount * interestRate) /\n            (depositAmount + currentDepositAmount);\n        depositEntry.feeRate =\n            (PRECISION *\n                feeAmount +\n                currentDepositAmount *\n                depositEntry.feeRate) /\n            (depositAmount + currentDepositAmount);\n        uint256 sumOfRecordedDepositAmountDivRecordedIncomeIndex =\n            (currentDepositAmount * EXTRA_PRECISION) /\n                depositEntry.averageRecordedIncomeIndex +\n                (depositAmount * EXTRA_PRECISION) /\n                moneyMarket.incomeIndex();\n        depositEntry.averageRecordedIncomeIndex =\n            ((depositAmount + currentDepositAmount) * EXTRA_PRECISION) /\n            sumOfRecordedDepositAmountDivRecordedIncomeIndex;\n\n        // Update global values\n        totalDeposit += depositAmount;\n        {\n            uint256 depositCap = GlobalDepositCap;\n            require(\n                depositCap == 0 || totalDeposit <= depositCap,\n                \"DInterest: CAP\"\n            );\n        }\n        totalInterestOwed += interestAmount;\n        totalFeeOwed += feeAmount;\n\n        // Emit event\n        emit ETopupDeposit(\n            sender,\n            depositID,\n            depositAmount,\n            interestAmount,\n            feeAmount\n        );\n\n        // Update vest\n        mphMinter.updateVestForDeposit(\n            depositID,\n            currentDepositAmount,\n            depositAmount\n        );\n    }\n\n    function _topupDepositTransferFunds(address sender, uint256 depositAmount)\n        internal\n        virtual\n    {\n        // Transfer `depositAmount` stablecoin to DInterest\n        stablecoin.safeTransferFrom(sender, address(this), depositAmount);\n\n        // Lend `depositAmount` stablecoin to money market\n        stablecoin.safeApprove(address(moneyMarket), depositAmount);\n        moneyMarket.deposit(depositAmount);\n    }\n\n    /**\n        @dev See {rolloverDeposit}\n     */\n    function _rolloverDeposit(\n        address sender,\n        uint64 depositID,\n        uint64 maturationTimestamp\n    ) internal virtual returns (uint64 newDepositID, uint256 interestAmount) {\n        // withdraw from existing deposit\n        uint256 withdrawnStablecoinAmount =\n            _withdraw(sender, depositID, type(uint256).max, false, true);\n\n        // deposit funds into a new deposit\n        (newDepositID, interestAmount) = _deposit(\n            sender,\n            withdrawnStablecoinAmount,\n            maturationTimestamp,\n            true\n        );\n\n        emit ERolloverDeposit(sender, depositID, newDepositID);\n    }\n\n    /**\n        @dev See {withdraw}\n        @param rollover True if being called from {_rolloverDeposit}, false otherwise\n     */\n    function _withdraw(\n        address sender,\n        uint64 depositID,\n        uint256 virtualTokenAmount,\n        bool early,\n        bool rollover\n    ) internal virtual returns (uint256 withdrawnStablecoinAmount) {\n        (\n            uint256 withdrawAmount,\n            uint256 feeAmount,\n            uint256 fundingInterestAmount,\n            uint256 refundAmount\n        ) = _withdrawRecordData(sender, depositID, virtualTokenAmount, early);\n        return\n            _withdrawTransferFunds(\n                sender,\n                _getDeposit(depositID).fundingID,\n                withdrawAmount,\n                feeAmount,\n                fundingInterestAmount,\n                refundAmount,\n                rollover\n            );\n    }\n\n    function _withdrawRecordData(\n        address sender,\n        uint64 depositID,\n        uint256 virtualTokenAmount,\n        bool early\n    )\n        internal\n        virtual\n        returns (\n            uint256 withdrawAmount,\n            uint256 feeAmount,\n            uint256 fundingInterestAmount,\n            uint256 refundAmount\n        )\n    {\n        // Verify input\n        require(virtualTokenAmount > 0, \"DInterest: BAD_AMOUNT\");\n        Deposit storage depositEntry = _getDeposit(depositID);\n        if (early) {\n            require(\n                block.timestamp < depositEntry.maturationTimestamp,\n                \"DInterest: MATURE\"\n            );\n        } else {\n            require(\n                block.timestamp >= depositEntry.maturationTimestamp,\n                \"DInterest: IMMATURE\"\n            );\n        }\n        require(\n            depositNFT.ownerOf(depositID) == sender,\n            \"DInterest: NOT_OWNER\"\n        );\n\n        // Check if withdrawing all funds\n        {\n            uint256 virtualTokenTotalSupply =\n                depositEntry.virtualTokenTotalSupply;\n            if (virtualTokenAmount > virtualTokenTotalSupply) {\n                virtualTokenAmount = virtualTokenTotalSupply;\n            }\n        }\n\n        // Compute token amounts\n        uint256 interestRate = depositEntry.interestRate;\n        uint256 feeRate = depositEntry.feeRate;\n        uint256 depositAmount =\n            virtualTokenAmount.decdiv(interestRate + PRECISION);\n        {\n            uint256 interestAmount =\n                early ? 0 : virtualTokenAmount - depositAmount;\n            withdrawAmount = depositAmount + interestAmount;\n        }\n        if (early) {\n            // apply fee to withdrawAmount\n            uint256 earlyWithdrawFee =\n                feeModel.getEarlyWithdrawFeeAmount(\n                    address(this),\n                    depositID,\n                    withdrawAmount\n                );\n            feeAmount = earlyWithdrawFee;\n            withdrawAmount -= earlyWithdrawFee;\n        } else {\n            feeAmount = depositAmount.decmul(feeRate);\n        }\n\n        // Update global values\n        totalDeposit -= depositAmount;\n        totalInterestOwed -= virtualTokenAmount - depositAmount;\n        totalFeeOwed -= depositAmount.decmul(feeRate);\n\n        // If deposit was funded, compute funding interest payout\n        uint64 fundingID = depositEntry.fundingID;\n        if (fundingID > 0) {\n            Funding storage funding = _getFunding(fundingID);\n\n            // Compute funded deposit amount before withdrawal\n            uint256 recordedFundedPrincipalAmount =\n                (fundingMultitoken.totalSupply(fundingID) *\n                    funding.principalPerToken) / ULTRA_PRECISION;\n\n            // Shrink funding principal per token value\n            {\n                uint256 totalPrincipal =\n                    _depositVirtualTokenToPrincipal(\n                        depositID,\n                        depositEntry.virtualTokenTotalSupply\n                    );\n                uint256 totalPrincipalDecrease =\n                    virtualTokenAmount + depositAmount.decmul(feeRate);\n                if (\n                    totalPrincipal <=\n                    totalPrincipalDecrease + recordedFundedPrincipalAmount\n                ) {\n                    // Not enough unfunded principal, need to decrease funding principal per token value\n                    funding.principalPerToken = (totalPrincipal >=\n                        totalPrincipalDecrease)\n                        ? (funding.principalPerToken *\n                            (totalPrincipal - totalPrincipalDecrease)) /\n                            recordedFundedPrincipalAmount\n                        : 0;\n                }\n            }\n\n            // Compute interest payout + refund\n            // and update relevant state\n            (\n                fundingInterestAmount,\n                refundAmount\n            ) = _computeAndUpdateFundingInterestAfterWithdraw(\n                fundingID,\n                recordedFundedPrincipalAmount,\n                early\n            );\n        }\n\n        // Update vest\n        {\n            uint256 depositAmountBeforeWithdrawal =\n                _getDeposit(depositID).virtualTokenTotalSupply.decdiv(\n                    interestRate + PRECISION\n                );\n            mphMinter.updateVestForDeposit(\n                depositID,\n                depositAmountBeforeWithdrawal,\n                0\n            );\n        }\n\n        // Burn `virtualTokenAmount` deposit virtual tokens\n        _getDeposit(depositID).virtualTokenTotalSupply -= virtualTokenAmount;\n\n        // Emit event\n        emit EWithdraw(sender, depositID, early, virtualTokenAmount, feeAmount);\n    }\n\n    function _withdrawTransferFunds(\n        address sender,\n        uint64 fundingID,\n        uint256 withdrawAmount,\n        uint256 feeAmount,\n        uint256 fundingInterestAmount,\n        uint256 refundAmount,\n        bool rollover\n    ) internal virtual returns (uint256 withdrawnStablecoinAmount) {\n        // Withdraw funds from money market\n        // Withdraws principal together with funding interest to save gas\n        if (rollover) {\n            // Rollover mode, don't withdraw `withdrawAmount` from moneyMarket\n\n            // We do this because feePlusFundingInterest might\n            // be slightly less due to rounding\n            uint256 feePlusFundingInterest =\n                moneyMarket.withdraw(feeAmount + fundingInterestAmount);\n            if (feePlusFundingInterest >= feeAmount + fundingInterestAmount) {\n                // enough to pay everything, if there's extra give to feeAmount\n                feeAmount = feePlusFundingInterest - fundingInterestAmount;\n            } else if (feePlusFundingInterest >= feeAmount) {\n                // enough to pay fee, give remainder to fundingInterestAmount\n                fundingInterestAmount = feePlusFundingInterest - feeAmount;\n            } else {\n                // not enough to pay fee, give everything to fee\n                feeAmount = feePlusFundingInterest;\n                fundingInterestAmount = 0;\n            }\n\n            // we're keeping the withdrawal amount in the money market\n            withdrawnStablecoinAmount = withdrawAmount;\n        } else {\n            uint256 actualWithdrawnAmount =\n                moneyMarket.withdraw(\n                    withdrawAmount + feeAmount + fundingInterestAmount\n                );\n\n            // We do this because `actualWithdrawnAmount` might\n            // be slightly less due to rounding\n            withdrawnStablecoinAmount = withdrawAmount;\n            if (\n                actualWithdrawnAmount >=\n                withdrawAmount + feeAmount + fundingInterestAmount\n            ) {\n                // enough to pay everything, if there's extra give to feeAmount\n                feeAmount =\n                    actualWithdrawnAmount -\n                    withdrawAmount -\n                    fundingInterestAmount;\n            } else if (actualWithdrawnAmount >= withdrawAmount + feeAmount) {\n                // enough to pay withdrawal + fee + remainder\n                // give remainder to funding interest\n                fundingInterestAmount =\n                    actualWithdrawnAmount -\n                    withdrawAmount -\n                    feeAmount;\n            } else if (actualWithdrawnAmount >= withdrawAmount) {\n                // enough to pay withdrawal + remainder\n                // give remainder to fee\n                feeAmount = actualWithdrawnAmount - withdrawAmount;\n                fundingInterestAmount = 0;\n            } else {\n                // not enough to pay withdrawal\n                // give everything to withdrawal\n                withdrawnStablecoinAmount = actualWithdrawnAmount;\n                feeAmount = 0;\n                fundingInterestAmount = 0;\n            }\n\n            if (withdrawnStablecoinAmount > 0) {\n                stablecoin.safeTransfer(sender, withdrawnStablecoinAmount);\n            }\n        }\n\n        // Send `feeAmount` stablecoin to feeModel beneficiary\n        if (feeAmount > 0) {\n            stablecoin.safeTransfer(feeModel.beneficiary(), feeAmount);\n        }\n\n        // Distribute `fundingInterestAmount` stablecoins to funders\n        if (fundingInterestAmount > 0) {\n            stablecoin.safeApprove(\n                address(fundingMultitoken),\n                fundingInterestAmount\n            );\n            fundingMultitoken.distributeDividends(\n                fundingID,\n                address(stablecoin),\n                fundingInterestAmount\n            );\n            // Mint funder rewards\n            if (fundingInterestAmount > refundAmount) {\n                _distributeFundingRewards(\n                    fundingID,\n                    fundingInterestAmount - refundAmount\n                );\n            }\n        }\n    }\n\n    /**\n        @dev See {fund}\n     */\n    function _fund(\n        address sender,\n        uint64 depositID,\n        uint256 fundAmount\n    ) internal virtual returns (uint64 fundingID) {\n        uint256 actualFundAmount;\n        (fundingID, actualFundAmount) = _fundRecordData(\n            sender,\n            depositID,\n            fundAmount\n        );\n        _fundTransferFunds(sender, actualFundAmount);\n    }\n\n    function _fundRecordData(\n        address sender,\n        uint64 depositID,\n        uint256 fundAmount\n    ) internal virtual returns (uint64 fundingID, uint256 actualFundAmount) {\n        Deposit storage depositEntry = _getDeposit(depositID);\n        uint256 incomeIndex = moneyMarket.incomeIndex();\n\n        (bool isNegative, uint256 surplusMagnitude) = _surplus(incomeIndex);\n        require(isNegative, \"DInterest: NO_DEBT\");\n\n        (isNegative, surplusMagnitude) = _rawSurplusOfDeposit(\n            depositID,\n            incomeIndex\n        );\n        require(isNegative, \"DInterest: NO_DEBT\");\n        if (fundAmount > surplusMagnitude) {\n            fundAmount = surplusMagnitude;\n        }\n\n        // Create funding struct if one doesn't exist\n        uint256 totalPrincipal =\n            _depositVirtualTokenToPrincipal(\n                depositID,\n                depositEntry.virtualTokenTotalSupply\n            );\n        uint256 totalPrincipalToFund;\n        fundingID = depositEntry.fundingID;\n        uint256 mintTokenAmount;\n        if (fundingID == 0 || _getFunding(fundingID).principalPerToken == 0) {\n            // The first funder, create struct\n            require(block.timestamp <= type(uint64).max, \"DInterest: OVERFLOW\");\n            fundingList.push(\n                Funding({\n                    depositID: depositID,\n                    lastInterestPayoutTimestamp: uint64(block.timestamp),\n                    recordedMoneyMarketIncomeIndex: incomeIndex,\n                    principalPerToken: ULTRA_PRECISION\n                })\n            );\n            require(\n                fundingList.length <= type(uint64).max,\n                \"DInterest: OVERFLOW\"\n            );\n            fundingID = uint64(fundingList.length);\n            depositEntry.fundingID = fundingID;\n            totalPrincipalToFund =\n                (totalPrincipal * fundAmount) /\n                surplusMagnitude;\n            mintTokenAmount = totalPrincipalToFund;\n        } else {\n            // Not the first funder\n            // Trigger interest payment for existing funders\n            _payInterestToFunders(fundingID, incomeIndex);\n\n            // Compute amount of principal to fund\n            uint256 principalPerToken =\n                _getFunding(fundingID).principalPerToken;\n            uint256 unfundedPrincipalAmount =\n                totalPrincipal -\n                    (fundingMultitoken.totalSupply(fundingID) *\n                        principalPerToken) /\n                    ULTRA_PRECISION;\n            surplusMagnitude =\n                (surplusMagnitude * unfundedPrincipalAmount) /\n                totalPrincipal;\n            if (fundAmount > surplusMagnitude) {\n                fundAmount = surplusMagnitude;\n            }\n            totalPrincipalToFund =\n                (unfundedPrincipalAmount * fundAmount) /\n                surplusMagnitude;\n            mintTokenAmount =\n                (totalPrincipalToFund * ULTRA_PRECISION) /\n                principalPerToken;\n        }\n        // Mint funding multitoken\n        fundingMultitoken.mint(sender, fundingID, mintTokenAmount);\n\n        // Update relevant values\n        sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +=\n            (totalPrincipalToFund * EXTRA_PRECISION) /\n            incomeIndex;\n        totalFundedPrincipalAmount += totalPrincipalToFund;\n\n        // Emit event\n        emit EFund(sender, fundingID, fundAmount, mintTokenAmount);\n\n        actualFundAmount = fundAmount;\n    }\n\n    function _fundTransferFunds(address sender, uint256 fundAmount)\n        internal\n        virtual\n    {\n        // Transfer `fundAmount` stablecoins from sender\n        stablecoin.safeTransferFrom(sender, address(this), fundAmount);\n\n        // Deposit `fundAmount` stablecoins into moneyMarket\n        stablecoin.safeApprove(address(moneyMarket), fundAmount);\n        moneyMarket.deposit(fundAmount);\n    }\n\n    /**\n        @dev See {payInterestToFunders}\n        @param currentMoneyMarketIncomeIndex The moneyMarket's current incomeIndex\n     */\n    function _payInterestToFunders(\n        uint64 fundingID,\n        uint256 currentMoneyMarketIncomeIndex\n    ) internal virtual returns (uint256 interestAmount) {\n        Funding storage f = _getFunding(fundingID);\n        {\n            uint256 recordedMoneyMarketIncomeIndex =\n                f.recordedMoneyMarketIncomeIndex;\n            uint256 fundingTokenTotalSupply =\n                fundingMultitoken.totalSupply(fundingID);\n            uint256 recordedFundedPrincipalAmount =\n                (fundingTokenTotalSupply * f.principalPerToken) /\n                    ULTRA_PRECISION;\n\n            // Update funding values\n            sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex =\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\n                (recordedFundedPrincipalAmount * EXTRA_PRECISION) /\n                currentMoneyMarketIncomeIndex -\n                (recordedFundedPrincipalAmount * EXTRA_PRECISION) /\n                recordedMoneyMarketIncomeIndex;\n            f.recordedMoneyMarketIncomeIndex = currentMoneyMarketIncomeIndex;\n\n            // Compute interest to funders\n            interestAmount =\n                (recordedFundedPrincipalAmount *\n                    currentMoneyMarketIncomeIndex) /\n                recordedMoneyMarketIncomeIndex -\n                recordedFundedPrincipalAmount;\n        }\n\n        // Distribute interest to funders\n        if (interestAmount > 0) {\n            uint256 stablecoinPrecision = 10**uint256(stablecoin.decimals());\n            if (\n                interestAmount >\n                stablecoinPrecision / FUNDER_PAYOUT_THRESHOLD_DIVISOR\n            ) {\n                interestAmount = moneyMarket.withdraw(interestAmount);\n                if (interestAmount > 0) {\n                    stablecoin.safeApprove(\n                        address(fundingMultitoken),\n                        interestAmount\n                    );\n                    fundingMultitoken.distributeDividends(\n                        fundingID,\n                        address(stablecoin),\n                        interestAmount\n                    );\n\n                    _distributeFundingRewards(fundingID, interestAmount);\n                }\n            } else {\n                // interestAmount below minimum payout threshold, pay nothing\n                emit EPayFundingInterest(fundingID, 0, 0);\n                return 0;\n            }\n        }\n\n        emit EPayFundingInterest(fundingID, interestAmount, 0);\n    }\n\n    /**\n        @dev Mints MPH rewards to the holders of an FRB. If past the deposit maturation,\n             only mint proportional to the time from the last distribution to the maturation.\n        @param fundingID The ID of the funding\n        @param rawInterestAmount The interest being distributed\n     */\n    function _distributeFundingRewards(\n        uint64 fundingID,\n        uint256 rawInterestAmount\n    ) internal {\n        Funding storage f = _getFunding(fundingID);\n\n        // Mint funder rewards\n        uint256 maturationTimestamp =\n            _getDeposit(f.depositID).maturationTimestamp;\n        if (block.timestamp > maturationTimestamp) {\n            // past maturation, only mint proportionally to maturation - last payout\n            uint256 lastInterestPayoutTimestamp = f.lastInterestPayoutTimestamp;\n            if (lastInterestPayoutTimestamp < maturationTimestamp) {\n                uint256 effectiveInterestAmount =\n                    (rawInterestAmount *\n                        (maturationTimestamp - lastInterestPayoutTimestamp)) /\n                        (block.timestamp - lastInterestPayoutTimestamp);\n                mphMinter.distributeFundingRewards(\n                    fundingID,\n                    effectiveInterestAmount\n                );\n            }\n        } else {\n            // before maturation, mint full amount\n            mphMinter.distributeFundingRewards(fundingID, rawInterestAmount);\n        }\n        // update last payout timestamp\n        require(block.timestamp <= type(uint64).max, \"DInterest: OVERFLOW\");\n        f.lastInterestPayoutTimestamp = uint64(block.timestamp);\n    }\n\n    /**\n        @dev Used in {_withdraw}. Computes the amount of interest to distribute\n             to the deposit's floating-rate bond holders. Also updates the Funding\n             struct associated with the floating-rate bond.\n        @param fundingID The ID of the floating-rate bond\n        @param recordedFundedPrincipalAmount The amount of principal funded before the withdrawal\n        @param early True if withdrawing before maturation, false otherwise\n        @return fundingInterestAmount The amount of interest to distribute to the floating-rate bond holders, plus the refund amount\n        @return refundAmount The amount of refund caused by an early withdraw\n     */\n    function _computeAndUpdateFundingInterestAfterWithdraw(\n        uint64 fundingID,\n        uint256 recordedFundedPrincipalAmount,\n        bool early\n    )\n        internal\n        virtual\n        returns (uint256 fundingInterestAmount, uint256 refundAmount)\n    {\n        Funding storage f = _getFunding(fundingID);\n        uint256 currentFundedPrincipalAmount =\n            (fundingMultitoken.totalSupply(fundingID) * f.principalPerToken) /\n                ULTRA_PRECISION;\n\n        // Update funding values\n        {\n            uint256 recordedMoneyMarketIncomeIndex =\n                f.recordedMoneyMarketIncomeIndex;\n            uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\n            uint256 currentFundedPrincipalAmountDivRecordedIncomeIndex =\n                (currentFundedPrincipalAmount * EXTRA_PRECISION) /\n                    currentMoneyMarketIncomeIndex;\n            uint256 recordedFundedPrincipalAmountDivRecordedIncomeIndex =\n                (recordedFundedPrincipalAmount * EXTRA_PRECISION) /\n                    recordedMoneyMarketIncomeIndex;\n            if (\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\n                    currentFundedPrincipalAmountDivRecordedIncomeIndex >=\n                recordedFundedPrincipalAmountDivRecordedIncomeIndex\n            ) {\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex =\n                    sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\n                    currentFundedPrincipalAmountDivRecordedIncomeIndex -\n                    recordedFundedPrincipalAmountDivRecordedIncomeIndex;\n            } else {\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex = 0;\n            }\n\n            f.recordedMoneyMarketIncomeIndex = currentMoneyMarketIncomeIndex;\n            totalFundedPrincipalAmount -=\n                recordedFundedPrincipalAmount -\n                currentFundedPrincipalAmount;\n\n            // Compute interest to funders\n            fundingInterestAmount =\n                (recordedFundedPrincipalAmount *\n                    currentMoneyMarketIncomeIndex) /\n                recordedMoneyMarketIncomeIndex -\n                recordedFundedPrincipalAmount;\n        }\n\n        // Add refund to interestAmount\n        if (early) {\n            Deposit storage depositEntry = _getDeposit(f.depositID);\n            uint256 interestRate = depositEntry.interestRate;\n            uint256 feeRate = depositEntry.feeRate;\n            (, uint256 moneyMarketInterestRatePerSecond) =\n                interestOracle.updateAndQuery();\n            refundAmount =\n                (((recordedFundedPrincipalAmount -\n                    currentFundedPrincipalAmount) * PRECISION)\n                    .decmul(moneyMarketInterestRatePerSecond) *\n                    (depositEntry.maturationTimestamp - block.timestamp)) /\n                PRECISION;\n            uint256 maxRefundAmount =\n                (recordedFundedPrincipalAmount - currentFundedPrincipalAmount)\n                    .decdiv(PRECISION + interestRate + feeRate)\n                    .decmul(interestRate + feeRate);\n            refundAmount = refundAmount <= maxRefundAmount\n                ? refundAmount\n                : maxRefundAmount;\n            fundingInterestAmount += refundAmount;\n        }\n\n        emit EPayFundingInterest(\n            fundingID,\n            fundingInterestAmount,\n            refundAmount\n        );\n    }\n\n    /**\n        Internal getter functions\n     */\n\n    /**\n        @dev See {getDeposit}\n     */\n    function _getDeposit(uint64 depositID)\n        internal\n        view\n        returns (Deposit storage)\n    {\n        return deposits[depositID - 1];\n    }\n\n    /**\n        @dev See {getFunding}\n     */\n    function _getFunding(uint64 fundingID)\n        internal\n        view\n        returns (Funding storage)\n    {\n        return fundingList[fundingID - 1];\n    }\n\n    /**\n        @dev Converts a virtual token value into the corresponding principal value.\n             Principal refers to deposit + full interest + fee.\n        @param depositID The ID of the deposit of the virtual tokens\n        @param virtualTokenAmount The virtual token value\n        @return The corresponding principal value\n     */\n    function _depositVirtualTokenToPrincipal(\n        uint64 depositID,\n        uint256 virtualTokenAmount\n    ) internal view virtual returns (uint256) {\n        Deposit storage depositEntry = _getDeposit(depositID);\n        uint256 depositInterestRate = depositEntry.interestRate;\n        return\n            virtualTokenAmount.decdiv(depositInterestRate + PRECISION).decmul(\n                depositInterestRate + depositEntry.feeRate + PRECISION\n            );\n    }\n\n    /**\n        @dev See {Rescuable._authorizeRescue}\n     */\n    function _authorizeRescue(\n        address, /*token*/\n        address /*target*/\n    ) internal view override {\n        require(msg.sender == owner(), \"DInterest: NOT_OWNER\");\n    }\n\n    /**\n        @dev See {surplus}\n        @param incomeIndex The moneyMarket's current incomeIndex\n     */\n    function _surplus(uint256 incomeIndex)\n        internal\n        virtual\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        // compute totalInterestOwedToFunders\n        uint256 currentValue =\n            (incomeIndex *\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex) /\n                EXTRA_PRECISION;\n        uint256 initialValue = totalFundedPrincipalAmount;\n        uint256 totalInterestOwedToFunders;\n        if (currentValue > initialValue) {\n            totalInterestOwedToFunders = currentValue - initialValue;\n        }\n\n        // compute surplus\n        uint256 totalValue = moneyMarket.totalValue(incomeIndex);\n        uint256 totalOwed =\n            totalDeposit +\n                totalInterestOwed +\n                totalFeeOwed +\n                totalInterestOwedToFunders;\n        if (totalValue >= totalOwed) {\n            // Locked value more than owed deposits, positive surplus\n            isNegative = false;\n            surplusAmount = totalValue - totalOwed;\n        } else {\n            // Locked value less than owed deposits, negative surplus\n            isNegative = true;\n            surplusAmount = totalOwed - totalValue;\n        }\n    }\n\n    /**\n        @dev See {rawSurplusOfDeposit}\n        @param currentMoneyMarketIncomeIndex The moneyMarket's current incomeIndex\n     */\n    function _rawSurplusOfDeposit(\n        uint64 depositID,\n        uint256 currentMoneyMarketIncomeIndex\n    ) internal virtual returns (bool isNegative, uint256 surplusAmount) {\n        Deposit storage depositEntry = _getDeposit(depositID);\n        uint256 depositTokenTotalSupply = depositEntry.virtualTokenTotalSupply;\n        uint256 depositAmount =\n            depositTokenTotalSupply.decdiv(\n                depositEntry.interestRate + PRECISION\n            );\n        uint256 interestAmount = depositTokenTotalSupply - depositAmount;\n        uint256 feeAmount = depositAmount.decmul(depositEntry.feeRate);\n        uint256 currentDepositValue =\n            (depositAmount * currentMoneyMarketIncomeIndex) /\n                depositEntry.averageRecordedIncomeIndex;\n        uint256 owed = depositAmount + interestAmount + feeAmount;\n        if (currentDepositValue >= owed) {\n            // Locked value more than owed deposits, positive surplus\n            isNegative = false;\n            surplusAmount = currentDepositValue - owed;\n        } else {\n            // Locked value less than owed deposits, negative surplus\n            isNegative = true;\n            surplusAmount = owed - currentDepositValue;\n        }\n    }\n\n    /**\n        Param setters (only callable by the owner)\n     */\n    function setFeeModel(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: NOT_CONTRACT\");\n        feeModel = IFeeModel(newValue);\n        emit ESetParamAddress(msg.sender, \"feeModel\", newValue);\n    }\n\n    function setInterestModel(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: NOT_CONTRACT\");\n        interestModel = IInterestModel(newValue);\n        emit ESetParamAddress(msg.sender, \"interestModel\", newValue);\n    }\n\n    function setInterestOracle(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: NOT_CONTRACT\");\n        interestOracle = IInterestOracle(newValue);\n        require(\n            interestOracle.moneyMarket() == moneyMarket,\n            \"DInterest: BAD_ORACLE\"\n        );\n        emit ESetParamAddress(msg.sender, \"interestOracle\", newValue);\n    }\n\n    function setRewards(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: NOT_CONTRACT\");\n        moneyMarket.setRewards(newValue);\n        emit ESetParamAddress(msg.sender, \"moneyMarket.rewards\", newValue);\n    }\n\n    function setMPHMinter(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: NOT_CONTRACT\");\n        mphMinter = MPHMinter(newValue);\n        emit ESetParamAddress(msg.sender, \"mphMinter\", newValue);\n    }\n\n    function setMaxDepositPeriod(uint64 newValue) external onlyOwner {\n        require(newValue > 0, \"DInterest: BAD_VAL\");\n        MaxDepositPeriod = newValue;\n        emit ESetParamUint(msg.sender, \"MaxDepositPeriod\", uint256(newValue));\n    }\n\n    function setMinDepositAmount(uint256 newValue) external onlyOwner {\n        require(newValue > 0, \"DInterest: BAD_VAL\");\n        MinDepositAmount = newValue;\n        emit ESetParamUint(msg.sender, \"MinDepositAmount\", newValue);\n    }\n\n    function setGlobalDepositCap(uint256 newValue) external onlyOwner {\n        GlobalDepositCap = newValue;\n        emit ESetParamUint(msg.sender, \"GlobalDepositCap\", newValue);\n    }\n\n    function setDepositNFTBaseURI(string calldata newURI) external onlyOwner {\n        depositNFT.setBaseURI(newURI);\n    }\n\n    function setDepositNFTContractURI(string calldata newURI)\n        external\n        onlyOwner\n    {\n        depositNFT.setContractURI(newURI);\n    }\n\n    function skimSurplus(address recipient) external onlyOwner {\n        (bool isNegative, uint256 surplusMagnitude) = surplus();\n        if (!isNegative) {\n            surplusMagnitude = moneyMarket.withdraw(surplusMagnitude);\n            stablecoin.safeTransfer(recipient, surplusMagnitude);\n        }\n    }\n\n    function decreaseFeeForDeposit(uint64 depositID, uint256 newFeeRate)\n        external\n        onlyOwner\n    {\n        Deposit storage depositStorage = _getDeposit(depositID);\n        uint256 feeRate = depositStorage.feeRate;\n        uint256 interestRate = depositStorage.interestRate;\n        uint256 virtualTokenTotalSupply =\n            depositStorage.virtualTokenTotalSupply;\n        require(newFeeRate < feeRate, \"DInterest: BAD_VAL\");\n        uint256 depositAmount =\n            virtualTokenTotalSupply.decdiv(interestRate + PRECISION);\n\n        // update fee rate\n        depositStorage.feeRate = newFeeRate;\n\n        // update interest rate\n        // fee reduction is allocated to interest\n        uint256 reducedFeeAmount = depositAmount.decmul(feeRate - newFeeRate);\n        depositStorage.interestRate =\n            interestRate +\n            reducedFeeAmount.decdiv(depositAmount);\n\n        // update global amounts\n        totalInterestOwed += reducedFeeAmount;\n        totalFeeOwed -= reducedFeeAmount;\n    }\n\n    uint256[32] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/libs/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n        @dev Modified from openzeppelin. Instead of reverting when the allowance is non-zero and value\n        is non-zero, we first set the allowance to 0 and then call approve(spender, value).\n        This provides support for non-standard tokens such as USDT that revert in this scenario. \n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if ((token.allowance(address(this), spender)) > 0) {\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(token.approve.selector, spender, 0)\n            );\n        }\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata =\n            address(token).functionCall(\n                data,\n                \"SafeERC20: low-level call failed\"\n            );\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./AddressUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract MulticallUpgradeable is Initializable {\n    function __Multicall_init() internal initializer {\n        __Multicall_init_unchained();\n    }\n\n    function __Multicall_init_unchained() internal initializer {\n    }\n    /**\n    * @dev Receives and executes a batch of function calls on this contract.\n    */\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint i = 0; i < data.length; i++) {\n            results[i] = _functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/moneymarkets/MoneyMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    AccessControlUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {Rescuable} from \"../libs/Rescuable.sol\";\n\n// Interface for money market protocols (Compound, Aave, etc.)\nabstract contract MoneyMarket is\n    Rescuable,\n    OwnableUpgradeable,\n    AccessControlUpgradeable\n{\n    bytes32 internal constant RESCUER_ROLE = keccak256(\"RESCUER_ROLE\");\n\n    function __MoneyMarket_init(address rescuer) internal initializer {\n        __Ownable_init();\n        __AccessControl_init();\n\n        // RESCUER_ROLE is managed by itself\n        _setupRole(RESCUER_ROLE, rescuer);\n        _setRoleAdmin(RESCUER_ROLE, RESCUER_ROLE);\n    }\n\n    function deposit(uint256 amount) external virtual;\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        virtual\n        returns (uint256 actualAmountWithdrawn);\n\n    function totalValue() external virtual returns (uint256); // The total value locked in the money market, in terms of the underlying stablecoin\n\n    function totalValue(uint256 currentIncomeIndex)\n        external\n        view\n        virtual\n        returns (uint256); // The total value locked in the money market, in terms of the underlying stablecoin\n\n    function incomeIndex() external virtual returns (uint256); // Used for calculating the interest generated (e.g. cDai's price for the Compound market)\n\n    function stablecoin() external view virtual returns (ERC20);\n\n    function claimRewards() external virtual; // Claims farmed tokens (e.g. COMP, CRV) and sends it to the rewards pool\n\n    function setRewards(address newValue) external virtual;\n\n    /**\n        @dev See {Rescuable._authorizeRescue}\n     */\n    function _authorizeRescue(\n        address, /*token*/\n        address /*target*/\n    ) internal view virtual override {\n        require(hasRole(RESCUER_ROLE, msg.sender), \"MoneyMarket: not rescuer\");\n    }\n\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n}\n"
    },
    "contracts/models/fee/IFeeModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\ninterface IFeeModel {\n    function beneficiary() external view returns (address payable);\n\n    function getInterestFeeAmount(address pool, uint256 interestAmount)\n        external\n        view\n        returns (uint256 feeAmount);\n\n    function getEarlyWithdrawFeeAmount(\n        address pool,\n        uint64 depositID,\n        uint256 withdrawnDepositAmount\n    ) external view returns (uint256 feeAmount);\n}\n"
    },
    "contracts/models/interest/IInterestModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\ninterface IInterestModel {\n    function calculateInterestAmount(\n        uint256 depositAmount,\n        uint256 depositPeriodInSeconds,\n        uint256 moneyMarketInterestRatePerSecond,\n        bool surplusIsNegative,\n        uint256 surplusAmount\n    ) external view returns (uint256 interestAmount);\n}\n"
    },
    "contracts/tokens/NFT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {\n    ERC721URIStorageUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract NFT is ERC721URIStorageUpgradeable, OwnableUpgradeable {\n    string internal _contractURI;\n    string internal __baseURI;\n\n    function initialize(string calldata tokenName, string calldata tokenSymbol)\n        external\n        initializer\n    {\n        __Ownable_init();\n        __ERC721_init(tokenName, tokenSymbol);\n    }\n\n    function contractURI() external view returns (string memory) {\n        return _contractURI;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return __baseURI;\n    }\n\n    function mint(address to, uint256 tokenId) external onlyOwner {\n        _safeMint(to, tokenId);\n    }\n\n    function burn(uint256 tokenId) external onlyOwner {\n        _burn(tokenId);\n    }\n\n    function setContractURI(string calldata newURI) external onlyOwner {\n        _contractURI = newURI;\n    }\n\n    function setTokenURI(uint256 tokenId, string calldata newURI) external {\n        require(ownerOf(tokenId) == msg.sender, \"NFT: not token owner\");\n        _setTokenURI(tokenId, newURI);\n    }\n\n    function setBaseURI(string calldata newURI) external onlyOwner {\n        __baseURI = newURI;\n    }\n\n    uint256[48] private __gap;\n}\n"
    },
    "contracts/tokens/FundingMultitoken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC1155Upgradeable} from \"../libs/ERC1155Upgradeable.sol\";\nimport {ERC1155DividendToken} from \"../libs/ERC1155DividendToken.sol\";\nimport {WrappedERC1155Token} from \"../libs/WrappedERC1155Token.sol\";\n\ncontract FundingMultitoken is ERC1155DividendToken, WrappedERC1155Token {\n    bytes32 public constant DIVIDEND_ROLE = keccak256(\"DIVIDEND_ROLE\");\n\n    function __FundingMultitoken_init(\n        address admin,\n        string calldata uri,\n        address[] memory dividendTokens,\n        address _wrapperTemplate,\n        bool _deployWrapperOnMint,\n        string memory _baseName,\n        string memory _baseSymbol,\n        uint8 _decimals\n    ) internal initializer {\n        __ERC1155Base_init(admin, uri);\n        __ERC1155DividendToken_init_unchained(dividendTokens);\n        __WrappedERC1155Token_init_unchained(\n            _wrapperTemplate,\n            _deployWrapperOnMint,\n            _baseName,\n            _baseSymbol,\n            _decimals\n        );\n        __FundingMultitoken_init_unchained(admin);\n    }\n\n    function __FundingMultitoken_init_unchained(address admin)\n        internal\n        initializer\n    {\n        // DIVIDEND_ROLE is managed by itself\n        _setupRole(DIVIDEND_ROLE, admin);\n        _setRoleAdmin(DIVIDEND_ROLE, DIVIDEND_ROLE);\n    }\n\n    function initialize(\n        address admin,\n        string calldata uri,\n        address[] calldata dividendTokens,\n        address _wrapperTemplate,\n        bool _deployWrapperOnMint,\n        string memory _baseName,\n        string memory _baseSymbol,\n        uint8 _decimals\n    ) external virtual initializer {\n        __FundingMultitoken_init(\n            admin,\n            uri,\n            dividendTokens,\n            _wrapperTemplate,\n            _deployWrapperOnMint,\n            _baseName,\n            _baseSymbol,\n            _decimals\n        );\n    }\n\n    function distributeDividends(\n        uint256 tokenID,\n        address dividendToken,\n        uint256 amount\n    ) external {\n        require(\n            hasRole(DIVIDEND_ROLE, _msgSender()),\n            \"FundingMultitoken: must have dividend role\"\n        );\n        _distributeDividends(tokenID, dividendToken, amount);\n    }\n\n    function withdrawDividend(uint256 tokenID, address dividendToken) external {\n        _withdrawDividend(tokenID, dividendToken, msg.sender);\n    }\n\n    function withdrawDividendFor(\n        uint256 tokenID,\n        address dividendToken,\n        address user\n    ) external {\n        require(\n            hasRole(DIVIDEND_ROLE, _msgSender()),\n            \"FundingMultitoken: must have dividend role\"\n        );\n        _withdrawDividend(tokenID, dividendToken, user);\n    }\n\n    function registerDividendToken(address dividendToken) external {\n        require(\n            hasRole(DIVIDEND_ROLE, _msgSender()),\n            \"FundingMultitoken: must have dividend role\"\n        );\n        _registerDividendToken(dividendToken);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155DividendToken, WrappedERC1155Token) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n        @dev See {ERC1155Upgradeable._shouldSkipSafeTransferAcceptanceCheck}\n     */\n    function _shouldSkipSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        internal\n        override(ERC1155Upgradeable, WrappedERC1155Token)\n        returns (bool)\n    {\n        return\n            WrappedERC1155Token._shouldSkipSafeTransferAcceptanceCheck(\n                operator,\n                from,\n                to,\n                id,\n                amount,\n                data\n            );\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/rewards/MPHMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {\n    AccessControlUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {\n    AddressUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {Vesting02} from \"./Vesting02.sol\";\nimport {FundingMultitoken} from \"../tokens/FundingMultitoken.sol\";\nimport {DecMath} from \"../libs/DecMath.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {MPHToken} from \"./MPHToken.sol\";\n\ncontract MPHMinter is AccessControlUpgradeable {\n    using AddressUpgradeable for address;\n    using DecMath for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n    bytes32 public constant WHITELISTER_ROLE = keccak256(\"WHITELISTER_ROLE\");\n    bytes32 public constant WHITELISTED_POOL_ROLE =\n        keccak256(\"WHITELISTED_POOL_ROLE\");\n\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n    event ESetParamUint(\n        address indexed sender,\n        string indexed paramName,\n        address pool,\n        uint256 newValue\n    );\n    event MintDepositorReward(\n        address indexed sender,\n        address indexed to,\n        uint256 depositorReward\n    );\n    event MintFunderReward(\n        address indexed sender,\n        address indexed to,\n        uint256 funderReward\n    );\n\n    /**\n        @notice The multiplier applied when minting MPH for a pool's depositor reward.\n                Unit is MPH-wei per depositToken-wei per second. (wei here is the smallest decimal place)\n                Scaled by 10^18.\n                NOTE: The depositToken's decimals matter!\n     */\n    mapping(address => uint256) public poolDepositorRewardMintMultiplier;\n    /**\n        @notice The multiplier applied when minting MPH for a pool's funder reward.\n                Unit is MPH-wei per depositToken-wei. (wei here is the smallest decimal place)\n                Scaled by 10^18.\n                NOTE: The depositToken's decimals matter!\n     */\n    mapping(address => uint256) public poolFunderRewardMultiplier;\n    /**\n        @notice Multiplier used for calculating dev reward\n     */\n    uint256 public devRewardMultiplier;\n    /**\n        @notice Multiplier used for calculating gov reward\n     */\n    uint256 public govRewardMultiplier;\n\n    /**\n        External contracts\n     */\n    MPHToken public mph;\n    address public govTreasury;\n    address public devWallet;\n    Vesting02 public vesting02;\n\n    function __MPHMinter_init(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) internal initializer {\n        __AccessControl_init();\n        __MPHMinter_init_unchained(\n            _mph,\n            _govTreasury,\n            _devWallet,\n            _vesting02,\n            _devRewardMultiplier,\n            _govRewardMultiplier\n        );\n    }\n\n    function __MPHMinter_init_unchained(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) internal initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        // only accounts with the whitelister role can whitelist pools\n        _setRoleAdmin(WHITELISTED_POOL_ROLE, WHITELISTER_ROLE);\n\n        mph = MPHToken(_mph);\n        govTreasury = _govTreasury;\n        devWallet = _devWallet;\n        vesting02 = Vesting02(_vesting02);\n        devRewardMultiplier = _devRewardMultiplier;\n        govRewardMultiplier = _govRewardMultiplier;\n    }\n\n    function initialize(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        address _vesting02,\n        uint256 _devRewardMultiplier,\n        uint256 _govRewardMultiplier\n    ) external initializer {\n        __MPHMinter_init(\n            _mph,\n            _govTreasury,\n            _devWallet,\n            _vesting02,\n            _devRewardMultiplier,\n            _govRewardMultiplier\n        );\n    }\n\n    function createVestForDeposit(address account, uint64 depositID)\n        external\n        onlyRole(WHITELISTED_POOL_ROLE)\n    {\n        vesting02.createVestForDeposit(\n            account,\n            msg.sender,\n            depositID,\n            poolDepositorRewardMintMultiplier[msg.sender]\n        );\n    }\n\n    function updateVestForDeposit(\n        uint64 depositID,\n        uint256 currentDepositAmount,\n        uint256 depositAmount\n    ) external onlyRole(WHITELISTED_POOL_ROLE) {\n        vesting02.updateVestForDeposit(\n            msg.sender,\n            depositID,\n            currentDepositAmount,\n            depositAmount,\n            poolDepositorRewardMintMultiplier[msg.sender]\n        );\n    }\n\n    function mintVested(address account, uint256 amount)\n        external\n        returns (uint256 mintedAmount)\n    {\n        require(msg.sender == address(vesting02), \"MPHMinter: not vesting02\");\n        if (mph.owner() != address(this)) {\n            // not the owner of the MPH token, cannot mint\n            return 0;\n        }\n        if (amount > 0) {\n            mph.ownerMint(account, amount);\n        }\n        uint256 devReward = amount.decmul(devRewardMultiplier);\n        if (devReward > 0) {\n            mph.ownerMint(devWallet, devReward);\n        }\n        uint256 govReward = amount.decmul(govRewardMultiplier);\n        if (govReward > 0) {\n            mph.ownerMint(govTreasury, govReward);\n        }\n        return amount;\n    }\n\n    function distributeFundingRewards(uint64 fundingID, uint256 interestAmount)\n        external\n        onlyRole(WHITELISTED_POOL_ROLE)\n    {\n        if (interestAmount == 0 || mph.owner() != address(this)) {\n            return;\n        }\n        uint256 mintMPHAmount =\n            interestAmount.decmul(poolFunderRewardMultiplier[msg.sender]);\n        if (mintMPHAmount == 0) {\n            return;\n        }\n        FundingMultitoken fundingMultitoken =\n            DInterest(msg.sender).fundingMultitoken();\n        mph.ownerMint(address(this), mintMPHAmount);\n        mph.increaseAllowance(address(fundingMultitoken), mintMPHAmount);\n        fundingMultitoken.distributeDividends(\n            fundingID,\n            address(mph),\n            mintMPHAmount\n        );\n\n        uint256 devReward = mintMPHAmount.decmul(devRewardMultiplier);\n        if (devReward > 0) {\n            mph.ownerMint(devWallet, devReward);\n        }\n        uint256 govReward = mintMPHAmount.decmul(govRewardMultiplier);\n        if (govReward > 0) {\n            mph.ownerMint(govTreasury, govReward);\n        }\n    }\n\n    /**\n        Param setters\n     */\n    function setPoolDepositorRewardMintMultiplier(\n        address pool,\n        uint256 newMultiplier\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(pool.isContract(), \"MPHMinter: pool not contract\");\n        poolDepositorRewardMintMultiplier[pool] = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"poolDepositorRewardMintMultiplier\",\n            pool,\n            newMultiplier\n        );\n    }\n\n    function setPoolFunderRewardMultiplier(address pool, uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(pool.isContract(), \"MPHMinter: pool not contract\");\n        poolFunderRewardMultiplier[pool] = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"poolFunderRewardMultiplier\",\n            pool,\n            newMultiplier\n        );\n    }\n\n    function setDevRewardMultiplier(uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newMultiplier <= PRECISION, \"MPHMinter: invalid multiplier\");\n        devRewardMultiplier = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"devRewardMultiplier\",\n            address(0),\n            newMultiplier\n        );\n    }\n\n    function setGovRewardMultiplier(uint256 newMultiplier)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newMultiplier <= PRECISION, \"MPHMinter: invalid multiplier\");\n        govRewardMultiplier = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"govRewardMultiplier\",\n            address(0),\n            newMultiplier\n        );\n    }\n\n    function setGovTreasury(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        govTreasury = newValue;\n        emit ESetParamAddress(msg.sender, \"govTreasury\", newValue);\n    }\n\n    function setDevWallet(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        devWallet = newValue;\n        emit ESetParamAddress(msg.sender, \"devWallet\", newValue);\n    }\n\n    function setMPHTokenOwner(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        mph.transferOwnership(newValue);\n        emit ESetParamAddress(msg.sender, \"mphTokenOwner\", newValue);\n    }\n\n    function setMPHTokenOwnerToZero() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        mph.renounceOwnership();\n        emit ESetParamAddress(msg.sender, \"mphTokenOwner\", address(0));\n    }\n\n    function setVesting02(address newValue)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newValue.isContract(), \"MPHMinter: not contract\");\n        vesting02 = Vesting02(newValue);\n        emit ESetParamAddress(msg.sender, \"vesting02\", newValue);\n    }\n\n    uint256[42] private __gap;\n}\n"
    },
    "contracts/models/interest-oracle/IInterestOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {MoneyMarket} from \"../../moneymarkets/MoneyMarket.sol\";\n\ninterface IInterestOracle {\n    function updateAndQuery() external returns (bool updated, uint256 value);\n\n    function query() external view returns (uint256 value);\n\n    function moneyMarket() external view returns (MoneyMarket);\n}\n"
    },
    "contracts/libs/DecMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\n// Decimal math library\nlibrary DecMath {\n    uint256 internal constant PRECISION = 10**18;\n\n    function decmul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * b) / PRECISION;\n    }\n\n    function decdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * PRECISION) / b;\n    }\n}\n"
    },
    "contracts/libs/Rescuable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {SafeERC20} from \"./SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n    @notice Inherit this to allow for rescuing ERC20 tokens sent to the contract in error.\n */\nabstract contract Rescuable {\n    using SafeERC20 for IERC20;\n\n    /**\n        @notice Rescues ERC20 tokens sent to the contract in error.\n        @dev Need to implement {_authorizeRescue} to do access-control for this function.\n        @param token The ERC20 token to rescue\n        @param target The address to send the tokens to\n     */\n    function rescue(address token, address target) external virtual {\n        // make sure we're not stealing funds or something\n        _authorizeRescue(token, target);\n\n        // transfer token to target\n        IERC20 tokenContract = IERC20(token);\n        tokenContract.safeTransfer(\n            target,\n            tokenContract.balanceOf(address(this))\n        );\n    }\n\n    /**\n        @dev Should revert if the rescue call should be stopped.\n        @param token The ERC20 token to rescue\n        @param target The address to send the tokens to\n     */\n    function _authorizeRescue(address token, address target) internal virtual;\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/libs/Sponsorable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {SafeERC20} from \"./SafeERC20.sol\";\n\n/**\n    @notice Add support for meta-txs that use ERC20 tokens to pay for gas\n */\nabstract contract Sponsorable {\n    using SafeERC20 for IERC20;\n\n    /**\n        @dev Using uint256 for all numbers since this struct won't ever be in storage. This saves gas.\n        @param sender The user who made the meta-tx\n        @param sponsor The account that should receive the sponsor fee\n        @param sponsorFeeToken The ERC20 token address the sponsor fee is paid in\n        @param sponsorFeeAmount The amount of sponsor fee to transfer from `sender` to `sponsor`\n        @param nonce The signature nonce used for preventing replay attacks. Should equal accountNonce[sender].\n        @param deadline The timestamp after which the signature is invalid\n        @param v ECDSA signature component: Parity of the `y` coordinate of point `R`\n        @param r ECDSA signature component: x-coordinate of `R`\n        @param s ECDSA signature component: `s` value of the signature\n     */\n    struct Sponsorship {\n        address sender;\n        address sponsor;\n        address sponsorFeeToken;\n        uint256 sponsorFeeAmount;\n        uint256 nonce;\n        uint256 deadline;\n        uint256 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    mapping(address => uint256) public accountNonce;\n\n    /**\n        @dev Use this for functions that should support meta-txs.\n        @param sponsorship The sponsorship information\n        @param funcSignature The function signature (selector) of the function being called\n        @param encodedParams The parameters of the function, encoded using abi.encode()\n     */\n    modifier sponsored(\n        Sponsorship memory sponsorship,\n        bytes4 funcSignature,\n        bytes memory encodedParams\n    ) {\n        _validateSponsorship(sponsorship, funcSignature, encodedParams);\n        _paySponsor(\n            sponsorship.sender,\n            sponsorship.sponsor,\n            sponsorship.sponsorFeeToken,\n            sponsorship.sponsorFeeAmount\n        );\n        _;\n    }\n\n    /**\n        @dev Validates the signature of a meta-tx sponsorship, reverts if the signature is invalid.\n        @param sponsorship The sponsorship information\n        @param funcSignature The function signature (selector) of the function being called\n        @param encodedParams The parameters of the function, encoded using abi.encode()\n     */\n    function _validateSponsorship(\n        Sponsorship memory sponsorship,\n        bytes4 funcSignature,\n        bytes memory encodedParams\n    ) internal virtual {\n        require(\n            sponsorship.nonce == accountNonce[sponsorship.sender],\n            \"Sponsorable: BAD_NONCE\"\n        );\n        require(\n            block.timestamp <= sponsorship.deadline,\n            \"Sponsorable: SIG_DEAD\"\n        );\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    keccak256(\n                        abi.encodePacked(\n                            abi.encode(\n                                chainId,\n                                address(this),\n                                sponsorship.sponsor,\n                                sponsorship.sponsorFeeToken,\n                                sponsorship.sponsorFeeAmount,\n                                sponsorship.nonce,\n                                sponsorship.deadline,\n                                funcSignature\n                            ),\n                            encodedParams\n                        )\n                    )\n                )\n            );\n\n        address recoveredAddress =\n            ECDSA.recover(\n                digest,\n                uint8(sponsorship.v),\n                sponsorship.r,\n                sponsorship.s\n            );\n        require(\n            recoveredAddress != address(0) &&\n                recoveredAddress == sponsorship.sender,\n            \"Sponsorable: BAD_SIG\"\n        );\n\n        // update nonce\n        accountNonce[sponsorship.sender] = sponsorship.nonce + 1;\n    }\n\n    /**\n        @dev Transfers `sponsorFeeAmount` of ERC20 token `sponsorFeeToken` from `sender` to `sponsor`.\n        @param sender The user who made the meta-tx\n        @param sponsor The account that should receive the sponsor fee\n        @param sponsorFeeToken The ERC20 token address the sponsor fee is paid in\n        @param sponsorFeeAmount The amount of sponsor fee to transfer from `sender` to `sponsor`\n     */\n    function _paySponsor(\n        address sender,\n        address sponsor,\n        address sponsorFeeToken,\n        uint256 sponsorFeeAmount\n    ) internal virtual {\n        if (sponsorFeeAmount == 0) {\n            return;\n        }\n\n        IERC20 token = IERC20(sponsorFeeToken);\n\n        // transfer tokens from sender\n        token.safeTransferFrom(sender, address(this), sponsorFeeAmount);\n\n        // transfer tokens to sponsor\n        token.safeTransfer(sponsor, sponsorFeeAmount);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if(!hasRole(role, account)) {\n            revert(string(abi.encodePacked(\n                \"AccessControl: account \",\n                StringsUpgradeable.toHexString(uint160(account), 20),\n                \" is missing role \",\n                StringsUpgradeable.toHexString(uint256(role), 32)\n            )));\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorageUpgradeable is Initializable, ERC721Upgradeable {\n    function __ERC721URIStorage_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721URIStorage_init_unchained();\n    }\n\n    function __ERC721URIStorage_init_unchained() internal initializer {\n    }\n    using StringsUpgradeable for uint256;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping (uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping (address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Upgradeable).interfaceId\n            || interfaceId == type(IERC721MetadataUpgradeable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n            : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/libs/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {\n    IERC1155Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport {\n    IERC1155ReceiverUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport {\n    IERC1155MetadataURIUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport {\n    AddressUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {\n    ContextUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport {\n    ERC165Upgradeable,\n    IERC165Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {\n    Initializable\n} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is\n    Initializable,\n    ContextUpgradeable,\n    ERC165Upgradeable,\n    IERC1155Upgradeable,\n    IERC1155MetadataURIUpgradeable\n{\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal initializer {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            account != address(0),\n            \"ERC1155: balance query for the zero address\"\n        );\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(\n            accounts.length == ids.length,\n            \"ERC1155: accounts and ids length mismatch\"\n        );\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        require(\n            _msgSender() != operator,\n            \"ERC1155: setting approval status for self\"\n        );\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            from,\n            to,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        uint256 fromBalance = _balances[id][from];\n        require(\n            fromBalance >= amount,\n            \"ERC1155: insufficient balance for transfer\"\n        );\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(\n                fromBalance >= amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            address(0),\n            account,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(\n            operator,\n            address(0),\n            account,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            address(0),\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            account,\n            address(0),\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            \"\"\n        );\n\n        uint256 accountBalance = _balances[id][account];\n        require(\n            accountBalance >= amount,\n            \"ERC1155: burn amount exceeds balance\"\n        );\n        _balances[id][account] = accountBalance - amount;\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(\n                accountBalance >= amount,\n                \"ERC1155: burn amount exceeds balance\"\n            );\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n        @dev Override this to return true to skip checking to.onERC1155Received during\n             single transfers.\n     */\n    function _shouldSkipSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual returns (bool) {\n        return false;\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (\n            to.isContract() &&\n            !_shouldSkipSafeTransferAcceptanceCheck(\n                operator,\n                from,\n                to,\n                id,\n                amount,\n                data\n            )\n        ) {\n            try\n                IERC1155ReceiverUpgradeable(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response !=\n                    IERC1155ReceiverUpgradeable(to).onERC1155Received.selector\n                ) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response !=\n                    IERC1155ReceiverUpgradeable(to)\n                        .onERC1155BatchReceived\n                        .selector\n                ) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element)\n        private\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n\n    uint256[47] private __gap;\n}\n"
    },
    "contracts/libs/ERC1155DividendToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {\n    SafeCastUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"./SafeERC20.sol\";\nimport {ERC1155Base} from \"./ERC1155Base.sol\";\n\n/**\n    @notice An extension of ERC1155Base that allows distributing dividends to all holders\n            of an token ID. Also supports multiple dividend tokens.\n */\nabstract contract ERC1155DividendToken is ERC1155Base {\n    using SafeERC20 for IERC20;\n    using SafeCastUpgradeable for uint256;\n    using SafeCastUpgradeable for int256;\n\n    struct DividendTokenData {\n        address dividendToken;\n        mapping(uint256 => uint256) magnifiedDividendPerShare;\n        // About dividendCorrection:\n        // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\n        //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\n        // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\n        //   `dividendOf(_user)` should not be changed,\n        //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\n        // To keep the `dividendOf(_user)` unchanged, we add a correction term:\n        //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\n        //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\n        //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\n        // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\n        mapping(uint256 => mapping(address => int256)) magnifiedDividendCorrections;\n        mapping(uint256 => mapping(address => uint256)) withdrawnDividends;\n    }\n\n    // With `magnitude`, we can properly distribute dividends even if the amount of received target is small.\n    // For more discussion about choosing the value of `magnitude`,\n    //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n    uint256 internal constant magnitude = 2**128;\n\n    /**\n        @notice The list of tokens that can be distributed to token holders as dividend. 1-indexed.\n     */\n    mapping(uint256 => DividendTokenData) public dividendTokenDataList;\n    uint256 public dividendTokenDataListLength;\n    /**\n        @notice The dividend token address to its key in {dividendTokenDataList}\n     */\n    mapping(address => uint256) public dividendTokenToDataID;\n\n    /// @dev This event MUST emit when target is distributed to token holders.\n    /// @param from The address which sends target to this contract.\n    /// @param weiAmount The amount of distributed target in wei.\n    event DividendsDistributed(\n        uint256 indexed tokenID,\n        address indexed from,\n        address indexed dividendToken,\n        uint256 weiAmount\n    );\n\n    /// @dev This event MUST emit when an address withdraws their dividend.\n    /// @param to The address which withdraws target from this contract.\n    /// @param weiAmount The amount of withdrawn target in wei.\n    event DividendWithdrawn(\n        uint256 indexed tokenID,\n        address indexed to,\n        address indexed dividendToken,\n        uint256 weiAmount\n    );\n\n    function __ERC1155DividendToken_init(\n        address[] memory dividendTokens,\n        address admin,\n        string memory uri\n    ) internal initializer {\n        __ERC1155Base_init(admin, uri);\n        __ERC1155DividendToken_init_unchained(dividendTokens);\n    }\n\n    function __ERC1155DividendToken_init_unchained(\n        address[] memory dividendTokens\n    ) internal initializer {\n        dividendTokenDataListLength = dividendTokens.length;\n        for (uint256 i = 0; i < dividendTokens.length; i++) {\n            dividendTokenDataList[i + 1].dividendToken = dividendTokens[i];\n            dividendTokenToDataID[dividendTokens[i]] = i + 1;\n        }\n    }\n\n    /**\n        Public getters\n     */\n\n    /// @notice View the amount of dividend in wei that an address can withdraw.\n    /// @param tokenID The token's ID.\n    /// @param dividendToken The token the dividend is in\n    /// @param _owner The address of a token holder.\n    /// @return The amount of dividend in wei that `_owner` can withdraw.\n    function dividendOf(\n        uint256 tokenID,\n        address dividendToken,\n        address _owner\n    ) public view returns (uint256) {\n        return _withdrawableDividendOf(tokenID, dividendToken, _owner);\n    }\n\n    /// @notice View the amount of dividend in wei that an address has withdrawn.\n    /// @param tokenID The token's ID.\n    /// @param dividendToken The token the dividend is in\n    /// @param _owner The address of a token holder.\n    /// @return The amount of dividend in wei that `_owner` has withdrawn.\n    function withdrawnDividendOf(\n        uint256 tokenID,\n        address dividendToken,\n        address _owner\n    ) public view returns (uint256) {\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\n        if (dividendTokenDataID == 0) {\n            return 0;\n        }\n        DividendTokenData storage data =\n            dividendTokenDataList[dividendTokenDataID];\n        return data.withdrawnDividends[tokenID][_owner];\n    }\n\n    /// @notice View the amount of dividend in wei that an address has earned in total.\n    /// @dev accumulativeDividendOf(_owner) = _withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\n    /// = (magnifiedDividendPerShare * balanceOf(_owner) + magnifiedDividendCorrections[_owner]) / magnitude\n    /// @param tokenID The token's ID.\n    /// @param dividendToken The token the dividend is in\n    /// @param _owner The address of a token holder.\n    /// @return The amount of dividend in wei that `_owner` has earned in total.\n    function accumulativeDividendOf(\n        uint256 tokenID,\n        address dividendToken,\n        address _owner\n    ) public view returns (uint256) {\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\n        if (dividendTokenDataID == 0) {\n            return 0;\n        }\n        DividendTokenData storage data =\n            dividendTokenDataList[dividendTokenDataID];\n        return\n            ((data.magnifiedDividendPerShare[tokenID] *\n                balanceOf(_owner, tokenID))\n                .toInt256() +\n                data.magnifiedDividendCorrections[tokenID][_owner])\n                .toUint256() / magnitude;\n    }\n\n    /**\n        Internal functions\n     */\n\n    /// @notice View the amount of dividend in wei that an address can withdraw.\n    /// @param tokenID The token's ID.\n    /// @param dividendToken The token the dividend is in\n    /// @param _owner The address of a token holder.\n    /// @return The amount of dividend in wei that `_owner` can withdraw.\n    function _withdrawableDividendOf(\n        uint256 tokenID,\n        address dividendToken,\n        address _owner\n    ) internal view returns (uint256) {\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\n        if (dividendTokenDataID == 0) {\n            return 0;\n        }\n        DividendTokenData storage data =\n            dividendTokenDataList[dividendTokenDataID];\n        return\n            accumulativeDividendOf(tokenID, dividendToken, _owner) -\n            data.withdrawnDividends[tokenID][_owner];\n    }\n\n    /// @notice Distributes target to token holders as dividends.\n    /// @dev It reverts if the total supply of tokens is 0.\n    /// It emits the `DividendsDistributed` event if the amount of received target is greater than 0.\n    /// About undistributed target tokens:\n    ///   In each distribution, there is a small amount of target not distributed,\n    ///     the magnified amount of which is\n    ///     `(amount * magnitude) % totalSupply()`.\n    ///   With a well-chosen `magnitude`, the amount of undistributed target\n    ///     (de-magnified) in a distribution can be less than 1 wei.\n    ///   We can actually keep track of the undistributed target in a distribution\n    ///     and try to distribute it in the next distribution,\n    ///     but keeping track of such data on-chain costs much more than\n    ///     the saved target, so we don't do that.\n    function _distributeDividends(\n        uint256 tokenID,\n        address dividendToken,\n        uint256 amount\n    ) internal {\n        uint256 tokenTotalSupply = totalSupply(tokenID);\n        require(tokenTotalSupply > 0);\n        require(amount > 0);\n\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\n        require(\n            dividendTokenDataID != 0,\n            \"ERC1155DividendToken: invalid dividendToken\"\n        );\n        DividendTokenData storage data =\n            dividendTokenDataList[dividendTokenDataID];\n\n        data.magnifiedDividendPerShare[tokenID] +=\n            (amount * magnitude) /\n            tokenTotalSupply;\n\n        IERC20(dividendToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        emit DividendsDistributed(tokenID, msg.sender, dividendToken, amount);\n    }\n\n    /// @notice Withdraws the target distributed to the sender.\n    /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn target is greater than 0.\n    function _withdrawDividend(\n        uint256 tokenID,\n        address dividendToken,\n        address user\n    ) internal {\n        uint256 _withdrawableDividend =\n            _withdrawableDividendOf(tokenID, dividendToken, user);\n        if (_withdrawableDividend > 0) {\n            uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\n            require(\n                dividendTokenDataID != 0,\n                \"ERC1155DividendToken: invalid dividendToken\"\n            );\n            DividendTokenData storage data =\n                dividendTokenDataList[dividendTokenDataID];\n            data.withdrawnDividends[tokenID][user] += _withdrawableDividend;\n            emit DividendWithdrawn(\n                tokenID,\n                user,\n                dividendToken,\n                _withdrawableDividend\n            );\n            IERC20(dividendToken).safeTransfer(user, _withdrawableDividend);\n        }\n    }\n\n    function _registerDividendToken(address dividendToken)\n        internal\n        returns (uint256 newDividendTokenDataID)\n    {\n        require(\n            dividendTokenToDataID[dividendToken] == 0,\n            \"ERC1155DividendToken: already registered\"\n        );\n        dividendTokenDataListLength++;\n        newDividendTokenDataID = dividendTokenDataListLength;\n        dividendTokenDataList[newDividendTokenDataID]\n            .dividendToken = dividendToken;\n        dividendTokenToDataID[dividendToken] = newDividendTokenDataID;\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155Base) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            // Mint\n            for (uint256 i = 0; i < ids.length; i++) {\n                uint256 tokenID = ids[i];\n                uint256 amount = amounts[i];\n\n                for (uint256 j = 1; j <= dividendTokenDataListLength; j++) {\n                    DividendTokenData storage dividendTokenData =\n                        dividendTokenDataList[j];\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\n                        to\n                    ] -= (dividendTokenData.magnifiedDividendPerShare[tokenID] *\n                        amount)\n                        .toInt256();\n                }\n            }\n        } else if (to == address(0)) {\n            // Burn\n            for (uint256 i = 0; i < ids.length; i++) {\n                uint256 tokenID = ids[i];\n                uint256 amount = amounts[i];\n\n                for (uint256 j = 1; j <= dividendTokenDataListLength; j++) {\n                    DividendTokenData storage dividendTokenData =\n                        dividendTokenDataList[j];\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\n                        from\n                    ] += (dividendTokenData.magnifiedDividendPerShare[tokenID] *\n                        amount)\n                        .toInt256();\n                }\n            }\n        } else {\n            // Transfer\n            for (uint256 i = 0; i < ids.length; i++) {\n                uint256 tokenID = ids[i];\n                uint256 amount = amounts[i];\n\n                for (uint256 j = 1; j <= dividendTokenDataListLength; j++) {\n                    DividendTokenData storage dividendTokenData =\n                        dividendTokenDataList[j];\n                    int256 _magCorrection =\n                        (dividendTokenData.magnifiedDividendPerShare[tokenID] *\n                            amount)\n                            .toInt256();\n                    // Retain the rewards\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\n                        from\n                    ] += _magCorrection;\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\n                        to\n                    ] -= _magCorrection;\n                }\n            }\n        }\n    }\n\n    uint256[47] private __gap;\n}\n"
    },
    "contracts/libs/WrappedERC1155Token.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {\n    ClonesUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport {\n    StringsUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport {ERC1155Upgradeable} from \"./ERC1155Upgradeable.sol\";\nimport {ERC1155Base} from \"./ERC1155Base.sol\";\nimport {ERC20Wrapper} from \"./ERC20Wrapper.sol\";\n\n/**\n    @notice An ERC-1155 multitoken where each ID is wrapped in an ERC-20 interface\n */\nabstract contract WrappedERC1155Token is ERC1155Base {\n    using ClonesUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    mapping(uint256 => address) public tokenIDToWrapper;\n    address public wrapperTemplate;\n    bool public deployWrapperOnMint;\n    string public baseName;\n    string public baseSymbol;\n    uint8 public decimals;\n\n    function __WrappedERC1155Token_init(\n        address admin,\n        string memory uri,\n        address _wrapperTemplate,\n        bool _deployWrapperOnMint,\n        string memory _baseName,\n        string memory _baseSymbol,\n        uint8 _decimals\n    ) internal initializer {\n        __ERC1155Base_init(admin, uri);\n        __WrappedERC1155Token_init_unchained(\n            _wrapperTemplate,\n            _deployWrapperOnMint,\n            _baseName,\n            _baseSymbol,\n            _decimals\n        );\n    }\n\n    function __WrappedERC1155Token_init_unchained(\n        address _wrapperTemplate,\n        bool _deployWrapperOnMint,\n        string memory _baseName,\n        string memory _baseSymbol,\n        uint8 _decimals\n    ) internal initializer {\n        wrapperTemplate = _wrapperTemplate;\n        deployWrapperOnMint = _deployWrapperOnMint;\n        baseName = _baseName;\n        baseSymbol = _baseSymbol;\n        decimals = _decimals;\n    }\n\n    /**\n        @notice Called by an ERC20Wrapper contract to handle a transfer call.\n        @dev Only callable by a wrapper deployed by this contract.\n        @param from Source of transfer\n        @param to Target of transfer\n        @param tokenID The ERC-1155 token ID of the wrapper\n        @param amount The amount to transfer\n     */\n    function wrapperTransfer(\n        address from,\n        address to,\n        uint256 tokenID,\n        uint256 amount\n    ) external {\n        require(\n            msg.sender == tokenIDToWrapper[tokenID],\n            \"WrappedERC1155Token: not wrapper\"\n        );\n        _safeTransferFrom(from, to, tokenID, amount, bytes(\"\"));\n    }\n\n    /**\n        @notice Deploys an ERC20Wrapper contract for the ERC-1155 tokens with ID `tokenID`.\n        @dev If a wrapper already exists for this tokenID, does nothing and returns the address\n             of the existing wrapper.\n        @param tokenID The ID of the token to wrap\n        @return wrapperAddress The address of the wrapper\n     */\n    function deployWrapper(uint256 tokenID)\n        external\n        returns (address wrapperAddress)\n    {\n        return _deployWrapper(tokenID);\n    }\n\n    /**\n        @dev See {deployWrapper}\n     */\n    function _deployWrapper(uint256 tokenID)\n        internal\n        returns (address wrapperAddress)\n    {\n        wrapperAddress = tokenIDToWrapper[tokenID];\n        if (wrapperAddress == address(0)) {\n            // deploy wrapper\n            ERC20Wrapper wrapper = ERC20Wrapper(wrapperTemplate.clone());\n            string memory tokenIDString = tokenID.toString();\n            string memory name =\n                string(abi.encodePacked(baseName, tokenIDString));\n            string memory symbol =\n                string(abi.encodePacked(baseSymbol, tokenIDString));\n            wrapper.initialize(address(this), tokenID, name, symbol, decimals);\n            tokenIDToWrapper[tokenID] = address(wrapper);\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            // Mint\n            if (deployWrapperOnMint) {\n                for (uint256 i = 0; i < ids.length; i++) {\n                    _deployWrapper(ids[i]);\n                }\n            }\n        }\n\n        // Emit transfer event in wrapper\n        for (uint256 i = 0; i < ids.length; i++) {\n            address wrapperAddress = tokenIDToWrapper[ids[i]];\n            if (wrapperAddress != address(0)) {\n                ERC20Wrapper wrapper = ERC20Wrapper(wrapperAddress);\n                wrapper.emitTransferEvent(from, to, amounts[i]);\n            }\n        }\n    }\n\n    /**\n        @dev See {ERC1155Upgradeable._shouldSkipSafeTransferAcceptanceCheck}\n     */\n    function _shouldSkipSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override(ERC1155Upgradeable) returns (bool) {\n        address wrapperAddress = tokenIDToWrapper[id];\n        if (wrapperAddress != address(0)) {\n            // has wrapper, check if operator is the wrapper\n            return operator == wrapperAddress;\n        } else {\n            // no wrapper, should do safety checks\n            return false;\n        }\n    }\n\n    /**\n        Param setters (need metadata role)\n     */\n    function setDeployWrapperOnMint(bool newValue) external {\n        require(\n            hasRole(METADATA_ROLE, msg.sender),\n            \"WrappedERC1155Token: no metadata role\"\n        );\n        deployWrapperOnMint = newValue;\n    }\n\n    function setBaseName(string calldata newValue) external {\n        require(\n            hasRole(METADATA_ROLE, msg.sender),\n            \"WrappedERC1155Token: no metadata role\"\n        );\n        baseName = newValue;\n    }\n\n    function setBaseSymbol(string calldata newValue) external {\n        require(\n            hasRole(METADATA_ROLE, msg.sender),\n            \"WrappedERC1155Token: no metadata role\"\n        );\n        baseSymbol = newValue;\n    }\n\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/libs/ERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC1155Upgradeable} from \"./ERC1155Upgradeable.sol\";\nimport {\n    AccessControlUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\n/**\n    @notice An extension of ERC1155 that provides access-controlled minting and burning,\n            as well as a total supply getter for each token ID.\n */\nabstract contract ERC1155Base is ERC1155Upgradeable, AccessControlUpgradeable {\n    bytes32 public constant MINTER_BURNER_ROLE =\n        keccak256(\"MINTER_BURNER_ROLE\");\n    bytes32 public constant METADATA_ROLE = keccak256(\"METADATA_ROLE\");\n    bytes internal constant NULL_BYTES = bytes(\"\");\n\n    mapping(uint256 => uint256) private _totalSupply;\n\n    function __ERC1155Base_init(address admin, string memory uri)\n        internal\n        initializer\n    {\n        __ERC1155_init(uri);\n        __ERC1155Base_init_unchained(admin);\n    }\n\n    function __ERC1155Base_init_unchained(address admin) internal initializer {\n        // admin is granted metadata role and minter-burner role\n        // metadata role is managed by itself\n        // minter-burner role is managed by itself\n        _setupRole(METADATA_ROLE, admin);\n        _setupRole(MINTER_BURNER_ROLE, admin);\n        _setRoleAdmin(METADATA_ROLE, METADATA_ROLE);\n        _setRoleAdmin(MINTER_BURNER_ROLE, MINTER_BURNER_ROLE);\n    }\n\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) external {\n        require(\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\n            \"ERC1155Base: must have minter-burner role to mint\"\n        );\n\n        _mint(to, id, amount, NULL_BYTES);\n    }\n\n    function mintBatch(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\n            \"ERC1155Base: must have minter-burner role to mint\"\n        );\n\n        _mintBatch(to, ids, amounts, NULL_BYTES);\n    }\n\n    function burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) external {\n        require(\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\n            \"ERC1155Base: must have minter-burner role to burn\"\n        );\n\n        _burn(account, id, amount);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\n            \"ERC1155Base: must have minter-burner role to burn\"\n        );\n\n        _burnBatch(account, ids, amounts);\n    }\n\n    function setURI(string calldata newuri) external {\n        require(\n            hasRole(METADATA_ROLE, _msgSender()),\n            \"ERC1155Base: must have metadata role to set URI\"\n        );\n\n        _setURI(newuri);\n    }\n\n    function totalSupply(uint256 id) public view returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    function totalSupplyBatch(uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory totalSupplies)\n    {\n        totalSupplies = new uint256[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            totalSupplies[i] = _totalSupply[ids[i]];\n        }\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155Upgradeable) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            // Mint\n            for (uint256 i = 0; i < ids.length; i++) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        } else if (to == address(0)) {\n            // Burn\n            for (uint256 i = 0; i < ids.length; i++) {\n                _totalSupply[ids[i]] -= amounts[i];\n            }\n        }\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/libs/ERC20Wrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    Initializable\n} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {WrappedERC1155Token} from \"./WrappedERC1155Token.sol\";\n\n/**\n    @notice An ERC-20 wrapper for a particular tokenID of an ERC-1155 token\n */\ncontract ERC20Wrapper is Initializable, IERC20 {\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    WrappedERC1155Token public parentMultitoken;\n    uint256 public tokenID;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    function initialize(\n        address _parentMultitoken,\n        uint256 _tokenID,\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals\n    ) external virtual initializer {\n        parentMultitoken = WrappedERC1155Token(_parentMultitoken);\n        tokenID = _tokenID;\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view virtual override returns (uint256) {\n        return parentMultitoken.totalSupply(tokenID);\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return parentMultitoken.balanceOf(account, tokenID);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        external\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20Wrapper: transfer amount exceeds allowance\"\n        );\n        _approve(sender, msg.sender, currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        external\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20Wrapper: decreased allowance below zero\"\n        );\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n        @dev Only callable by the parentMultitoken. Emits a transfer event when the parent token\n             is transferred.\n     */\n    function emitTransferEvent(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        require(\n            msg.sender == address(parentMultitoken),\n            \"ERC20Wrapper: not parent\"\n        );\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        parentMultitoken.wrapperTransfer(\n            msg.sender,\n            recipient,\n            tokenID,\n            amount\n        );\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(\n            owner != address(0),\n            \"ERC20Wrapper: approve from the zero address\"\n        );\n        require(\n            spender != address(0),\n            \"ERC20Wrapper: approve to the zero address\"\n        );\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/rewards/Vesting02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"../libs/SafeERC20.sol\";\nimport {\n    ERC721URIStorageUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    MathUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {MPHMinter} from \"./MPHMinter.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {DecMath} from \"../libs/DecMath.sol\";\n\ncontract Vesting02 is ERC721URIStorageUpgradeable, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using DecMath for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n\n    struct Vest {\n        address pool;\n        uint64 depositID;\n        uint64 lastUpdateTimestamp;\n        uint256 accumulatedAmount;\n        uint256 withdrawnAmount;\n        uint256 vestAmountPerStablecoinPerSecond;\n    }\n    Vest[] public vestList;\n    mapping(address => mapping(uint64 => uint64)) public depositIDToVestID;\n\n    MPHMinter public mphMinter;\n    IERC20 public token;\n    string internal _contractURI;\n    string internal __baseURI;\n\n    event ECreateVest(\n        address indexed to,\n        address indexed pool,\n        uint64 depositID,\n        uint64 vestID,\n        uint256 vestAmountPerStablecoinPerSecond\n    );\n    event EUpdateVest(\n        uint64 indexed vestID,\n        address poolAddress,\n        uint64 depositID,\n        uint256 currentDepositAmount,\n        uint256 depositAmount,\n        uint256 vestAmountPerStablecoinPerSecond\n    );\n    event EWithdraw(\n        address indexed sender,\n        uint64 indexed vestID,\n        uint256 withdrawnAmount\n    );\n    event ESetMPHMinter(address newValue);\n    event EBoost(\n        uint64 indexed vestID,\n        uint256 vestAmountPerStablecoinPerSecond\n    );\n\n    function initialize(\n        address _token,\n        string calldata tokenName,\n        string calldata tokenSymbol\n    ) external initializer {\n        __Ownable_init();\n        __ERC721_init(tokenName, tokenSymbol);\n\n        token = IERC20(_token);\n    }\n\n    function setMPHMinter(address newValue) external onlyOwner {\n        require(newValue != address(0), \"Vesting02: 0 address\");\n        mphMinter = MPHMinter(newValue);\n        emit ESetMPHMinter(newValue);\n    }\n\n    /**\n        MPHMinter only functions\n     */\n\n    function createVestForDeposit(\n        address to,\n        address pool,\n        uint64 depositID,\n        uint256 vestAmountPerStablecoinPerSecond\n    ) external returns (uint64 vestID) {\n        require(\n            address(msg.sender) == address(mphMinter),\n            \"Vesting02: not minter\"\n        );\n\n        // create vest object\n        require(block.timestamp <= type(uint64).max, \"Vesting02: OVERFLOW\");\n        vestList.push(\n            Vest({\n                pool: pool,\n                depositID: depositID,\n                lastUpdateTimestamp: uint64(block.timestamp),\n                accumulatedAmount: 0,\n                withdrawnAmount: 0,\n                vestAmountPerStablecoinPerSecond: vestAmountPerStablecoinPerSecond\n            })\n        );\n        require(vestList.length <= type(uint64).max, \"Vesting02: OVERFLOW\");\n        vestID = uint64(vestList.length); // 1-indexed\n        depositIDToVestID[pool][depositID] = vestID;\n\n        // mint NFT\n        _safeMint(to, vestID);\n\n        emit ECreateVest(\n            to,\n            pool,\n            depositID,\n            vestID,\n            vestAmountPerStablecoinPerSecond\n        );\n    }\n\n    function updateVestForDeposit(\n        address poolAddress,\n        uint64 depositID,\n        uint256 currentDepositAmount,\n        uint256 depositAmount,\n        uint256 vestAmountPerStablecoinPerSecond\n    ) external {\n        require(\n            address(msg.sender) == address(mphMinter),\n            \"Vesting02: not minter\"\n        );\n\n        uint64 vestID = depositIDToVestID[poolAddress][depositID];\n        Vest storage vestEntry = _getVest(vestID);\n        DInterest pool = DInterest(poolAddress);\n        DInterest.Deposit memory depositEntry =\n            pool.getDeposit(vestEntry.depositID);\n        uint256 currentTimestamp =\n            MathUpgradeable.min(\n                block.timestamp,\n                depositEntry.maturationTimestamp\n            );\n        vestEntry.accumulatedAmount += (currentDepositAmount *\n            (currentTimestamp - vestEntry.lastUpdateTimestamp))\n            .decmul(vestEntry.vestAmountPerStablecoinPerSecond);\n        require(block.timestamp <= type(uint64).max, \"Vesting02: OVERFLOW\");\n        vestEntry.lastUpdateTimestamp = uint64(block.timestamp);\n        vestEntry.vestAmountPerStablecoinPerSecond =\n            (vestEntry.vestAmountPerStablecoinPerSecond *\n                currentDepositAmount +\n                vestAmountPerStablecoinPerSecond *\n                depositAmount) /\n            (currentDepositAmount + depositAmount);\n\n        emit EUpdateVest(\n            vestID,\n            poolAddress,\n            depositID,\n            currentDepositAmount,\n            depositAmount,\n            vestAmountPerStablecoinPerSecond\n        );\n    }\n\n    /**\n        Public action functions\n     */\n\n    function withdraw(uint64 vestID)\n        external\n        returns (uint256 withdrawnAmount)\n    {\n        return _withdraw(vestID);\n    }\n\n    function multiWithdraw(uint64[] memory vestIDList) external {\n        for (uint256 i = 0; i < vestIDList.length; i++) {\n            _withdraw(vestIDList[i]);\n        }\n    }\n\n    function _withdraw(uint64 vestID)\n        internal\n        returns (uint256 withdrawnAmount)\n    {\n        require(ownerOf(vestID) == msg.sender, \"Vesting02: not owner\");\n\n        // compute withdrawable amount\n        withdrawnAmount = _getVestWithdrawableAmount(vestID);\n        if (withdrawnAmount == 0) {\n            return 0;\n        }\n\n        // update vest object\n        Vest storage vestEntry = _getVest(vestID);\n        vestEntry.withdrawnAmount += withdrawnAmount;\n\n        // mint tokens to vest recipient\n        mphMinter.mintVested(msg.sender, withdrawnAmount);\n\n        emit EWithdraw(msg.sender, vestID, withdrawnAmount);\n    }\n\n    /**\n        Public getter functions\n     */\n\n    function getVestWithdrawableAmount(uint64 vestID)\n        external\n        view\n        returns (uint256)\n    {\n        return _getVestWithdrawableAmount(vestID);\n    }\n\n    function _getVestWithdrawableAmount(uint64 vestID)\n        internal\n        view\n        returns (uint256 withdrawableAmount)\n    {\n        // read vest data\n        Vest memory vestEntry = _getVest(vestID);\n        DInterest pool = DInterest(vestEntry.pool);\n        DInterest.Deposit memory depositEntry =\n            pool.getDeposit(vestEntry.depositID);\n\n        // compute vested amount\n        uint256 currentTimestamp =\n            MathUpgradeable.min(\n                block.timestamp,\n                depositEntry.maturationTimestamp\n            );\n        if (currentTimestamp < vestEntry.lastUpdateTimestamp) {\n            return vestEntry.accumulatedAmount - vestEntry.withdrawnAmount;\n        }\n        uint256 depositAmount =\n            depositEntry.virtualTokenTotalSupply.decdiv(\n                PRECISION + depositEntry.interestRate\n            );\n        return\n            vestEntry.accumulatedAmount +\n            (depositAmount * (currentTimestamp - vestEntry.lastUpdateTimestamp))\n                .decmul(vestEntry.vestAmountPerStablecoinPerSecond) -\n            vestEntry.withdrawnAmount;\n    }\n\n    function getVest(uint64 vestID) external view returns (Vest memory) {\n        return _getVest(vestID);\n    }\n\n    function _getVest(uint64 vestID) internal view returns (Vest storage) {\n        return vestList[vestID - 1];\n    }\n\n    function numVests() external view returns (uint256) {\n        return vestList.length;\n    }\n\n    /**\n        NFT metadata\n     */\n\n    function contractURI() external view returns (string memory) {\n        return _contractURI;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return __baseURI;\n    }\n\n    function setContractURI(string calldata newURI) external onlyOwner {\n        _contractURI = newURI;\n    }\n\n    function setTokenURI(uint256 tokenId, string calldata newURI) external {\n        require(ownerOf(tokenId) == msg.sender, \"Vesting02: not token owner\");\n        _setTokenURI(tokenId, newURI);\n    }\n\n    /**\n        Owner functions\n     */\n\n    function setBaseURI(string calldata newURI) external onlyOwner {\n        __baseURI = newURI;\n    }\n\n    function boost(uint64 vestID, uint256 vestAmountPerStablecoinPerSecond)\n        external\n        onlyOwner\n    {\n        _getVest(vestID)\n            .vestAmountPerStablecoinPerSecond = vestAmountPerStablecoinPerSecond;\n        emit EBoost(vestID, vestAmountPerStablecoinPerSecond);\n    }\n\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/rewards/MPHToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {\n    ERC20BurnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract MPHToken is\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    OwnableUpgradeable\n{\n    function initialize() external initializer {\n        __Ownable_init();\n        __ERC20Burnable_init();\n        __ERC20_init(\"88mph.app\", \"MPH\");\n    }\n\n    function ownerMint(address account, uint256 amount)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n        } else if (signature.length == 64) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let vs := mload(add(signature, 0x40))\n                r := mload(add(signature, 0x20))\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                v := add(shr(255, vs), 27)\n            }\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20Burnable_init_unchained();\n    }\n\n    function __ERC20Burnable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        _approve(account, _msgSender(), currentAllowance - amount);\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/zaps/ZapCurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"../libs/SafeERC20.sol\";\nimport {\n    ERC1155Receiver\n} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport {\n    IERC721Receiver\n} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {CurveZapIn} from \"./imports/CurveZapIn.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {NFT} from \"../tokens/NFT.sol\";\nimport {FundingMultitoken} from \"../tokens/FundingMultitoken.sol\";\nimport {Vesting02} from \"../rewards/Vesting02.sol\";\n\ncontract ZapCurve is ERC1155Receiver, IERC721Receiver {\n    using SafeERC20 for ERC20;\n\n    modifier active {\n        isActive = true;\n        _;\n        isActive = false;\n    }\n\n    CurveZapIn public constant zapper =\n        CurveZapIn(0xf9A724c2607E5766a7Bbe530D6a7e173532F9f3a);\n    bytes internal constant NULL_BYTES = bytes(\"\");\n    bool public isActive;\n\n    function zapCurveDeposit(\n        address pool,\n        address vesting,\n        address swapAddress,\n        address inputToken,\n        uint256 inputTokenAmount,\n        uint256 minOutputTokenAmount,\n        uint64 maturationTimestamp\n    ) external active {\n        DInterest poolContract = DInterest(pool);\n\n        // zap into curve\n        uint64 depositID;\n        {\n            uint256 outputTokenAmount =\n                _zapTokenInCurve(\n                    swapAddress,\n                    inputToken,\n                    inputTokenAmount,\n                    minOutputTokenAmount\n                );\n\n            // create deposit\n            poolContract.stablecoin().safeApprove(pool, outputTokenAmount);\n            (depositID, ) = poolContract.deposit(\n                outputTokenAmount,\n                maturationTimestamp\n            );\n        }\n\n        // transfer deposit multitokens to msg.sender\n        poolContract.depositNFT().safeTransferFrom(\n            address(this),\n            msg.sender,\n            depositID\n        );\n\n        // transfer vest token out\n        {\n            Vesting02 vestingContract = Vesting02(vesting);\n            vestingContract.safeTransferFrom(\n                address(this),\n                msg.sender,\n                vestingContract.depositIDToVestID(pool, depositID)\n            );\n        }\n    }\n\n    function zapCurveFund(\n        address pool,\n        address swapAddress,\n        address inputToken,\n        uint256 inputTokenAmount,\n        uint256 minOutputTokenAmount,\n        uint64 depositID\n    ) external active {\n        DInterest poolContract = DInterest(pool);\n        ERC20 stablecoin = poolContract.stablecoin();\n        FundingMultitoken fundingMultitoken = poolContract.fundingMultitoken();\n\n        // zap into curve\n        uint256 outputTokenAmount =\n            _zapTokenInCurve(\n                swapAddress,\n                inputToken,\n                inputTokenAmount,\n                minOutputTokenAmount\n            );\n\n        // create funding\n        stablecoin.safeApprove(pool, outputTokenAmount);\n        uint64 fundingID = poolContract.fund(depositID, outputTokenAmount);\n\n        // transfer funding multitoken to msg.sender\n        fundingMultitoken.safeTransferFrom(\n            address(this),\n            msg.sender,\n            fundingID,\n            fundingMultitoken.balanceOf(address(this), fundingID),\n            NULL_BYTES\n        );\n        // transfer remaining stablecoins to msg.sender\n        stablecoin.safeTransfer(\n            msg.sender,\n            stablecoin.balanceOf(address(this))\n        );\n    }\n\n    function onERC1155Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        uint256, /*value*/\n        bytes calldata /*data*/\n    ) external view override returns (bytes4) {\n        require(isActive, \"ZapCurve: inactive\");\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address, /*operator*/\n        address, /*from*/\n        uint256[] calldata, /*ids*/\n        uint256[] calldata, /*values*/\n        bytes calldata /*data*/\n    ) external view override returns (bytes4) {\n        require(isActive, \"ZapCurve: inactive\");\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    function onERC721Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*tokenId*/\n        bytes memory /*data*/\n    ) external view override returns (bytes4) {\n        require(isActive, \"ZapCurve: inactive\");\n        return this.onERC721Received.selector;\n    }\n\n    function _zapTokenInCurve(\n        address swapAddress,\n        address inputToken,\n        uint256 inputTokenAmount,\n        uint256 minOutputTokenAmount\n    ) internal returns (uint256 outputTokenAmount) {\n        ERC20 inputTokenContract = ERC20(inputToken);\n\n        // transfer inputToken from msg.sender\n        inputTokenContract.safeTransferFrom(\n            msg.sender,\n            address(this),\n            inputTokenAmount\n        );\n\n        // zap inputToken into curve\n        inputTokenContract.safeApprove(address(zapper), inputTokenAmount);\n        outputTokenAmount = zapper.ZapIn(\n            address(this),\n            inputToken,\n            swapAddress,\n            inputTokenAmount,\n            minOutputTokenAmount\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "contracts/zaps/imports/CurveZapIn.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\ninterface CurveZapIn {\n    /**\n        @notice This function adds liquidity to a Curve pool with ETH or ERC20 tokens\n        @param toWhomToIssue The address to return the Curve LP tokens to\n        @param fromToken The ERC20 token used for investment (address(0x00) if ether)\n        @param swapAddress Curve swap address for the pool\n        @param incomingTokenQty The amount of fromToken to invest\n        @param minPoolTokens The minimum acceptable quantity of tokens to receive. Reverts otherwise\n        @return crvTokensBought Amount of Curve LP tokens received\n    */\n    function ZapIn(\n        address toWhomToIssue,\n        address fromToken,\n        address swapAddress,\n        uint256 incomingTokenQty,\n        uint256 minPoolTokens\n    ) external payable returns (uint256 crvTokensBought);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/zero-coupon-bond/ZeroCouponBond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeERC20} from \"../libs/SafeERC20.sol\";\nimport {\n    IERC721ReceiverUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {NFT} from \"../tokens/NFT.sol\";\nimport {DInterest} from \"../DInterest.sol\";\nimport {Vesting02} from \"../rewards/Vesting02.sol\";\nimport {Sponsorable} from \"../libs/Sponsorable.sol\";\n\ncontract ZeroCouponBond is\n    ERC20Upgradeable,\n    ReentrancyGuardUpgradeable,\n    IERC721ReceiverUpgradeable,\n    Sponsorable\n{\n    using SafeERC20 for ERC20;\n\n    DInterest public pool;\n    ERC20 public stablecoin;\n    NFT public depositNFT;\n    Vesting02 public vesting;\n    uint64 public maturationTimestamp;\n    uint64 public depositID;\n    uint8 private _decimals;\n\n    event WithdrawDeposit();\n    event RedeemStablecoin(address indexed sender, uint256 amount);\n\n    function initialize(\n        address _creator,\n        address _pool,\n        address _vesting,\n        uint64 _maturationTimestamp,\n        uint256 _initialDepositAmount,\n        string calldata _tokenName,\n        string calldata _tokenSymbol\n    ) external initializer {\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __ReentrancyGuard_init();\n\n        pool = DInterest(_pool);\n        stablecoin = pool.stablecoin();\n        depositNFT = pool.depositNFT();\n        maturationTimestamp = _maturationTimestamp;\n        vesting = Vesting02(_vesting);\n\n        // set decimals to be the same as the underlying stablecoin\n        _decimals = pool.stablecoin().decimals();\n\n        // create deposit\n        stablecoin.safeTransferFrom(\n            _creator,\n            address(this),\n            _initialDepositAmount\n        );\n        stablecoin.safeApprove(address(pool), type(uint256).max);\n        uint256 interestAmount;\n        (depositID, interestAmount) = pool.deposit(\n            _initialDepositAmount,\n            maturationTimestamp\n        );\n        _mint(_creator, _initialDepositAmount + interestAmount);\n        vesting.safeTransferFrom(\n            address(this),\n            _creator,\n            vesting.depositIDToVestID(_pool, depositID)\n        );\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n        Public action functions\n     */\n    /**\n        @notice Mint zero coupon bonds by depositing `depositAmount` stablecoins.\n        @param depositAmount The amount to deposit for minting zero coupon bonds\n        @return mintedAmount The amount of bonds minted\n     */\n    function mint(uint256 depositAmount)\n        external\n        nonReentrant\n        returns (uint256 mintedAmount)\n    {\n        return _mintInternal(msg.sender, depositAmount);\n    }\n\n    /**\n        @notice Withdraws the underlying deposit from the DInterest pool.\n     */\n    function withdrawDeposit() external nonReentrant {\n        uint256 balance = pool.getDeposit(depositID).virtualTokenTotalSupply;\n        require(balance > 0, \"ZeroCouponBond: already withdrawn\");\n        pool.withdraw(depositID, balance, false);\n\n        emit WithdrawDeposit();\n    }\n\n    /**\n        @notice Redeems zero coupon bonds 1-for-1 for the underlying stablecoins.\n        @param amount The amount of zero coupon bonds to burn\n        @param withdrawDepositIfNeeded True if withdrawDeposit() should be called if needed, false otherwise (to save gas)\n     */\n    function redeem(uint256 amount, bool withdrawDepositIfNeeded)\n        external\n        nonReentrant\n    {\n        _redeem(msg.sender, amount, withdrawDepositIfNeeded);\n    }\n\n    /**\n        Sponsored action functions\n     */\n    /**\n        @dev See {mint}\n     */\n    function sponsoredMint(\n        uint256 depositAmount,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredMint.selector,\n            abi.encode(depositAmount)\n        )\n        returns (uint256 mintedAmount)\n    {\n        return _mintInternal(sponsorship.sender, depositAmount);\n    }\n\n    /**\n        @dev See {redeem}\n     */\n    function sponsoredRedeem(\n        uint256 amount,\n        bool withdrawDepositIfNeeded,\n        Sponsorship calldata sponsorship\n    )\n        external\n        nonReentrant\n        sponsored(\n            sponsorship,\n            this.sponsoredRedeem.selector,\n            abi.encode(amount, withdrawDepositIfNeeded)\n        )\n    {\n        _redeem(sponsorship.sender, amount, withdrawDepositIfNeeded);\n    }\n\n    /**\n        Public getter functions\n     */\n\n    /**\n        @notice Checks whether withdrawDeposit() needs to be called.\n        @return True if withdrawDeposit() should be called, false otherwise.\n     */\n    function withdrawDepositNeeded() external view returns (bool) {\n        return pool.getDeposit(depositID).virtualTokenTotalSupply > 0;\n    }\n\n    /**\n        Internal action functions\n     */\n\n    /**\n        @dev See {mint}\n     */\n    function _mintInternal(address sender, uint256 depositAmount)\n        internal\n        returns (uint256 mintedAmount)\n    {\n        // transfer stablecoins from `sender`\n        stablecoin.safeTransferFrom(sender, address(this), depositAmount);\n\n        // topup deposit\n        mintedAmount =\n            depositAmount +\n            pool.topupDeposit(depositID, depositAmount);\n\n        // mint zero coupon bonds to `msg.sender`\n        _mint(sender, mintedAmount);\n    }\n\n    /**\n        @dev See {redeem}\n     */\n    function _redeem(\n        address sender,\n        uint256 amount,\n        bool withdrawDepositIfNeeded\n    ) internal {\n        require(\n            block.timestamp >= maturationTimestamp,\n            \"ZeroCouponBond: not mature\"\n        );\n\n        if (withdrawDepositIfNeeded) {\n            uint256 balance =\n                pool.getDeposit(depositID).virtualTokenTotalSupply;\n            if (balance > 0) {\n                pool.withdraw(depositID, balance, false);\n                emit WithdrawDeposit();\n            }\n        }\n\n        // burn `amount` zero coupon bonds from `sender`\n        _burn(sender, amount);\n\n        // transfer `amount` stablecoins to `sender`\n        stablecoin.safeTransfer(sender, amount);\n\n        emit RedeemStablecoin(sender, amount);\n    }\n\n    function onERC721Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*tokenId*/\n        bytes memory /*data*/\n    ) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    uint256[43] private __gap;\n}\n"
    },
    "contracts/rewards/dumpers/OneSplitDumper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {OneSplitAudit} from \"./imports/OneSplitAudit.sol\";\nimport {xMPH} from \"../xMPH.sol\";\nimport {AdminControlled} from \"../../libs/AdminControlled.sol\";\n\ncontract OneSplitDumper is AdminControlled {\n    using SafeERC20 for IERC20;\n\n    OneSplitAudit public oneSplit;\n    xMPH public xMPHToken;\n    IERC20 public rewardToken;\n\n    constructor(address _oneSplit, address _xMPHToken) {\n        oneSplit = OneSplitAudit(_oneSplit);\n        xMPHToken = xMPH(_xMPHToken);\n        rewardToken = IERC20(address(xMPHToken.mph()));\n    }\n\n    function getDumpParams(address tokenAddress, uint256 parts)\n        external\n        view\n        returns (uint256 returnAmount, uint256[] memory distribution)\n    {\n        IERC20 token = IERC20(tokenAddress);\n        uint256 tokenBalance = token.balanceOf(address(this));\n        (returnAmount, distribution) = oneSplit.getExpectedReturn(\n            tokenAddress,\n            address(rewardToken),\n            tokenBalance,\n            parts,\n            0\n        );\n    }\n\n    function dump(\n        address tokenAddress,\n        uint256 returnAmount,\n        uint256[] calldata distribution\n    ) external onlyAdmin {\n        // dump token for rewardToken\n        IERC20 token = IERC20(tokenAddress);\n        uint256 tokenBalance = token.balanceOf(address(this));\n        token.safeApprove(address(oneSplit), tokenBalance);\n\n        uint256 rewardTokenBalanceBefore = rewardToken.balanceOf(address(this));\n        oneSplit.swap(\n            tokenAddress,\n            address(rewardToken),\n            tokenBalance,\n            returnAmount,\n            distribution,\n            0\n        );\n        uint256 rewardTokenBalanceAfter = rewardToken.balanceOf(address(this));\n        require(\n            rewardTokenBalanceAfter > rewardTokenBalanceBefore,\n            \"OneSplitDumper: receivedRewardTokenAmount == 0\"\n        );\n    }\n\n    function notify() external onlyAdmin {\n        uint256 balance = rewardToken.balanceOf(address(this));\n        rewardToken.safeApprove(address(xMPHToken), balance);\n        xMPHToken.distributeReward(balance);\n    }\n}\n"
    },
    "contracts/rewards/dumpers/imports/OneSplitAudit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\ninterface OneSplitAudit {\n    function swap(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata distribution,\n        uint256 flags\n    ) external payable;\n\n    function getExpectedReturn(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 flags // See constants in IOneSplit.sol\n    )\n        external\n        view\n        returns (uint256 returnAmount, uint256[] memory distribution);\n}\n"
    },
    "contracts/rewards/xMPH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {\n    AccessControlUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {DecMath} from \"../libs/DecMath.sol\";\n\n/**\n    @title Staked MPH\n    @author Zefram Lou\n    @notice The MPH staking contract\n */\ncontract xMPH is ERC20Upgradeable, AccessControlUpgradeable {\n    using DecMath for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n    uint256 internal constant MAX_REWARD_UNLOCK_PERIOD = 365 days;\n    bytes32 public constant DISTRIBUTOR_ROLE = keccak256(\"DISTRIBUTOR_ROLE\");\n    uint256 public constant MIN_AMOUNT = 10**9;\n\n    ERC20 public mph;\n    uint256 public rewardUnlockPeriod;\n    uint256 public currentUnlockEndTimestamp;\n    uint256 public lastRewardTimestamp;\n    uint256 public lastRewardAmount;\n\n    function __xMPH_init(\n        address _mph,\n        uint256 _rewardUnlockPeriod,\n        address _distributor\n    ) internal initializer {\n        __ERC20_init(\"Staked MPH\", \"xMPH\");\n        __AccessControl_init();\n        __xMPH_init_unchained(_mph, _rewardUnlockPeriod, _distributor);\n    }\n\n    function __xMPH_init_unchained(\n        address _mph,\n        uint256 _rewardUnlockPeriod,\n        address _distributor\n    ) internal initializer {\n        // Validate input\n        require(\n            _mph != address(0) && _distributor != address(0),\n            \"xMPH: 0 address\"\n        );\n        require(\n            _rewardUnlockPeriod > 0 &&\n                _rewardUnlockPeriod <= MAX_REWARD_UNLOCK_PERIOD,\n            \"xMPH: invalid _rewardUnlockPeriod\"\n        );\n\n        // _distributor and msg.sender are given DISTRIBUTOR_ROLE\n        // DISTRIBUTOR_ROLE is managed by itself\n        // msg.sender is given DEFAULT_ADMIN_ROLE which enables\n        // calling setRewardUnlockPeriod()\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(DISTRIBUTOR_ROLE, msg.sender);\n        _setupRole(DISTRIBUTOR_ROLE, _distributor);\n        _setRoleAdmin(DISTRIBUTOR_ROLE, DISTRIBUTOR_ROLE);\n        mph = ERC20(_mph);\n        rewardUnlockPeriod = _rewardUnlockPeriod;\n\n        // force the deployer to deposit to prevent rounding schenanigans\n        _deposit(MIN_AMOUNT);\n    }\n\n    /**\n        @param _mph The MPH token\n        @param _rewardUnlockPeriod The length of each reward distribution period, in seconds\n        @param _distributor The account that will call distributeReward()\n     */\n    function initialize(\n        address _mph,\n        uint256 _rewardUnlockPeriod,\n        address _distributor\n    ) external initializer {\n        __xMPH_init(_mph, _rewardUnlockPeriod, _distributor);\n    }\n\n    /**\n        @notice Deposit MPH to get xMPH\n        @dev The amount can't be 0\n        @param _mphAmount The amount of MPH to deposit\n        @return shareAmount The amount of xMPH minted\n     */\n    function deposit(uint256 _mphAmount)\n        external\n        virtual\n        returns (uint256 shareAmount)\n    {\n        return _deposit(_mphAmount);\n    }\n\n    /**\n        @notice Withdraw MPH using xMPH\n        @dev The amount can't be 0\n        @param _shareAmount The amount of xMPH to burn\n        @return mphAmount The amount of MPH withdrawn\n     */\n    function withdraw(uint256 _shareAmount)\n        external\n        virtual\n        returns (uint256 mphAmount)\n    {\n        return _withdraw(_shareAmount);\n    }\n\n    /**\n        @notice Compute the amount of MPH that can be withdrawn by burning\n                1 xMPH. Increases linearly during a reward distribution period.\n        @dev Initialized to be PRECISION (representing 1 MPH = 1 xMPH)\n        @return The amount of MPH that can be withdrawn by burning\n                1 xMPH\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 mphBalance = mph.balanceOf(address(this));\n        if (totalShares == 0 || mphBalance == 0) {\n            return PRECISION;\n        }\n        uint256 _lastRewardAmount = lastRewardAmount;\n        uint256 _currentUnlockEndTimestamp = currentUnlockEndTimestamp;\n        if (\n            _lastRewardAmount == 0 ||\n            block.timestamp >= _currentUnlockEndTimestamp\n        ) {\n            // no rewards or rewards fully unlocked\n            // entire balance is withdrawable\n            return mphBalance.decdiv(totalShares);\n        } else {\n            // rewards not fully unlocked\n            // deduct locked rewards from balance\n            uint256 _lastRewardTimestamp = lastRewardTimestamp;\n            uint256 lockedRewardAmount =\n                (_lastRewardAmount *\n                    (_currentUnlockEndTimestamp - block.timestamp)) /\n                    (_currentUnlockEndTimestamp - _lastRewardTimestamp);\n            return (mphBalance - lockedRewardAmount).decdiv(totalShares);\n        }\n    }\n\n    /**\n        @notice Distributes MPH rewards to xMPH holders\n        @dev When not in a distribution period, start a new one with rewardUnlockPeriod seconds.\n             When in a distribution period, add rewards to current period\n     */\n    function distributeReward(uint256 rewardAmount) external virtual {\n        _distributeReward(rewardAmount);\n    }\n\n    function setRewardUnlockPeriod(uint256 newValue) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"xMPH: not admin\");\n        require(\n            newValue > 0 && newValue <= MAX_REWARD_UNLOCK_PERIOD,\n            \"xMPH: invalid value\"\n        );\n        rewardUnlockPeriod = newValue;\n    }\n\n    /**\n        @dev See {deposit}\n     */\n    function _deposit(uint256 _mphAmount)\n        internal\n        virtual\n        returns (uint256 shareAmount)\n    {\n        require(_mphAmount > 0, \"xMPH: amount\");\n        shareAmount = _mphAmount.decdiv(getPricePerFullShare());\n        _mint(msg.sender, shareAmount);\n        mph.transferFrom(msg.sender, address(this), _mphAmount);\n    }\n\n    /**\n        @dev See {withdraw}\n     */\n    function _withdraw(uint256 _shareAmount)\n        internal\n        virtual\n        returns (uint256 mphAmount)\n    {\n        require(\n            totalSupply() >= _shareAmount + MIN_AMOUNT && _shareAmount > 0,\n            \"xMPH: amount\"\n        );\n        mphAmount = _shareAmount.decmul(getPricePerFullShare());\n        _burn(msg.sender, _shareAmount);\n        mph.transfer(msg.sender, mphAmount);\n    }\n\n    /**\n        @dev See {distributeReward}\n     */\n    function _distributeReward(uint256 rewardAmount) internal {\n        require(totalSupply() >= MIN_AMOUNT, \"xMPH: supply\");\n        require(rewardAmount >= MIN_AMOUNT, \"xMPH: reward\");\n        require(\n            rewardAmount < type(uint256).max / PRECISION,\n            \"xMPH: rewards too large, would lock\"\n        );\n        require(hasRole(DISTRIBUTOR_ROLE, msg.sender), \"xMPH: not distributor\");\n\n        // transfer rewards from sender\n        mph.transferFrom(msg.sender, address(this), rewardAmount);\n\n        if (block.timestamp >= currentUnlockEndTimestamp) {\n            // start new reward period\n            currentUnlockEndTimestamp = block.timestamp + rewardUnlockPeriod;\n            lastRewardTimestamp = block.timestamp;\n            lastRewardAmount = rewardAmount;\n        } else {\n            // add rewards to current reward period\n            uint256 lockedRewardAmount =\n                (lastRewardAmount *\n                    (currentUnlockEndTimestamp - block.timestamp)) /\n                    (currentUnlockEndTimestamp - lastRewardTimestamp);\n            lastRewardTimestamp = block.timestamp;\n            lastRewardAmount = rewardAmount + lockedRewardAmount;\n        }\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/libs/AdminControlled.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nabstract contract AdminControlled is AccessControl {\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier onlyAdmin {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender),\n            \"AdminControlled: not admin\"\n        );\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if(!hasRole(role, account)) {\n            revert(string(abi.encodePacked(\n                \"AccessControl: account \",\n                Strings.toHexString(uint160(account), 20),\n                \" is missing role \",\n                Strings.toHexString(uint256(role), 32)\n            )));\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "contracts/rewards/dumpers/withdrawers/YearnWithdrawer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {AdminControlled} from \"../../../libs/AdminControlled.sol\";\nimport {yERC20} from \"../imports/yERC20.sol\";\n\ncontract YearnWithdrawer is AdminControlled {\n    function yearnWithdraw(address yTokenAddress) external onlyAdmin {\n        yERC20 yToken = yERC20(yTokenAddress);\n        uint256 balance = yToken.balanceOf(address(this));\n        yToken.withdraw(balance);\n    }\n}\n"
    },
    "contracts/rewards/dumpers/imports/yERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\n// NOTE: Basically an alias for Vaults\ninterface yERC20 {\n    function balanceOf(address owner) external view returns (uint256);\n\n    function deposit(uint256 _amount) external;\n\n    function withdraw(uint256 _amount) external;\n\n    function getPricePerFullShare() external view returns (uint256);\n}\n"
    },
    "contracts/rewards/dumpers/Dumper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {OneSplitDumper} from \"./OneSplitDumper.sol\";\nimport {CurveLPWithdrawer} from \"./withdrawers/CurveLPWithdrawer.sol\";\nimport {YearnWithdrawer} from \"./withdrawers/YearnWithdrawer.sol\";\n\ncontract Dumper is OneSplitDumper, CurveLPWithdrawer, YearnWithdrawer {\n    constructor(address _oneSplit, address _xMPHToken)\n        OneSplitDumper(_oneSplit, _xMPHToken)\n    {}\n}\n"
    },
    "contracts/rewards/dumpers/withdrawers/CurveLPWithdrawer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ICurveFi, Zap} from \"../imports/Curve.sol\";\nimport {AdminControlled} from \"../../../libs/AdminControlled.sol\";\n\ncontract CurveLPWithdrawer is AdminControlled {\n    function curveWithdraw2(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[2] calldata minAmounts\n    ) external onlyAdmin {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdraw3(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[3] calldata minAmounts\n    ) external onlyAdmin {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdraw4(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[4] calldata minAmounts\n    ) external onlyAdmin {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdraw5(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[5] calldata minAmounts\n    ) external onlyAdmin {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdrawOneCoin(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        int128 coinIndex,\n        uint256 minAmount\n    ) external onlyAdmin {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        Zap curvePool = Zap(curvePoolAddress);\n        curvePool.remove_liquidity_one_coin(\n            lpTokenBalance,\n            coinIndex,\n            minAmount\n        );\n    }\n}\n"
    },
    "contracts/rewards/dumpers/imports/Curve.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\ninterface ICurveFi {\n    function remove_liquidity_imbalance(\n        uint256[2] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[3] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[4] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[5] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity(uint256 _amount, uint256[2] calldata amounts)\n        external;\n\n    function remove_liquidity(uint256 _amount, uint256[3] calldata amounts)\n        external;\n\n    function remove_liquidity(uint256 _amount, uint256[4] calldata amounts)\n        external;\n\n    function remove_liquidity(uint256 _amount, uint256[5] calldata amounts)\n        external;\n}\n\ninterface Zap {\n    function remove_liquidity_one_coin(\n        uint256,\n        int128,\n        uint256\n    ) external;\n}\n"
    },
    "contracts/mocks/HarvestStakingMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n* Synthetix: Rewards.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\npragma solidity 0.8.3;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SafeERC20} from \"../libs/SafeERC20.sol\";\n\nabstract contract IRewardDistributionRecipient is Ownable {\n    mapping(address => bool) public isRewardDistribution;\n\n    function notifyRewardAmount(uint256 reward) external virtual;\n\n    modifier onlyRewardDistribution() {\n        require(\n            isRewardDistribution[_msgSender()],\n            \"Caller is not reward distribution\"\n        );\n        _;\n    }\n\n    function setRewardDistribution(\n        address _rewardDistribution,\n        bool _isRewardDistribution\n    ) external onlyOwner {\n        isRewardDistribution[_rewardDistribution] = _isRewardDistribution;\n    }\n}\n\nabstract contract LPTokenWrapper {\n    using SafeERC20 for IERC20;\n\n    IERC20 public stakeToken;\n\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n\n    constructor(address _stakeToken) {\n        stakeToken = IERC20(_stakeToken);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply += amount;\n        _balances[msg.sender] += amount;\n        stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply -= amount;\n        _balances[msg.sender] -= amount;\n        stakeToken.safeTransfer(msg.sender, amount);\n    }\n}\n\ncontract HarvestStakingMock is LPTokenWrapper, IRewardDistributionRecipient {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    uint256 public constant DURATION = 7 days;\n\n    uint256 public starttime;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    modifier checkStart {\n        require(block.timestamp >= starttime, \"Rewards: not start\");\n        _;\n    }\n\n    constructor(\n        address _stakeToken,\n        address _rewardToken,\n        uint256 _starttime\n    ) LPTokenWrapper(_stakeToken) {\n        rewardToken = IERC20(_rewardToken);\n        starttime = _starttime;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            (((lastTimeRewardApplicable() - lastUpdateTime) *\n                rewardRate *\n                1e18) / totalSupply());\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            (balanceOf(account) *\n                (rewardPerToken() - userRewardPerTokenPaid[account])) /\n            1e18 +\n            rewards[account];\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount)\n        public\n        override\n        updateReward(msg.sender)\n        checkStart\n    {\n        require(amount > 0, \"Rewards: cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        override\n        updateReward(msg.sender)\n        checkStart\n    {\n        require(amount > 0, \"Rewards: cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) checkStart {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        override\n        onlyRewardDistribution\n        updateReward(address(0))\n    {\n        // https://sips.synthetix.io/sips/sip-77\n        require(reward > 0, \"Rewards: reward == 0\");\n        require(\n            reward < type(uint256).max / 10**18,\n            \"Rewards: rewards too large, would lock\"\n        );\n        if (block.timestamp > starttime) {\n            if (block.timestamp >= periodFinish) {\n                rewardRate = reward / DURATION;\n            } else {\n                uint256 remaining = periodFinish - block.timestamp;\n                uint256 leftover = remaining * rewardRate;\n                rewardRate = (reward + leftover) / DURATION;\n            }\n            lastUpdateTime = block.timestamp;\n            periodFinish = block.timestamp + DURATION;\n            emit RewardAdded(reward);\n        } else {\n            rewardRate = reward / DURATION;\n            lastUpdateTime = starttime;\n            periodFinish = starttime + DURATION;\n            emit RewardAdded(reward);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/models/fee/PercentageFeeModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IFeeModel} from \"./IFeeModel.sol\";\n\ncontract PercentageFeeModel is IFeeModel, Ownable {\n    uint256 internal constant PRECISION = 10**18;\n    uint256 internal constant MAX_INTEREST_FEE = 50 * 10**16; // 50%\n    uint256 internal constant MAX_EARLY_WITHDRAW_FEE = 5 * 10**16; // 5%\n\n    struct FeeOverride {\n        bool isOverridden;\n        uint256 fee;\n    }\n\n    address payable public override beneficiary;\n    mapping(address => FeeOverride) public interestFeeOverrideForPool;\n    mapping(address => FeeOverride) public earlyWithdrawFeeOverrideForPool;\n    mapping(address => mapping(uint64 => FeeOverride))\n        public earlyWithdrawFeeOverrideForDeposit;\n\n    uint256 public interestFee;\n    uint256 public earlyWithdrawFee;\n\n    event SetBeneficiary(address newBeneficiary);\n    event SetInterestFee(uint256 newValue);\n    event SetEarlyWithdrawFee(uint256 newValue);\n    event OverrideInterestFeeForPool(address indexed pool, uint256 newFee);\n    event OverrideEarlyWithdrawFeeForPool(address indexed pool, uint256 newFee);\n    event OverrideEarlyWithdrawFeeForDeposit(\n        address indexed pool,\n        uint64 indexed depositID,\n        uint256 newFee\n    );\n\n    constructor(\n        address payable _beneficiary,\n        uint256 _interestFee,\n        uint256 _earlyWithdrawFee\n    ) {\n        require(\n            _beneficiary != address(0) &&\n                _interestFee <= MAX_INTEREST_FEE &&\n                _earlyWithdrawFee <= MAX_EARLY_WITHDRAW_FEE,\n            \"PercentageFeeModel: invalid input\"\n        );\n        beneficiary = _beneficiary;\n        interestFee = _interestFee;\n        earlyWithdrawFee = _earlyWithdrawFee;\n    }\n\n    function getInterestFeeAmount(address pool, uint256 interestAmount)\n        external\n        view\n        override\n        returns (uint256 feeAmount)\n    {\n        uint256 feeRate;\n        FeeOverride memory feeOverrideForPool =\n            interestFeeOverrideForPool[pool];\n        if (feeOverrideForPool.isOverridden) {\n            // fee has been overridden for pool\n            feeRate = feeOverrideForPool.fee;\n        } else {\n            // use default fee\n            feeRate = interestFee;\n        }\n        return (interestAmount * feeRate) / PRECISION;\n    }\n\n    function getEarlyWithdrawFeeAmount(\n        address pool,\n        uint64 depositID,\n        uint256 withdrawnDepositAmount\n    ) external view override returns (uint256 feeAmount) {\n        uint256 feeRate;\n        FeeOverride memory feeOverrideForDeposit =\n            earlyWithdrawFeeOverrideForDeposit[pool][depositID];\n        if (feeOverrideForDeposit.isOverridden) {\n            // fee has been overridden for deposit\n            feeRate = feeOverrideForDeposit.fee;\n        } else {\n            FeeOverride memory feeOverrideForPool =\n                earlyWithdrawFeeOverrideForPool[pool];\n            if (feeOverrideForPool.isOverridden) {\n                // fee has been overridden for pool\n                feeRate = feeOverrideForPool.fee;\n            } else {\n                // use default fee\n                feeRate = earlyWithdrawFee;\n            }\n        }\n        return (withdrawnDepositAmount * feeRate) / PRECISION;\n    }\n\n    function setBeneficiary(address payable newValue) external onlyOwner {\n        require(newValue != address(0), \"PercentageFeeModel: 0 address\");\n        beneficiary = newValue;\n        emit SetBeneficiary(newValue);\n    }\n\n    function setInterestFee(uint256 newValue) external onlyOwner {\n        require(newValue <= MAX_INTEREST_FEE, \"PercentageFeeModel: too big\");\n        interestFee = newValue;\n        emit SetInterestFee(newValue);\n    }\n\n    function setEarlyWithdrawFee(uint256 newValue) external onlyOwner {\n        require(\n            newValue <= MAX_EARLY_WITHDRAW_FEE,\n            \"PercentageFeeModel: too big\"\n        );\n        earlyWithdrawFee = newValue;\n        emit SetEarlyWithdrawFee(newValue);\n    }\n\n    function overrideInterestFeeForPool(address pool, uint256 newFee)\n        external\n        onlyOwner\n    {\n        require(newFee <= interestFee, \"PercentageFeeModel: too big\");\n        interestFeeOverrideForPool[pool] = FeeOverride({\n            isOverridden: true,\n            fee: newFee\n        });\n        emit OverrideInterestFeeForPool(pool, newFee);\n    }\n\n    function overrideEarlyWithdrawFeeForPool(address pool, uint256 newFee)\n        external\n        onlyOwner\n    {\n        require(newFee <= earlyWithdrawFee, \"PercentageFeeModel: too big\");\n        earlyWithdrawFeeOverrideForPool[pool] = FeeOverride({\n            isOverridden: true,\n            fee: newFee\n        });\n        emit OverrideEarlyWithdrawFeeForPool(pool, newFee);\n    }\n\n    function overrideEarlyWithdrawFeeForDeposit(\n        address pool,\n        uint64 depositID,\n        uint256 newFee\n    ) external onlyOwner {\n        require(newFee <= earlyWithdrawFee, \"PercentageFeeModel: too big\");\n        earlyWithdrawFeeOverrideForDeposit[pool][depositID] = FeeOverride({\n            isOverridden: true,\n            fee: newFee\n        });\n        emit OverrideEarlyWithdrawFeeForDeposit(pool, depositID, newFee);\n    }\n}\n"
    },
    "contracts/mocks/VaultWithDepositFeeMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {DecMath} from \"../libs/DecMath.sol\";\n\ncontract VaultWithDepositFeeMock is ERC20 {\n    using DecMath for uint256;\n\n    uint256 PRECISION = 10**18;\n\n    ERC20 public underlying;\n    uint256 public depositFee;\n    uint256 public feeCollected;\n\n    constructor(address _underlying, uint256 _depositFee)\n        ERC20(\"yUSD\", \"yUSD\")\n    {\n        underlying = ERC20(_underlying);\n        depositFee = _depositFee;\n    }\n\n    function deposit(uint256 tokenAmount) public {\n        uint256 sharePrice = getPricePerFullShare();\n        uint256 shareAmountAfterFee =\n            tokenAmount.decdiv(sharePrice).decmul(PRECISION - depositFee);\n        uint256 tokenFee = tokenAmount.decmul(depositFee);\n        _mint(msg.sender, shareAmountAfterFee);\n\n        underlying.transferFrom(msg.sender, address(this), tokenAmount);\n\n        feeCollected = feeCollected + tokenFee;\n    }\n\n    function withdraw(uint256 sharesAmount) public {\n        uint256 sharePrice = getPricePerFullShare();\n        uint256 underlyingAmount = sharesAmount.decmul(sharePrice);\n        _burn(msg.sender, sharesAmount);\n\n        underlying.transfer(msg.sender, underlyingAmount);\n    }\n\n    function getPricePerFullShare() public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return 10**18;\n        }\n        return\n            (underlying.balanceOf(address(this)) - feeCollected).decdiv(\n                _totalSupply\n            );\n    }\n\n    function pricePerShare() external view returns (uint256) {\n        return getPricePerFullShare();\n    }\n}\n"
    },
    "contracts/models/interest/LinearInterestModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {DecMath} from \"../../libs/DecMath.sol\";\nimport {IInterestModel} from \"./IInterestModel.sol\";\n\ncontract LinearInterestModel is IInterestModel {\n    using DecMath for uint256;\n\n    uint256 public constant PRECISION = 10**18;\n    uint256 public IRMultiplier;\n\n    constructor(uint256 _IRMultiplier) {\n        IRMultiplier = _IRMultiplier;\n    }\n\n    function calculateInterestAmount(\n        uint256 depositAmount,\n        uint256 depositPeriodInSeconds,\n        uint256 moneyMarketInterestRatePerSecond,\n        bool, /*surplusIsNegative*/\n        uint256 /*surplusAmount*/\n    ) external view override returns (uint256 interestAmount) {\n        // interestAmount = depositAmount * moneyMarketInterestRatePerSecond * IRMultiplier * depositPeriodInSeconds\n        interestAmount =\n            ((depositAmount * PRECISION)\n                .decmul(moneyMarketInterestRatePerSecond)\n                .decmul(IRMultiplier) * depositPeriodInSeconds) /\n            PRECISION;\n    }\n}\n"
    },
    "contracts/models/interest/LinearDecayInterestModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {DecMath} from \"../../libs/DecMath.sol\";\nimport {IInterestModel} from \"./IInterestModel.sol\";\n\ncontract LinearDecayInterestModel is IInterestModel {\n    using DecMath for uint256;\n\n    uint256 public constant PRECISION = 10**18;\n    uint256 public multiplierIntercept;\n    uint256 public multiplierSlope;\n\n    constructor(uint256 _multiplierIntercept, uint256 _multiplierSlope) {\n        multiplierIntercept = _multiplierIntercept;\n        multiplierSlope = _multiplierSlope;\n    }\n\n    function getIRMultiplier(uint256 depositPeriodInSeconds)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 multiplierDecrease = depositPeriodInSeconds * multiplierSlope;\n        if (multiplierDecrease >= multiplierIntercept) {\n            return 0;\n        } else {\n            return multiplierIntercept - multiplierDecrease;\n        }\n    }\n\n    function calculateInterestAmount(\n        uint256 depositAmount,\n        uint256 depositPeriodInSeconds,\n        uint256 moneyMarketInterestRatePerSecond,\n        bool, /*surplusIsNegative*/\n        uint256 /*surplusAmount*/\n    ) external view override returns (uint256 interestAmount) {\n        // interestAmount = depositAmount * moneyMarketInterestRatePerSecond * IRMultiplier * depositPeriodInSeconds\n        interestAmount =\n            ((depositAmount * PRECISION)\n                .decmul(moneyMarketInterestRatePerSecond)\n                .decmul(getIRMultiplier(depositPeriodInSeconds)) *\n                depositPeriodInSeconds) /\n            PRECISION;\n    }\n}\n"
    },
    "contracts/mocks/VaultMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {DecMath} from \"../libs/DecMath.sol\";\n\ncontract VaultMock is ERC20 {\n    using DecMath for uint256;\n\n    ERC20 public underlying;\n\n    constructor(address _underlying) ERC20(\"yUSD\", \"yUSD\") {\n        underlying = ERC20(_underlying);\n    }\n\n    function deposit(uint256 tokenAmount) public {\n        uint256 sharePrice = getPricePerFullShare();\n        _mint(msg.sender, tokenAmount.decdiv(sharePrice));\n\n        underlying.transferFrom(msg.sender, address(this), tokenAmount);\n    }\n\n    function withdraw(uint256 sharesAmount) public {\n        uint256 sharePrice = getPricePerFullShare();\n        uint256 underlyingAmount = sharesAmount.decmul(sharePrice);\n        _burn(msg.sender, sharesAmount);\n\n        underlying.transfer(msg.sender, underlyingAmount);\n    }\n\n    function getPricePerFullShare() public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return 10**18;\n        }\n        return underlying.balanceOf(address(this)).decdiv(_totalSupply);\n    }\n\n    function pricePerShare() external view returns (uint256) {\n        return getPricePerFullShare();\n    }\n}\n"
    },
    "contracts/mocks/ATokenMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {DecMath} from \"../libs/DecMath.sol\";\n\ncontract ATokenMock is ERC20 {\n    using DecMath for uint256;\n\n    uint256 internal constant YEAR = 31556952; // Number of seconds in one Gregorian calendar year (365.2425 days)\n\n    ERC20 public dai;\n    uint256 public liquidityRate;\n    uint256 public normalizedIncome;\n    address[] public users;\n    mapping(address => bool) public isUser;\n\n    constructor(address _dai) ERC20(\"aDAI\", \"aDAI\") {\n        dai = ERC20(_dai);\n\n        liquidityRate = 10**26; // 10% APY\n        normalizedIncome = 10**27;\n    }\n\n    function mint(address _user, uint256 _amount) external {\n        _mint(_user, _amount);\n        if (!isUser[_user]) {\n            users.push(_user);\n            isUser[_user] = true;\n        }\n    }\n\n    function burn(address _user, uint256 _amount) external {\n        _burn(_user, _amount);\n    }\n\n    function mintInterest(uint256 _seconds) external {\n        uint256 interest;\n        address user;\n        for (uint256 i = 0; i < users.length; i++) {\n            user = users[i];\n            interest =\n                (balanceOf(user) * _seconds * liquidityRate) /\n                (YEAR * 10**27);\n            _mint(user, interest);\n        }\n        normalizedIncome +=\n            (normalizedIncome * _seconds * liquidityRate) /\n            (YEAR * 10**27);\n    }\n\n    function setLiquidityRate(uint256 _liquidityRate) external {\n        liquidityRate = _liquidityRate;\n    }\n}\n"
    },
    "contracts/mocks/LendingPoolMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ATokenMock} from \"./ATokenMock.sol\";\n\ncontract LendingPoolMock {\n    mapping(address => address) internal reserveAToken;\n\n    function setReserveAToken(address _reserve, address _aTokenAddress)\n        external\n    {\n        reserveAToken[_reserve] = _aTokenAddress;\n    }\n\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16\n    ) external {\n        // Transfer asset\n        ERC20 token = ERC20(asset);\n        token.transferFrom(msg.sender, address(this), amount);\n\n        // Mint aTokens\n        address aTokenAddress = reserveAToken[asset];\n        ATokenMock aToken = ATokenMock(aTokenAddress);\n        aToken.mint(onBehalfOf, amount);\n    }\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        // Burn aTokens\n        address aTokenAddress = reserveAToken[asset];\n        ATokenMock aToken = ATokenMock(aTokenAddress);\n        aToken.burn(msg.sender, amount);\n\n        // Transfer asset\n        ERC20 token = ERC20(asset);\n        token.transfer(to, amount);\n        return amount;\n    }\n\n    // The equivalent of exchangeRateStored() for Compound cTokens\n    function getReserveNormalizedIncome(address asset)\n        external\n        view\n        returns (uint256)\n    {\n        address aTokenAddress = reserveAToken[asset];\n        ATokenMock aToken = ATokenMock(aTokenAddress);\n        return aToken.normalizedIncome();\n    }\n}\n"
    },
    "contracts/moneymarkets/yvault/YVaultMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {\n    AddressUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {DecMath} from \"../../libs/DecMath.sol\";\nimport {Vault} from \"./imports/Vault.sol\";\n\ncontract YVaultMarket is MoneyMarket {\n    using DecMath for uint256;\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    Vault public vault;\n    ERC20 public override stablecoin;\n\n    function initialize(\n        address _vault,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _vault.isContract() && _stablecoin.isContract(),\n            \"YVaultMarket: An input address is not a contract\"\n        );\n\n        vault = Vault(_vault);\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"YVaultMarket: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve `amount` stablecoin to vault\n        stablecoin.safeApprove(address(vault), amount);\n\n        // Deposit `amount` stablecoin to vault\n        vault.deposit(amount);\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"YVaultMarket: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInShares` shares from vault\n        uint256 sharePrice = vault.pricePerShare();\n        uint256 amountInShares = amountInUnderlying.decdiv(sharePrice);\n        if (amountInShares > 0) {\n            vault.withdraw(amountInShares);\n        }\n\n        // Transfer stablecoin to `msg.sender`\n        actualAmountWithdrawn = stablecoin.balanceOf(address(this));\n        if (actualAmountWithdrawn > 0) {\n            stablecoin.safeTransfer(msg.sender, actualAmountWithdrawn);\n        }\n    }\n\n    function claimRewards() external override {}\n\n    function totalValue() external view override returns (uint256) {\n        uint256 sharePrice = vault.pricePerShare();\n        uint256 shareBalance = vault.balanceOf(address(this));\n        return shareBalance.decmul(sharePrice);\n    }\n\n    function totalValue(uint256 currentIncomeIndex)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 shareBalance = vault.balanceOf(address(this));\n        return shareBalance.decmul(currentIncomeIndex);\n    }\n\n    function incomeIndex() external view override returns (uint256 index) {\n        index = vault.pricePerShare();\n        require(index > 0, \"YVaultMarket: BAD_INDEX\");\n    }\n\n    function setRewards(address newValue) external override {}\n\n    /**\n        @dev See {Rescuable._authorizeRescue}\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(vault), \"YVaultMarket: no steal\");\n    }\n\n    uint256[48] private __gap;\n}\n"
    },
    "contracts/moneymarkets/yvault/imports/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\ninterface Vault {\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 shareAmount) external;\n\n    function pricePerShare() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/moneymarkets/harvest/HarvestMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {\n    AddressUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {DecMath} from \"../../libs/DecMath.sol\";\nimport {HarvestVault} from \"./imports/HarvestVault.sol\";\nimport {HarvestStaking} from \"./imports/HarvestStaking.sol\";\n\ncontract HarvestMarket is MoneyMarket {\n    using DecMath for uint256;\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    HarvestVault public vault;\n    address public rewards;\n    HarvestStaking public stakingPool;\n    ERC20 public override stablecoin;\n\n    function initialize(\n        address _vault,\n        address _rewards,\n        address _stakingPool,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _vault.isContract() &&\n                _rewards != address(0) &&\n                _stakingPool.isContract() &&\n                _stablecoin.isContract(),\n            \"HarvestMarket: Invalid input address\"\n        );\n\n        vault = HarvestVault(_vault);\n        rewards = _rewards;\n        stakingPool = HarvestStaking(_stakingPool);\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"HarvestMarket: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve `amount` stablecoin to vault\n        stablecoin.safeApprove(address(vault), amount);\n\n        // Deposit `amount` stablecoin to vault\n        vault.deposit(amount);\n\n        // Stake vault token balance into staking pool\n        uint256 vaultShareBalance = vault.balanceOf(address(this));\n        vault.approve(address(stakingPool), vaultShareBalance);\n        stakingPool.stake(vaultShareBalance);\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"HarvestMarket: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInShares` shares from vault\n        uint256 sharePrice = vault.getPricePerFullShare();\n        uint256 amountInShares = amountInUnderlying.decdiv(sharePrice);\n        if (amountInShares > 0) {\n            stakingPool.withdraw(amountInShares);\n            vault.withdraw(amountInShares);\n        }\n\n        // Transfer stablecoin to `msg.sender`\n        actualAmountWithdrawn = stablecoin.balanceOf(address(this));\n        if (actualAmountWithdrawn > 0) {\n            stablecoin.safeTransfer(msg.sender, actualAmountWithdrawn);\n        }\n    }\n\n    function claimRewards() external override {\n        stakingPool.getReward();\n        ERC20 rewardToken = ERC20(stakingPool.rewardToken());\n        rewardToken.safeTransfer(rewards, rewardToken.balanceOf(address(this)));\n    }\n\n    function totalValue() external view override returns (uint256) {\n        uint256 sharePrice = vault.getPricePerFullShare();\n        uint256 shareBalance =\n            vault.balanceOf(address(this)) +\n                stakingPool.balanceOf(address(this));\n        return shareBalance.decmul(sharePrice);\n    }\n\n    function totalValue(uint256 currentIncomeIndex)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 shareBalance =\n            vault.balanceOf(address(this)) +\n                stakingPool.balanceOf(address(this));\n        return shareBalance.decmul(currentIncomeIndex);\n    }\n\n    function incomeIndex() external view override returns (uint256 index) {\n        index = vault.getPricePerFullShare();\n        require(index > 0, \"HarvestMarket: BAD_INDEX\");\n    }\n\n    /**\n        Param setters\n     */\n    function setRewards(address newValue) external override onlyOwner {\n        require(newValue.isContract(), \"HarvestMarket: not contract\");\n        rewards = newValue;\n        emit ESetParamAddress(msg.sender, \"rewards\", newValue);\n    }\n\n    /**\n        @dev See {Rescuable._authorizeRescue}\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(stakingPool), \"HarvestMarket: no steal\");\n    }\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/moneymarkets/harvest/imports/HarvestVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\ninterface HarvestVault {\n    function deposit(uint256) external;\n\n    function withdraw(uint256) external;\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/moneymarkets/harvest/imports/HarvestStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\ninterface HarvestStaking {\n    function stake(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function getReward() external;\n\n    function rewardToken() external returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/cream/CreamERC20Market.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {\n    AddressUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {DecMath} from \"../../libs/DecMath.sol\";\nimport {ICrERC20} from \"./imports/ICrERC20.sol\";\n\ncontract CreamERC20Market is MoneyMarket {\n    using DecMath for uint256;\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    uint256 internal constant ERRCODE_OK = 0;\n\n    ICrERC20 public cToken;\n    ERC20 public override stablecoin;\n\n    function initialize(\n        address _cToken,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n        // Verify input addresses\n        require(\n            _cToken.isContract() && _stablecoin.isContract(),\n            \"CreamERC20Market: An input address is not a contract\"\n        );\n\n        cToken = ICrERC20(_cToken);\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"CreamERC20Market: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Deposit `amount` stablecoin into cToken\n        stablecoin.safeApprove(address(cToken), amount);\n        require(\n            cToken.mint(amount) == ERRCODE_OK,\n            \"CreamERC20Market: Failed to mint cTokens\"\n        );\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"CreamERC20Market: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInUnderlying` stablecoin from cToken\n        require(\n            cToken.redeemUnderlying(amountInUnderlying) == ERRCODE_OK,\n            \"CreamERC20Market: Failed to redeem\"\n        );\n\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        stablecoin.safeTransfer(msg.sender, amountInUnderlying);\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external override {}\n\n    function totalValue() external override returns (uint256) {\n        uint256 cTokenBalance = cToken.balanceOf(address(this));\n        // Amount of stablecoin units that 1 unit of cToken can be exchanged for, scaled by 10^18\n        uint256 cTokenPrice = cToken.exchangeRateCurrent();\n        return cTokenBalance.decmul(cTokenPrice);\n    }\n\n    function totalValue(uint256 currentIncomeIndex)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 cTokenBalance = cToken.balanceOf(address(this));\n        return cTokenBalance.decmul(currentIncomeIndex);\n    }\n\n    function incomeIndex() external override returns (uint256 index) {\n        index = cToken.exchangeRateCurrent();\n        require(index > 0, \"CreamERC20Market: BAD_INDEX\");\n    }\n\n    function setRewards(address newValue) external override onlyOwner {}\n\n    /**\n        @dev See {Rescuable._authorizeRescue}\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(cToken), \"CreamERC20Market: no steal\");\n    }\n\n    uint256[48] private __gap;\n}\n"
    },
    "contracts/moneymarkets/cream/imports/ICrERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\n// Cream ERC20 market interface\ninterface ICrERC20 {\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account)\n        external\n        view\n        returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function accrueInterest() external returns (uint256);\n\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        returns (uint256);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        address cTokenCollateral\n    ) external returns (uint256);\n}\n"
    },
    "contracts/Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {FundingMultitoken} from \"./tokens/FundingMultitoken.sol\";\nimport {NFT} from \"./tokens/NFT.sol\";\nimport {ZeroCouponBond} from \"./zero-coupon-bond/ZeroCouponBond.sol\";\nimport {EMAOracle} from \"./models/interest-oracle/EMAOracle.sol\";\nimport {AaveMarket} from \"./moneymarkets/aave/AaveMarket.sol\";\nimport {BProtocolMarket} from \"./moneymarkets/bprotocol/BProtocolMarket.sol\";\nimport {\n    CompoundERC20Market\n} from \"./moneymarkets/compound/CompoundERC20Market.sol\";\nimport {CreamERC20Market} from \"./moneymarkets/cream/CreamERC20Market.sol\";\nimport {HarvestMarket} from \"./moneymarkets/harvest/HarvestMarket.sol\";\nimport {YVaultMarket} from \"./moneymarkets/yvault/YVaultMarket.sol\";\nimport {DInterest} from \"./DInterest.sol\";\nimport {DInterestWithDepositFee} from \"./DInterestWithDepositFee.sol\";\n\ncontract Factory {\n    using Clones for address;\n\n    event CreateClone(\n        string indexed contractName,\n        address template,\n        bytes32 salt,\n        address clone\n    );\n\n    function createNFT(\n        address template,\n        bytes32 salt,\n        string calldata _tokenName,\n        string calldata _tokenSymbol\n    ) external returns (NFT) {\n        NFT clone = NFT(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(_tokenName, _tokenSymbol);\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"NFT\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createFundingMultitoken(\n        address template,\n        bytes32 salt,\n        string calldata _uri,\n        address[] calldata _dividendTokens,\n        address _wrapperTemplate,\n        bool _deployWrapperOnMint,\n        string memory _baseName,\n        string memory _baseSymbol,\n        uint8 _decimals\n    ) external returns (FundingMultitoken) {\n        FundingMultitoken clone =\n            FundingMultitoken(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(\n            msg.sender,\n            _uri,\n            _dividendTokens,\n            _wrapperTemplate,\n            _deployWrapperOnMint,\n            _baseName,\n            _baseSymbol,\n            _decimals\n        );\n\n        emit CreateClone(\"FundingMultitoken\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createZeroCouponBond(\n        address template,\n        bytes32 salt,\n        address _pool,\n        address _vesting,\n        uint64 _maturationTimetstamp,\n        uint256 _initialDepositAmount,\n        string calldata _tokenName,\n        string calldata _tokenSymbol\n    ) external returns (ZeroCouponBond) {\n        ZeroCouponBond clone =\n            ZeroCouponBond(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(\n            msg.sender,\n            _pool,\n            _vesting,\n            _maturationTimetstamp,\n            _initialDepositAmount,\n            _tokenName,\n            _tokenSymbol\n        );\n\n        emit CreateClone(\"ZeroCouponBond\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createEMAOracle(\n        address template,\n        bytes32 salt,\n        uint256 _emaInitial,\n        uint256 _updateInterval,\n        uint256 _smoothingFactor,\n        uint256 _averageWindowInIntervals,\n        address _moneyMarket\n    ) external returns (EMAOracle) {\n        EMAOracle clone = EMAOracle(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(\n            _emaInitial,\n            _updateInterval,\n            _smoothingFactor,\n            _averageWindowInIntervals,\n            _moneyMarket\n        );\n\n        emit CreateClone(\"EMAOracle\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createAaveMarket(\n        address template,\n        bytes32 salt,\n        address _provider,\n        address _aToken,\n        address _aaveMining,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (AaveMarket) {\n        AaveMarket clone = AaveMarket(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(\n            _provider,\n            _aToken,\n            _aaveMining,\n            _rewards,\n            _rescuer,\n            _stablecoin\n        );\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"AaveMarket\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createBProtocolMarket(\n        address template,\n        bytes32 salt,\n        address _bToken,\n        address _bComptroller,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (BProtocolMarket) {\n        BProtocolMarket clone =\n            BProtocolMarket(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(\n            _bToken,\n            _bComptroller,\n            _rewards,\n            _rescuer,\n            _stablecoin\n        );\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"BProtocolMarket\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createCompoundERC20Market(\n        address template,\n        bytes32 salt,\n        address _cToken,\n        address _comptroller,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (CompoundERC20Market) {\n        CompoundERC20Market clone =\n            CompoundERC20Market(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(\n            _cToken,\n            _comptroller,\n            _rewards,\n            _rescuer,\n            _stablecoin\n        );\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"CompoundERC20Market\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createCreamERC20Market(\n        address template,\n        bytes32 salt,\n        address _cToken,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (CreamERC20Market) {\n        CreamERC20Market clone =\n            CreamERC20Market(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(_cToken, _rescuer, _stablecoin);\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"CreamERC20Market\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createHarvestMarket(\n        address template,\n        bytes32 salt,\n        address _vault,\n        address _rewards,\n        address _stakingPool,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (HarvestMarket) {\n        HarvestMarket clone = HarvestMarket(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(_vault, _rewards, _stakingPool, _rescuer, _stablecoin);\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"HarvestMarket\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createYVaultMarket(\n        address template,\n        bytes32 salt,\n        address _vault,\n        address _rescuer,\n        address _stablecoin\n    ) external returns (YVaultMarket) {\n        YVaultMarket clone = YVaultMarket(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(_vault, _rescuer, _stablecoin);\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"YVaultMarket\", template, salt, address(clone));\n        return clone;\n    }\n\n    function createDInterest(\n        address template,\n        bytes32 salt,\n        uint64 _MaxDepositPeriod,\n        uint256 _MinDepositAmount,\n        address _moneyMarket,\n        address _stablecoin,\n        address _feeModel,\n        address _interestModel,\n        address _interestOracle,\n        address _depositNFT,\n        address _fundingMultitoken,\n        address _mphMinter\n    ) external returns (DInterest) {\n        DInterest clone = DInterest(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(\n            _MaxDepositPeriod,\n            _MinDepositAmount,\n            _moneyMarket,\n            _stablecoin,\n            _feeModel,\n            _interestModel,\n            _interestOracle,\n            _depositNFT,\n            _fundingMultitoken,\n            _mphMinter\n        );\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\"DInterest\", template, salt, address(clone));\n        return clone;\n    }\n\n    struct DInterestWithDepositFeeParams {\n        uint64 _MaxDepositPeriod;\n        uint256 _MinDepositAmount;\n        uint256 _DepositFee;\n        address _moneyMarket;\n        address _stablecoin;\n        address _feeModel;\n        address _interestModel;\n        address _interestOracle;\n        address _depositNFT;\n        address _fundingMultitoken;\n        address _mphMinter;\n    }\n\n    function createDInterestWithDepositFee(\n        address template,\n        bytes32 salt,\n        DInterestWithDepositFeeParams calldata params\n    ) external returns (DInterestWithDepositFee) {\n        DInterestWithDepositFee clone =\n            DInterestWithDepositFee(template.cloneDeterministic(salt));\n\n        // initialize\n        clone.initialize(\n            params._MaxDepositPeriod,\n            params._MinDepositAmount,\n            params._DepositFee,\n            params._moneyMarket,\n            params._stablecoin,\n            params._feeModel,\n            params._interestModel,\n            params._interestOracle,\n            params._depositNFT,\n            params._fundingMultitoken,\n            params._mphMinter\n        );\n        clone.transferOwnership(msg.sender);\n\n        emit CreateClone(\n            \"DInterestWithDepositFee\",\n            template,\n            salt,\n            address(clone)\n        );\n        return clone;\n    }\n\n    function predictAddress(address template, bytes32 salt)\n        external\n        view\n        returns (address)\n    {\n        return template.predictDeterministicAddress(salt);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/models/interest-oracle/EMAOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {\n    Initializable\n} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {DecMath} from \"../../libs/DecMath.sol\";\nimport {IInterestOracle} from \"./IInterestOracle.sol\";\nimport {MoneyMarket} from \"../../moneymarkets/MoneyMarket.sol\";\n\ncontract EMAOracle is IInterestOracle, Initializable {\n    using DecMath for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n\n    /**\n        Immutable parameters\n     */\n    uint256 public UPDATE_INTERVAL;\n    uint256 public UPDATE_MULTIPLIER;\n    uint256 public ONE_MINUS_UPDATE_MULTIPLIER;\n\n    /**\n        Public variables\n     */\n    uint256 public emaStored;\n    uint256 public lastIncomeIndex;\n    uint256 public lastUpdateTimestamp;\n\n    /**\n        External contracts\n     */\n    MoneyMarket public override moneyMarket;\n\n    function initialize(\n        uint256 _emaInitial,\n        uint256 _updateInterval,\n        uint256 _smoothingFactor,\n        uint256 _averageWindowInIntervals,\n        address _moneyMarket\n    ) external initializer {\n        emaStored = _emaInitial;\n        UPDATE_INTERVAL = _updateInterval;\n        lastUpdateTimestamp = block.timestamp;\n\n        uint256 updateMultiplier =\n            _smoothingFactor / (_averageWindowInIntervals + 1);\n        UPDATE_MULTIPLIER = updateMultiplier;\n        ONE_MINUS_UPDATE_MULTIPLIER = PRECISION - updateMultiplier;\n\n        moneyMarket = MoneyMarket(_moneyMarket);\n        lastIncomeIndex = moneyMarket.incomeIndex();\n    }\n\n    function updateAndQuery()\n        external\n        override\n        returns (bool updated, uint256 value)\n    {\n        uint256 timeElapsed = block.timestamp - lastUpdateTimestamp;\n        if (timeElapsed < UPDATE_INTERVAL) {\n            return (false, emaStored);\n        }\n\n        // save gas by loading storage variables to memory\n        uint256 _lastIncomeIndex = lastIncomeIndex;\n        uint256 _emaStored = emaStored;\n\n        uint256 newIncomeIndex = moneyMarket.incomeIndex();\n        if (newIncomeIndex < _lastIncomeIndex) {\n            // Shouldn't revert (which would block execution)\n            // Assume no interest was accrued and use the last index as the new one\n            // which would push the EMA towards zero if there's e.g. an exploit\n            // in the underlying yield protocol\n            newIncomeIndex = _lastIncomeIndex;\n        }\n        uint256 incomingValue =\n            (newIncomeIndex - _lastIncomeIndex).decdiv(_lastIncomeIndex) /\n                timeElapsed;\n\n        updated = true;\n        value =\n            (incomingValue *\n                UPDATE_MULTIPLIER +\n                _emaStored *\n                ONE_MINUS_UPDATE_MULTIPLIER) /\n            PRECISION;\n        emaStored = value;\n        lastIncomeIndex = newIncomeIndex;\n        lastUpdateTimestamp = block.timestamp;\n    }\n\n    function query() external view override returns (uint256 value) {\n        return emaStored;\n    }\n\n    uint256[43] private __gap;\n}\n"
    },
    "contracts/moneymarkets/aave/AaveMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {\n    AddressUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {ILendingPool} from \"./imports/ILendingPool.sol\";\nimport {\n    ILendingPoolAddressesProvider\n} from \"./imports/ILendingPoolAddressesProvider.sol\";\nimport {IAaveMining} from \"./imports/IAaveMining.sol\";\n\ncontract AaveMarket is MoneyMarket {\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    uint16 internal constant REFERRALCODE = 20; // Aave referral program code\n\n    ILendingPoolAddressesProvider public provider; // Used for fetching the current address of LendingPool\n    ERC20 public override stablecoin;\n    ERC20 public aToken;\n    IAaveMining public aaveMining;\n    address public rewards;\n\n    function initialize(\n        address _provider,\n        address _aToken,\n        address _aaveMining,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _provider.isContract() &&\n                _aToken.isContract() &&\n                _aaveMining.isContract() &&\n                _stablecoin.isContract(),\n            \"AaveMarket: An input address is not a contract\"\n        );\n\n        provider = ILendingPoolAddressesProvider(_provider);\n        stablecoin = ERC20(_stablecoin);\n        aaveMining = IAaveMining(_aaveMining);\n        aToken = ERC20(_aToken);\n        rewards = _rewards;\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"AaveMarket: amount is 0\");\n\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve `amount` stablecoin to lendingPool\n        stablecoin.safeApprove(address(lendingPool), amount);\n\n        // Deposit `amount` stablecoin to lendingPool\n        lendingPool.deposit(\n            address(stablecoin),\n            amount,\n            address(this),\n            REFERRALCODE\n        );\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(amountInUnderlying > 0, \"AaveMarket: amountInUnderlying is 0\");\n\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\n        // Redeem `amountInUnderlying` aToken, since 1 aToken = 1 stablecoin\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        lendingPool.withdraw(\n            address(stablecoin),\n            amountInUnderlying,\n            msg.sender\n        );\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external override {\n        address[] memory assets = new address[](1);\n        assets[0] = address(aToken);\n        aaveMining.claimRewards(assets, type(uint256).max, rewards);\n    }\n\n    function totalValue() external view override returns (uint256) {\n        return aToken.balanceOf(address(this));\n    }\n\n    function totalValue(\n        uint256 /*currentIncomeIndex*/\n    ) external view override returns (uint256) {\n        return aToken.balanceOf(address(this));\n    }\n\n    function incomeIndex() external view override returns (uint256 index) {\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n        index = lendingPool.getReserveNormalizedIncome(address(stablecoin));\n        require(index > 0, \"AaveMarket: BAD_INDEX\");\n    }\n\n    /**\n        Param setters\n     */\n    function setRewards(address newValue) external override onlyOwner {\n        require(newValue.isContract(), \"AaveMarket: not contract\");\n        rewards = newValue;\n        emit ESetParamAddress(msg.sender, \"rewards\", newValue);\n    }\n\n    /**\n        @dev See {Rescuable._authorizeRescue}\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(aToken), \"AaveMarket: no steal\");\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/moneymarkets/bprotocol/BProtocolMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {\n    AddressUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {DecMath} from \"../../libs/DecMath.sol\";\nimport {IBToken} from \"./imports/IBToken.sol\";\nimport {IBComptroller} from \"./imports/IBComptroller.sol\";\n\ncontract BProtocolMarket is MoneyMarket {\n    using DecMath for uint256;\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    uint256 internal constant ERRCODE_OK = 0;\n\n    IBToken public bToken;\n    IBComptroller public bComptroller;\n    address public rewards;\n    ERC20 public override stablecoin;\n\n    function initialize(\n        address _bToken,\n        address _bComptroller,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _bToken.isContract() &&\n                _bComptroller.isContract() &&\n                _rewards != address(0) &&\n                _stablecoin.isContract(),\n            \"BProtocolMarket: Invalid input address\"\n        );\n\n        bToken = IBToken(_bToken);\n        bComptroller = IBComptroller(_bComptroller);\n        rewards = _rewards;\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"BProtocolMarket: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Deposit `amount` stablecoin into bToken\n        stablecoin.safeApprove(address(bToken), amount);\n        require(\n            bToken.mint(amount) == ERRCODE_OK,\n            \"BProtocolMarket: Failed to mint bTokens\"\n        );\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"BProtocolMarket: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInUnderlying` stablecoin from bToken\n        require(\n            bToken.redeemUnderlying(amountInUnderlying) == ERRCODE_OK,\n            \"BProtocolMarket: Failed to redeem\"\n        );\n\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        stablecoin.safeTransfer(msg.sender, amountInUnderlying);\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external override {\n        bComptroller.claimComp(address(this));\n        ERC20 comp = ERC20(bComptroller.registry().comp());\n        comp.safeTransfer(rewards, comp.balanceOf(address(this)));\n    }\n\n    function totalValue() external override returns (uint256) {\n        uint256 bTokenBalance = bToken.balanceOf(address(this));\n        // Amount of stablecoin units that 1 unit of bToken can be exchanged for, scaled by 10^18\n        uint256 bTokenPrice = bToken.exchangeRateCurrent();\n        return bTokenBalance.decmul(bTokenPrice);\n    }\n\n    function totalValue(uint256 currentIncomeIndex)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 bTokenBalance = bToken.balanceOf(address(this));\n        return bTokenBalance.decmul(currentIncomeIndex);\n    }\n\n    function incomeIndex() external override returns (uint256 index) {\n        index = bToken.exchangeRateCurrent();\n        require(index > 0, \"BProtocolMarket: BAD_INDEX\");\n    }\n\n    /**\n        Param setters\n     */\n    function setRewards(address newValue) external override onlyOwner {\n        require(newValue.isContract(), \"BProtocolMarket: not contract\");\n        rewards = newValue;\n        emit ESetParamAddress(msg.sender, \"rewards\", newValue);\n    }\n\n    /**\n        @dev See {Rescuable._authorizeRescue}\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(bToken), \"BProtocolMarket: no steal\");\n    }\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/moneymarkets/compound/CompoundERC20Market.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {SafeERC20} from \"../../libs/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {\n    AddressUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {MoneyMarket} from \"../MoneyMarket.sol\";\nimport {DecMath} from \"../../libs/DecMath.sol\";\nimport {ICERC20} from \"./imports/ICERC20.sol\";\nimport {IComptroller} from \"./imports/IComptroller.sol\";\n\ncontract CompoundERC20Market is MoneyMarket {\n    using DecMath for uint256;\n    using SafeERC20 for ERC20;\n    using AddressUpgradeable for address;\n\n    uint256 internal constant ERRCODE_OK = 0;\n\n    ICERC20 public cToken;\n    IComptroller public comptroller;\n    address public rewards;\n    ERC20 public override stablecoin;\n\n    function initialize(\n        address _cToken,\n        address _comptroller,\n        address _rewards,\n        address _rescuer,\n        address _stablecoin\n    ) external initializer {\n        __MoneyMarket_init(_rescuer);\n\n        // Verify input addresses\n        require(\n            _cToken.isContract() &&\n                _comptroller.isContract() &&\n                _rewards != address(0) &&\n                _stablecoin.isContract(),\n            \"CompoundERC20Market: Invalid input address\"\n        );\n\n        cToken = ICERC20(_cToken);\n        comptroller = IComptroller(_comptroller);\n        rewards = _rewards;\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external override onlyOwner {\n        require(amount > 0, \"CompoundERC20Market: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Deposit `amount` stablecoin into cToken\n        stablecoin.safeApprove(address(cToken), amount);\n        require(\n            cToken.mint(amount) == ERRCODE_OK,\n            \"CompoundERC20Market: Failed to mint cTokens\"\n        );\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        override\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"CompoundERC20Market: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInUnderlying` stablecoin from cToken\n        require(\n            cToken.redeemUnderlying(amountInUnderlying) == ERRCODE_OK,\n            \"CompoundERC20Market: Failed to redeem\"\n        );\n\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        stablecoin.safeTransfer(msg.sender, amountInUnderlying);\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external override {\n        comptroller.claimComp(address(this));\n        ERC20 comp = ERC20(comptroller.getCompAddress());\n        comp.safeTransfer(rewards, comp.balanceOf(address(this)));\n    }\n\n    function totalValue() external override returns (uint256) {\n        uint256 cTokenBalance = cToken.balanceOf(address(this));\n        // Amount of stablecoin units that 1 unit of cToken can be exchanged for, scaled by 10^18\n        uint256 cTokenPrice = cToken.exchangeRateCurrent();\n        return cTokenBalance.decmul(cTokenPrice);\n    }\n\n    function totalValue(uint256 currentIncomeIndex)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 cTokenBalance = cToken.balanceOf(address(this));\n        return cTokenBalance.decmul(currentIncomeIndex);\n    }\n\n    function incomeIndex() external override returns (uint256 index) {\n        index = cToken.exchangeRateCurrent();\n        require(index > 0, \"CompoundERC20Market: BAD_INDEX\");\n    }\n\n    /**\n        Param setters\n     */\n    function setRewards(address newValue) external override onlyOwner {\n        require(newValue.isContract(), \"CompoundERC20Market: not contract\");\n        rewards = newValue;\n        emit ESetParamAddress(msg.sender, \"rewards\", newValue);\n    }\n\n    /**\n        @dev See {Rescuable._authorizeRescue}\n     */\n    function _authorizeRescue(address token, address target)\n        internal\n        view\n        override\n    {\n        super._authorizeRescue(token, target);\n        require(token != address(cToken), \"CompoundERC20Market: no steal\");\n    }\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/DInterestWithDepositFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {DecMath} from \"./libs/DecMath.sol\";\nimport {DInterest} from \"./DInterest.sol\";\n\n/**\n    @dev A variant of DInterest that supports money markets with deposit fees\n */\ncontract DInterestWithDepositFee is DInterest {\n    using DecMath for uint256;\n\n    uint256 public DepositFee; // The deposit fee charged by the money market\n\n    /**\n        @param _MaxDepositPeriod The maximum deposit period, in seconds\n        @param _MinDepositAmount The minimum deposit amount, in stablecoins\n        @param _DepositFee The fee charged by the underlying money market\n        @param _moneyMarket Address of MoneyMarket that's used for generating interest (owner must be set to this DInterest contract)\n        @param _stablecoin Address of the stablecoin used to store funds\n        @param _feeModel Address of the FeeModel contract that determines how fees are charged\n        @param _interestModel Address of the InterestModel contract that determines how much interest to offer\n        @param _interestOracle Address of the InterestOracle contract that provides the average interest rate\n        @param _depositNFT Address of the NFT representing ownership of deposits (owner must be set to this DInterest contract)\n        @param _fundingMultitoken Address of the ERC1155 multitoken representing ownership of fundings (this DInterest contract must have the minter-burner role)\n        @param _mphMinter Address of the contract for handling minting MPH to users\n     */\n    function initialize(\n        uint64 _MaxDepositPeriod,\n        uint256 _MinDepositAmount,\n        uint256 _DepositFee,\n        address _moneyMarket,\n        address _stablecoin,\n        address _feeModel,\n        address _interestModel,\n        address _interestOracle,\n        address _depositNFT,\n        address _fundingMultitoken,\n        address _mphMinter\n    ) external virtual initializer {\n        __DInterest_init(\n            _MaxDepositPeriod,\n            _MinDepositAmount,\n            _moneyMarket,\n            _stablecoin,\n            _feeModel,\n            _interestModel,\n            _interestOracle,\n            _depositNFT,\n            _fundingMultitoken,\n            _mphMinter\n        );\n        DepositFee = _DepositFee;\n    }\n\n    /**\n        Internal action functions\n     */\n\n    /**\n        @dev See {deposit}\n     */\n    function _deposit(\n        address sender,\n        uint256 depositAmount,\n        uint64 maturationTimestamp,\n        bool rollover\n    )\n        internal\n        virtual\n        override\n        returns (uint64 depositID, uint256 interestAmount)\n    {\n        (depositID, interestAmount) = _depositRecordData(\n            sender,\n            _applyDepositFee(depositAmount),\n            maturationTimestamp\n        );\n        _depositTransferFunds(sender, depositAmount, rollover);\n    }\n\n    /**\n        @dev See {topupDeposit}\n     */\n    function _topupDeposit(\n        address sender,\n        uint64 depositID,\n        uint256 depositAmount\n    ) internal virtual override returns (uint256 interestAmount) {\n        interestAmount = _topupDepositRecordData(\n            sender,\n            depositID,\n            _applyDepositFee(depositAmount)\n        );\n        _topupDepositTransferFunds(sender, depositAmount);\n    }\n\n    /**\n        @dev See {fund}\n     */\n    function _fund(\n        address sender,\n        uint64 depositID,\n        uint256 fundAmount\n    ) internal virtual override returns (uint64 fundingID) {\n        uint256 actualFundAmount;\n        (fundingID, actualFundAmount) = _fundRecordData(\n            sender,\n            depositID,\n            _applyDepositFee(fundAmount)\n        );\n        _fundTransferFunds(sender, _unapplyDepositFee(fundAmount));\n    }\n\n    /**\n        Internal getter functions\n     */\n\n    /**\n        @dev Applies a flat percentage deposit fee to a value.\n        @param amount The before-fee amount\n        @return The after-fee amount\n     */\n    function _applyDepositFee(uint256 amount)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return amount.decmul(PRECISION - DepositFee);\n    }\n\n    /**\n        @dev Unapplies a flat percentage deposit fee to a value.\n        @param amount The after-fee amount\n        @return The before-fee amount\n     */\n    function _unapplyDepositFee(uint256 amount)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return amount.decdiv(PRECISION - DepositFee);\n    }\n\n    /**\n        Param setters (only callable by the owner)\n     */\n\n    function setDepositFee(uint256 newValue) external onlyOwner {\n        require(newValue < PRECISION, \"DInterestWithDepositFee: BAD_VALUE\");\n        DepositFee = newValue;\n        emit ESetParamUint(msg.sender, \"DepositFee\", newValue);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/moneymarkets/aave/imports/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.3;\n\n// Aave lending pool interface\n// Documentation: https://docs.aave.com/developers/the-core-protocol/lendingpool/ilendingpool\n// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\ninterface ILendingPool {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/aave/imports/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.3;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n}\n"
    },
    "contracts/moneymarkets/aave/imports/IAaveMining.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.3;\n\ninterface IAaveMining {\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/bprotocol/imports/IBToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\n// B.Protocol bToken interface\ninterface IBToken {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/bprotocol/imports/IBComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport \"./IRegistry.sol\";\n\n// B.Protocol BComptroller interface\ninterface IBComptroller {\n    function claimComp(address holder) external;\n\n    function registry() external returns (IRegistry);\n}\n"
    },
    "contracts/moneymarkets/bprotocol/imports/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\n// B.Protocol Registry interface\ninterface IRegistry {\n    function comp() external returns (address);\n}\n"
    },
    "contracts/moneymarkets/compound/imports/ICERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\n// Compound finance ERC20 market interface\n// Documentation: https://compound.finance/docs/ctokens\ninterface ICERC20 {\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account)\n        external\n        view\n        returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function accrueInterest() external returns (uint256);\n\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        returns (uint256);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        address cTokenCollateral\n    ) external returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/compound/imports/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\n// Compound finance Comptroller interface\n// Documentation: https://compound.finance/docs/comptroller\ninterface IComptroller {\n    function claimComp(address holder) external;\n\n    function getCompAddress() external view returns (address);\n}\n"
    },
    "contracts/echidna/xMPHEchidnaTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.3;\n\nimport {MPHToken} from \"../rewards/MPHToken.sol\";\nimport {xMPH} from \"../rewards/xMPH.sol\";\nimport {DecMath} from \"../libs/DecMath.sol\";\nimport {Asserts} from \"./Asserts.sol\";\n\ncontract xMPHEchidnaTest is Asserts {\n    using DecMath for uint256;\n\n    uint256 private constant REWARD_UNLOCK_PERIOD = 14 days;\n\n    MPHToken private mphToken;\n    xMPH private xMPHToken;\n\n    constructor() {\n        // initialize\n        mphToken = new MPHToken();\n        mphToken.initialize();\n\n        // mint this contract some MPH\n        mphToken.ownerMint(address(this), 100 * PRECISION);\n\n        // deploy xMPH\n        xMPHToken = new xMPH();\n        uint256 mphAmount = xMPHToken.MIN_AMOUNT();\n        mphToken.increaseAllowance(address(xMPHToken), mphAmount);\n        xMPHToken.initialize(\n            address(mphToken),\n            REWARD_UNLOCK_PERIOD,\n            address(this)\n        );\n    }\n\n    /**\n        Checks\n     */\n\n    function sanityChecks_deposit(uint256 _mphAmount) external {\n        uint256 beforeMPHBalance = mphToken.balanceOf(address(this));\n        uint256 beforePricePerFullShare = xMPHToken.getPricePerFullShare();\n        uint256 beforeShareBalance = xMPHToken.balanceOf(address(this));\n\n        mphToken.increaseAllowance(address(xMPHToken), _mphAmount);\n        uint256 shareAmount = xMPHToken.deposit(_mphAmount);\n\n        uint256 afterMPHBalance = mphToken.balanceOf(address(this));\n        uint256 afterPricePerFullShare = xMPHToken.getPricePerFullShare();\n        uint256 afterShareBalance = xMPHToken.balanceOf(address(this));\n\n        Assert(beforeMPHBalance - afterMPHBalance == _mphAmount);\n        AssertEpsilonEqual(beforePricePerFullShare, afterPricePerFullShare);\n        Assert(\n            afterShareBalance - beforeShareBalance ==\n                _mphAmount.decdiv(beforePricePerFullShare)\n        );\n        Assert(afterShareBalance - beforeShareBalance == shareAmount);\n    }\n\n    function sanityChecks_withdraw(uint256 _shareAmount) external {\n        uint256 beforeMPHBalance = mphToken.balanceOf(address(this));\n        uint256 beforePricePerFullShare = xMPHToken.getPricePerFullShare();\n        uint256 beforeShareBalance = xMPHToken.balanceOf(address(this));\n\n        uint256 mphAmount = xMPHToken.withdraw(_shareAmount);\n\n        uint256 afterMPHBalance = mphToken.balanceOf(address(this));\n        uint256 afterPricePerFullShare = xMPHToken.getPricePerFullShare();\n        uint256 afterShareBalance = xMPHToken.balanceOf(address(this));\n\n        Assert(\n            afterMPHBalance - beforeMPHBalance ==\n                _shareAmount.decmul(beforePricePerFullShare)\n        );\n        Assert(afterMPHBalance - beforeMPHBalance == mphAmount);\n        AssertEpsilonEqual(beforePricePerFullShare, afterPricePerFullShare);\n        Assert(beforeShareBalance - afterShareBalance == _shareAmount);\n    }\n\n    function sanityChecks_distributeReward(uint256 rewardAmount) external {\n        uint256 beforeMPHBalance = mphToken.balanceOf(address(this));\n        uint256 beforePricePerFullShare = xMPHToken.getPricePerFullShare();\n\n        mphToken.increaseAllowance(address(xMPHToken), rewardAmount);\n        xMPHToken.distributeReward(rewardAmount);\n\n        uint256 afterMPHBalance = mphToken.balanceOf(address(this));\n        uint256 afterPricePerFullShare = xMPHToken.getPricePerFullShare();\n\n        Assert(xMPHToken.hasRole(xMPHToken.DISTRIBUTOR_ROLE(), address(this)));\n        Assert(beforeMPHBalance - afterMPHBalance == rewardAmount);\n        AssertEpsilonEqual(beforePricePerFullShare, afterPricePerFullShare);\n    }\n\n    /**\n        Actions\n     */\n    function action_sendMPHToContract(uint256 mphAmount) external {\n        mphToken.transfer(address(xMPHToken), mphAmount);\n    }\n}\n"
    },
    "contracts/echidna/Asserts.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n    @notice Lets Echidna work with solidity 0.8 asserts\n */\ncontract Asserts {\n    uint256 internal constant EPSILON = 10**9;\n    uint256 internal constant PRECISION = 10**18;\n\n    event AssertionFailed();\n\n    function Assert(bool condition) internal {\n        if (!condition) {\n            emit AssertionFailed();\n        }\n    }\n\n    function AssertEpsilonEqual(uint256 a, uint256 b) internal {\n        if (a == 0 || b == 0) {\n            if (Math.max(a, b) > EPSILON) {\n                emit AssertionFailed();\n            }\n        } else {\n            uint256 hi = Math.max(a, b);\n            uint256 lo = Math.min(a, b);\n            uint256 delta = ((hi - lo) * PRECISION) / lo;\n            if (delta > EPSILON) {\n                emit AssertionFailed();\n            }\n        }\n    }\n}\n"
    },
    "contracts/DInterestLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {DecMath} from \"./libs/DecMath.sol\";\nimport {DInterest} from \"./DInterest.sol\";\n\ncontract DInterestLens {\n    using DecMath for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n    /**\n        @dev used for sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex\n     */\n    uint256 internal constant EXTRA_PRECISION = 10**27;\n    /**\n        @dev used for funding.principalPerToken\n     */\n    uint256 internal constant ULTRA_PRECISION = 2**128;\n\n    /**\n        @notice Computes the amount of stablecoins that can be withdrawn\n                by burning `virtualTokenAmount` virtual tokens from the deposit\n                with ID `depositID` at time `timestamp`.\n        @dev The queried timestamp should >= the deposit's lastTopupTimestamp, since\n             the information before this time is forgotten.\n        @param pool The DInterest pool\n        @param depositID The ID of the deposit\n        @param virtualTokenAmount The amount of virtual tokens to burn\n        @return withdrawableAmount The amount of stablecoins (after fee) that can be withdrawn\n        @return feeAmount The amount of fees that will be given to the beneficiary\n     */\n    function withdrawableAmountOfDeposit(\n        DInterest pool,\n        uint64 depositID,\n        uint256 virtualTokenAmount\n    ) external view returns (uint256 withdrawableAmount, uint256 feeAmount) {\n        // Verify input\n        DInterest.Deposit memory depositEntry = pool.getDeposit(depositID);\n        if (virtualTokenAmount == 0) {\n            return (0, 0);\n        } else {\n            if (virtualTokenAmount > depositEntry.virtualTokenTotalSupply) {\n                virtualTokenAmount = depositEntry.virtualTokenTotalSupply;\n            }\n        }\n\n        // Compute token amounts\n        bool early = block.timestamp < depositEntry.maturationTimestamp;\n        uint256 depositAmount =\n            virtualTokenAmount.decdiv(depositEntry.interestRate + PRECISION);\n        uint256 interestAmount = early ? 0 : virtualTokenAmount - depositAmount;\n        withdrawableAmount = depositAmount + interestAmount;\n\n        if (early) {\n            // apply fee to withdrawAmount\n            uint256 earlyWithdrawFee =\n                pool.feeModel().getEarlyWithdrawFeeAmount(\n                    address(pool),\n                    depositID,\n                    withdrawableAmount\n                );\n            feeAmount = earlyWithdrawFee;\n            withdrawableAmount -= earlyWithdrawFee;\n        } else {\n            feeAmount = depositAmount.decmul(depositEntry.feeRate);\n        }\n    }\n\n    /**\n        @notice Computes the floating-rate interest accrued in the floating-rate\n                bond with ID `fundingID`.\n        @param pool The DInterest pool\n        @param fundingID The ID of the floating-rate bond\n        @return fundingInterestAmount The interest accrued, in stablecoins\n     */\n    function accruedInterestOfFunding(DInterest pool, uint64 fundingID)\n        external\n        returns (uint256 fundingInterestAmount)\n    {\n        DInterest.Funding memory f = pool.getFunding(fundingID);\n        uint256 fundingTokenTotalSupply =\n            pool.fundingMultitoken().totalSupply(fundingID);\n        uint256 recordedFundedPrincipalAmount =\n            (fundingTokenTotalSupply * f.principalPerToken) / ULTRA_PRECISION;\n        uint256 recordedMoneyMarketIncomeIndex =\n            f.recordedMoneyMarketIncomeIndex;\n        uint256 currentMoneyMarketIncomeIndex =\n            pool.moneyMarket().incomeIndex();\n        require(currentMoneyMarketIncomeIndex > 0, \"DInterest: BAD_INDEX\");\n\n        // Compute interest to funders\n        fundingInterestAmount =\n            (recordedFundedPrincipalAmount * currentMoneyMarketIncomeIndex) /\n            recordedMoneyMarketIncomeIndex -\n            recordedFundedPrincipalAmount;\n    }\n\n    /**\n        @notice A floating-rate bond is no longer active if its principalPerToken becomes 0,\n                which occurs when the corresponding deposit is completely withdrawn. When\n                such a deposit is topped up, a new Funding struct and floating-rate bond will\n                be created.\n        @param pool The DInterest pool\n        @param fundingID The ID of the floating-rate bond\n        @return True if the funding is active, false otherwise\n     */\n    function fundingIsActive(DInterest pool, uint64 fundingID)\n        external\n        view\n        returns (bool)\n    {\n        return pool.getFunding(fundingID).principalPerToken > 0;\n    }\n\n    /**\n        @notice Computes the floating interest amount owed to deficit funders, which will be paid out\n                when a funded deposit is withdrawn.\n                Formula: \\sum_i recordedFundedPrincipalAmount_i * (incomeIndex / recordedMoneyMarketIncomeIndex_i - 1)\n                = incomeIndex * (\\sum_i recordedFundedPrincipalAmount_i / recordedMoneyMarketIncomeIndex_i)\n                - \\sum_i recordedFundedPrincipalAmount_i\n                where i refers to a funding\n        @param pool The DInterest pool\n        @return interestOwed The floating-rate interest accrued to all floating-rate bond holders\n     */\n    function totalInterestOwedToFunders(DInterest pool)\n        public\n        virtual\n        returns (uint256 interestOwed)\n    {\n        uint256 currentValue =\n            (pool.moneyMarket().incomeIndex() *\n                pool\n                    .sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex()) /\n                EXTRA_PRECISION;\n        uint256 initialValue = pool.totalFundedPrincipalAmount();\n        if (currentValue < initialValue) {\n            return 0;\n        }\n        return currentValue - initialValue;\n    }\n\n    /**\n        @notice Computes the surplus of a deposit, which is the raw surplus of the\n                unfunded part of the deposit. If the deposit is not funded, this will\n                return the same value as {rawSurplusOfDeposit}.\n        @param depositID The ID of the deposit\n        @return isNegative True if the surplus is negative, false otherwise\n        @return surplusAmount The absolute value of the surplus, in stablecoins\n     */\n    function surplusOfDeposit(DInterest pool, uint64 depositID)\n        public\n        virtual\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        (isNegative, surplusAmount) = pool.rawSurplusOfDeposit(depositID);\n\n        DInterest.Deposit memory depositEntry = pool.getDeposit(depositID);\n        if (depositEntry.fundingID != 0) {\n            uint256 totalPrincipal =\n                _depositVirtualTokenToPrincipal(\n                    depositEntry,\n                    depositEntry.virtualTokenTotalSupply\n                );\n            uint256 principalPerToken =\n                pool.getFunding(depositEntry.fundingID).principalPerToken;\n            uint256 unfundedPrincipalAmount =\n                totalPrincipal -\n                    (pool.fundingMultitoken().totalSupply(\n                        depositEntry.fundingID\n                    ) * principalPerToken) /\n                    ULTRA_PRECISION;\n            surplusAmount =\n                (surplusAmount * unfundedPrincipalAmount) /\n                totalPrincipal;\n        }\n    }\n\n    /**\n        @dev Converts a virtual token value into the corresponding principal value.\n             Principal refers to deposit + full interest + fee.\n        @param depositEntry The deposit struct\n        @param virtualTokenAmount The virtual token value\n        @return The corresponding principal value\n     */\n    function _depositVirtualTokenToPrincipal(\n        DInterest.Deposit memory depositEntry,\n        uint256 virtualTokenAmount\n    ) internal pure virtual returns (uint256) {\n        uint256 depositInterestRate = depositEntry.interestRate;\n        return\n            virtualTokenAmount.decdiv(depositInterestRate + PRECISION).decmul(\n                depositInterestRate + depositEntry.feeRate + PRECISION\n            );\n    }\n}\n"
    },
    "contracts/mocks/CERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n    Modified from https://github.com/bugduino/idle-contracts/blob/master/contracts/mocks/cDAIMock.sol\n    at commit b85dafa8e55e053cb2d403fc4b28cfe86f2116d4\n\n    Original license:\n    Copyright 2020 Idle Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n */\n\npragma solidity 0.8.3;\n\n// interfaces\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract CERC20Mock is ERC20 {\n    address public dai;\n\n    uint256 internal _supplyRate;\n    uint256 internal _exchangeRate;\n\n    constructor(address _dai) ERC20(\"cDAI\", \"cDAI\") {\n        dai = _dai;\n        uint256 daiDecimals = ERC20(_dai).decimals();\n        _exchangeRate = 2 * (10**(daiDecimals + 8)); // 1 cDAI = 0.02 DAI\n        _supplyRate = 45290900000; // 10% supply rate per year\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n\n    function mint(uint256 amount) external returns (uint256) {\n        require(\n            ERC20(dai).transferFrom(msg.sender, address(this), amount),\n            \"Error during transferFrom\"\n        ); // 1 DAI\n        _mint(msg.sender, (amount * 10**18) / _exchangeRate);\n        return 0;\n    }\n\n    function redeemUnderlying(uint256 amount) external returns (uint256) {\n        _burn(msg.sender, (amount * 10**18) / _exchangeRate);\n        require(\n            ERC20(dai).transfer(msg.sender, amount),\n            \"Error during transfer\"\n        ); // 1 DAI\n        return 0;\n    }\n\n    function exchangeRateStored() external view returns (uint256) {\n        return _exchangeRate;\n    }\n\n    function exchangeRateCurrent() external view returns (uint256) {\n        return _exchangeRate;\n    }\n\n    function _setExchangeRateStored(uint256 _rate) external {\n        _exchangeRate = _rate;\n    }\n\n    function supplyRatePerBlock() external view returns (uint256) {\n        return _supplyRate;\n    }\n\n    function _setSupplyRatePerBlock(uint256 _rate) external {\n        _supplyRate = _rate;\n    }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20(\"\", \"\") {\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal pure override {\n        require(amount > 0, \"ERC20Mock: amount 0\");\n    }\n}\n"
    },
    "contracts/mocks/ComptrollerMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\n// interfaces\nimport {ERC20Mock} from \"./ERC20Mock.sol\";\n\ncontract ComptrollerMock {\n    uint256 public constant CLAIM_AMOUNT = 10**18;\n    ERC20Mock public comp;\n\n    constructor(address _comp) {\n        comp = ERC20Mock(_comp);\n    }\n\n    function claimComp(address holder) external {\n        comp.mint(holder, CLAIM_AMOUNT);\n    }\n\n    function getCompAddress() external view returns (address) {\n        return address(comp);\n    }\n}\n"
    },
    "contracts/mocks/RegistryMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\n// interfaces\nimport {ERC20Mock} from \"./ERC20Mock.sol\";\n\ncontract RegistryMock {\n    ERC20Mock public comp;\n\n    constructor(address _comp) {\n        comp = ERC20Mock(_comp);\n    }\n}\n"
    },
    "contracts/mocks/BComptrollerMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\n// interfaces\nimport {RegistryMock} from \"./RegistryMock.sol\";\n\ncontract BComptrollerMock {\n    uint256 public constant CLAIM_AMOUNT = 10**18;\n    RegistryMock public registry;\n\n    constructor(address _registry) {\n        registry = RegistryMock(_registry);\n    }\n\n    function claimComp(address holder) external {\n        registry.comp().mint(holder, CLAIM_AMOUNT);\n    }\n}\n"
    },
    "contracts/mocks/AaveMiningMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\n\n// interfaces\nimport {ERC20Mock} from \"./ERC20Mock.sol\";\n\ncontract AaveMiningMock {\n    uint256 public constant CLAIM_AMOUNT = 10**18;\n    ERC20Mock public aave;\n\n    constructor(address _aave) {\n        aave = ERC20Mock(_aave);\n    }\n\n    function claimRewards(\n        address[] calldata, /*assets*/\n        uint256, /*amount*/\n        address to\n    ) external returns (uint256) {\n        aave.mint(to, CLAIM_AMOUNT);\n        return CLAIM_AMOUNT;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}